<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Numo::GSL::Sf
  
    &mdash; Documentation by YARD 0.9.8
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Numo::GSL::Sf";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../x_index.html">Index (S)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Numo.html" title="Numo (module)">Numo</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../GSL.html" title="Numo::GSL (module)">GSL</a></span></span>
     &raquo; 
    <span class="title">Sf</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Numo::GSL::Sf
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>ext/numo/gsl/sf/gsl_sf.c</dd>
  </dl>
  
</div>

<h2>Defined Under Namespace</h2>
<p class="children">
  
    
  
    
      <strong class="classes">Classes:</strong> <span class='object_link'><a href="Sf/Mathieu.html" title="Numo::GSL::Sf::Mathieu (class)">Mathieu</a></span>
    
  
</p>







  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai-class_method" title="airy_Ai (class method)">.<strong>airy_Ai</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Ai(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv-class_method" title="airy_Ai_deriv (class method)">.<strong>airy_Ai_deriv</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Ai’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_e-class_method" title="airy_Ai_deriv_e (class method)">.<strong>airy_Ai_deriv_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Ai’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_scaled-class_method" title="airy_Ai_deriv_scaled (class method)">.<strong>airy_Ai_deriv_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_A(x) Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_scaled_e-class_method" title="airy_Ai_deriv_scaled_e (class method)">.<strong>airy_Ai_deriv_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_A(x) Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_e-class_method" title="airy_Ai_e (class method)">.<strong>airy_Ai_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Ai(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_scaled-class_method" title="airy_Ai_scaled (class method)">.<strong>airy_Ai_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_A(x) Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_scaled_e-class_method" title="airy_Ai_scaled_e (class method)">.<strong>airy_Ai_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_A(x) Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi-class_method" title="airy_Bi (class method)">.<strong>airy_Bi</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Bi(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv-class_method" title="airy_Bi_deriv (class method)">.<strong>airy_Bi_deriv</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Bi’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_e-class_method" title="airy_Bi_deriv_e (class method)">.<strong>airy_Bi_deriv_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Bi’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_scaled-class_method" title="airy_Bi_deriv_scaled (class method)">.<strong>airy_Bi_deriv_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_B(x) Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_scaled_e-class_method" title="airy_Bi_deriv_scaled_e (class method)">.<strong>airy_Bi_deriv_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_B(x) Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_e-class_method" title="airy_Bi_e (class method)">.<strong>airy_Bi_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Bi(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_scaled-class_method" title="airy_Bi_scaled (class method)">.<strong>airy_Bi_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_B(x) Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_scaled_e-class_method" title="airy_Bi_scaled_e (class method)">.<strong>airy_Bi_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_B(x) Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai-class_method" title="airy_zero_Ai (class method)">.<strong>airy_zero_Ai</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_deriv-class_method" title="airy_zero_Ai_deriv (class method)">.<strong>airy_zero_Ai_deriv</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_deriv_e-class_method" title="airy_zero_Ai_deriv_e (class method)">.<strong>airy_zero_Ai_deriv_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_e-class_method" title="airy_zero_Ai_e (class method)">.<strong>airy_zero_Ai_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi-class_method" title="airy_zero_Bi (class method)">.<strong>airy_zero_Bi</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_deriv-class_method" title="airy_zero_Bi_deriv (class method)">.<strong>airy_zero_Bi_deriv</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_deriv_e-class_method" title="airy_zero_Bi_deriv_e (class method)">.<strong>airy_zero_Bi_deriv_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_e-class_method" title="airy_zero_Bi_e (class method)">.<strong>airy_zero_Bi_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#angle_restrict_pos-class_method" title="angle_restrict_pos (class method)">.<strong>angle_restrict_pos</strong>(theta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines force the angle theta to lie in the range [0, 2\pi).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#angle_restrict_symm-class_method" title="angle_restrict_symm (class method)">.<strong>angle_restrict_symm</strong>(theta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines force the angle theta to lie in the range (-\pi,\pi].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#atanint-class_method" title="atanint (class method)">.<strong>atanint</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$ AtanInt(x) = \int_0^x dt \arctan(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#atanint_e-class_method" title="atanint_e (class method)">.<strong>atanint_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$ AtanInt(x) = \int_0^x dt \arctan(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0-class_method" title="bessel_I0 (class method)">.<strong>bessel_I0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_e-class_method" title="bessel_I0_e (class method)">.<strong>bessel_I0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_scaled-class_method" title="bessel_I0_scaled (class method)">.<strong>bessel_I0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \exp(-</td>
      <td>x</td>
      <td>) I_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i0_scaled-class_method" title="bessel_i0_scaled (class method)">.<strong>bessel_i0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of zeroth order, \exp(-</td>
      <td>x</td>
      <td>) i_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_scaled_e-class_method" title="bessel_I0_scaled_e (class method)">.<strong>bessel_I0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \exp(-</td>
      <td>x</td>
      <td>) I_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i0_scaled_e-class_method" title="bessel_i0_scaled_e (class method)">.<strong>bessel_i0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of zeroth order, \exp(-</td>
      <td>x</td>
      <td>) i_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1-class_method" title="bessel_I1 (class method)">.<strong>bessel_I1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_e-class_method" title="bessel_I1_e (class method)">.<strong>bessel_I1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_scaled-class_method" title="bessel_I1_scaled (class method)">.<strong>bessel_I1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of first order \exp(-</td>
      <td>x</td>
      <td>) I_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i1_scaled-class_method" title="bessel_i1_scaled (class method)">.<strong>bessel_i1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of first order, \exp(-</td>
      <td>x</td>
      <td>) i_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_scaled_e-class_method" title="bessel_I1_scaled_e (class method)">.<strong>bessel_I1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of first order \exp(-</td>
      <td>x</td>
      <td>) I_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i1_scaled_e-class_method" title="bessel_i1_scaled_e (class method)">.<strong>bessel_i1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of first order, \exp(-</td>
      <td>x</td>
      <td>) i_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i2_scaled-class_method" title="bessel_i2_scaled (class method)">.<strong>bessel_i2_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of second order,  \exp(-</td>
      <td>x</td>
      <td>) i_2(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i2_scaled_e-class_method" title="bessel_i2_scaled_e (class method)">.<strong>bessel_i2_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of second order,  \exp(-</td>
      <td>x</td>
      <td>) i_2(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled-class_method" title="bessel_il_scaled (class method)">.<strong>bessel_il_scaled</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of order l,  \exp(-</td>
      <td>x</td>
      <td>) i_l(x) Domain: l &gt;= 0 Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled_array-class_method" title="bessel_il_scaled_array (class method)">.<strong>bessel_il_scaled_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This routine computes the values of the scaled regular modified spherical Bessel functions \exp(-</td>
      <td>x</td>
      <td>) i_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0, storing the results in the array result_array.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled_e-class_method" title="bessel_il_scaled_e (class method)">.<strong>bessel_il_scaled_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of order l,  \exp(-</td>
      <td>x</td>
      <td>) i_l(x) Domain: l &gt;= 0 Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In-class_method" title="bessel_In (class method)">.<strong>bessel_In</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of order n, I_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_array-class_method" title="bessel_In_array (class method)">.<strong>bessel_In_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular modified cylindrical Bessel functions I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_e-class_method" title="bessel_In_e (class method)">.<strong>bessel_In_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of order n, I_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled-class_method" title="bessel_In_scaled (class method)">.<strong>bessel_In_scaled</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of order n, \exp(-</td>
      <td>x</td>
      <td>) I_n(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled_array-class_method" title="bessel_In_scaled_array (class method)">.<strong>bessel_In_scaled_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This routine computes the values of the scaled regular cylindrical Bessel functions \exp(-</td>
      <td>x</td>
      <td>) I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled_e-class_method" title="bessel_In_scaled_e (class method)">.<strong>bessel_In_scaled_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of order n, \exp(-</td>
      <td>x</td>
      <td>) I_n(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu-class_method" title="bessel_Inu (class method)">.<strong>bessel_Inu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified Bessel function of fractional order \nu, I_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_e-class_method" title="bessel_Inu_e (class method)">.<strong>bessel_Inu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified Bessel function of fractional order \nu, I_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_scaled-class_method" title="bessel_Inu_scaled (class method)">.<strong>bessel_Inu_scaled</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified Bessel function of fractional order \nu, \exp(-</td>
      <td>x</td>
      <td>)I_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_scaled_e-class_method" title="bessel_Inu_scaled_e (class method)">.<strong>bessel_Inu_scaled_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified Bessel function of fractional order \nu, \exp(-</td>
      <td>x</td>
      <td>)I_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J0-class_method" title="bessel_J0 (class method)">.<strong>bessel_J0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j0-class_method" title="bessel_j0 (class method)">.<strong>bessel_j0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of zeroth order, j_0(x) = \sin(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J0_e-class_method" title="bessel_J0_e (class method)">.<strong>bessel_J0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j0_e-class_method" title="bessel_j0_e (class method)">.<strong>bessel_j0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of zeroth order, j_0(x) = \sin(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J1-class_method" title="bessel_J1 (class method)">.<strong>bessel_J1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of first order, J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j1-class_method" title="bessel_j1 (class method)">.<strong>bessel_j1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of first order, j_1(x) = (\sin(x)/x - \cos(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J1_e-class_method" title="bessel_J1_e (class method)">.<strong>bessel_J1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of first order, J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j1_e-class_method" title="bessel_j1_e (class method)">.<strong>bessel_j1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of first order, j_1(x) = (\sin(x)/x - \cos(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j2-class_method" title="bessel_j2 (class method)">.<strong>bessel_j2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j2_e-class_method" title="bessel_j2_e (class method)">.<strong>bessel_j2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl-class_method" title="bessel_jl (class method)">.<strong>bessel_jl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of order l, j_l(x), for $l \geq 0$ l &gt;= 0 and $x \geq 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_array-class_method" title="bessel_jl_array (class method)">.<strong>bessel_jl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive  for $lmax \geq 0$ lmax &gt;= 0 and $x \geq 0$ x &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_e-class_method" title="bessel_jl_e (class method)">.<strong>bessel_jl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of order l, j_l(x), for $l \geq 0$ l &gt;= 0 and $x \geq 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_steed_array-class_method" title="bessel_jl_steed_array (class method)">.<strong>bessel_jl_steed_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine uses Steed’s method to compute the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0 and $x \geq 0$ x &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn-class_method" title="bessel_Jn (class method)">.<strong>bessel_Jn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of order n, J_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn_array-class_method" title="bessel_Jn_array (class method)">.<strong>bessel_Jn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular cylindrical Bessel functions J_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn_e-class_method" title="bessel_Jn_e (class method)">.<strong>bessel_Jn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of order n, J_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jnu-class_method" title="bessel_Jnu (class method)">.<strong>bessel_Jnu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of fractional order \nu, J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jnu_e-class_method" title="bessel_Jnu_e (class method)">.<strong>bessel_Jnu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of fractional order \nu, J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0-class_method" title="bessel_K0 (class method)">.<strong>bessel_K0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_e-class_method" title="bessel_K0_e (class method)">.<strong>bessel_K0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_scaled-class_method" title="bessel_K0_scaled (class method)">.<strong>bessel_K0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \exp(x) K_0(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k0_scaled-class_method" title="bessel_k0_scaled (class method)">.<strong>bessel_k0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of zeroth order, \exp(x) k_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_scaled_e-class_method" title="bessel_K0_scaled_e (class method)">.<strong>bessel_K0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \exp(x) K_0(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k0_scaled_e-class_method" title="bessel_k0_scaled_e (class method)">.<strong>bessel_k0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of zeroth order, \exp(x) k_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1-class_method" title="bessel_K1 (class method)">.<strong>bessel_K1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_e-class_method" title="bessel_K1_e (class method)">.<strong>bessel_K1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_scaled-class_method" title="bessel_K1_scaled (class method)">.<strong>bessel_K1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of first order \exp(x) K_1(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k1_scaled-class_method" title="bessel_k1_scaled (class method)">.<strong>bessel_k1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of first order, \exp(x) k_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_scaled_e-class_method" title="bessel_K1_scaled_e (class method)">.<strong>bessel_K1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of first order \exp(x) K_1(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k1_scaled_e-class_method" title="bessel_k1_scaled_e (class method)">.<strong>bessel_k1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of first order, \exp(x) k_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k2_scaled-class_method" title="bessel_k2_scaled (class method)">.<strong>bessel_k2_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of second order, \exp(x) k_2(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k2_scaled_e-class_method" title="bessel_k2_scaled_e (class method)">.<strong>bessel_k2_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of second order, \exp(x) k_2(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled-class_method" title="bessel_kl_scaled (class method)">.<strong>bessel_kl_scaled</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of order l, \exp(x) k_l(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled_array-class_method" title="bessel_kl_scaled_array (class method)">.<strong>bessel_kl_scaled_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the scaled irregular modified spherical Bessel functions \exp(x) k_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0 and x&gt;0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled_e-class_method" title="bessel_kl_scaled_e (class method)">.<strong>bessel_kl_scaled_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of order l, \exp(x) k_l(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn-class_method" title="bessel_Kn (class method)">.<strong>bessel_Kn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_array-class_method" title="bessel_Kn_array (class method)">.<strong>bessel_Kn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular modified cylindrical Bessel functions K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_e-class_method" title="bessel_Kn_e (class method)">.<strong>bessel_Kn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled-class_method" title="bessel_Kn_scaled (class method)">.<strong>bessel_Kn_scaled</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of order n, \exp(x) K_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled_array-class_method" title="bessel_Kn_scaled_array (class method)">.<strong>bessel_Kn_scaled_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the scaled irregular cylindrical Bessel functions \exp(x) K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled_e-class_method" title="bessel_Kn_scaled_e (class method)">.<strong>bessel_Kn_scaled_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of order n, \exp(x) K_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu-class_method" title="bessel_Knu (class method)">.<strong>bessel_Knu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified Bessel function of fractional order \nu, K_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_e-class_method" title="bessel_Knu_e (class method)">.<strong>bessel_Knu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified Bessel function of fractional order \nu, K_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_scaled-class_method" title="bessel_Knu_scaled (class method)">.<strong>bessel_Knu_scaled</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled irregular modified Bessel function of fractional order \nu, \exp(+</td>
      <td>x</td>
      <td>) K_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_scaled_e-class_method" title="bessel_Knu_scaled_e (class method)">.<strong>bessel_Knu_scaled_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled irregular modified Bessel function of fractional order \nu, \exp(+</td>
      <td>x</td>
      <td>) K_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_lnKnu-class_method" title="bessel_lnKnu (class method)">.<strong>bessel_lnKnu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the irregular modified Bessel function of fractional order \nu, \ln(K_\nu(x)) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_lnKnu_e-class_method" title="bessel_lnKnu_e (class method)">.<strong>bessel_lnKnu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the irregular modified Bessel function of fractional order \nu, \ln(K_\nu(x)) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y0-class_method" title="bessel_Y0 (class method)">.<strong>bessel_Y0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y0-class_method" title="bessel_y0 (class method)">.<strong>bessel_y0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = -\cos(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y0_e-class_method" title="bessel_Y0_e (class method)">.<strong>bessel_Y0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y0_e-class_method" title="bessel_y0_e (class method)">.<strong>bessel_y0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = -\cos(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y1-class_method" title="bessel_Y1 (class method)">.<strong>bessel_Y1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y1-class_method" title="bessel_y1 (class method)">.<strong>bessel_y1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of first order, y_1(x) = -(\cos(x)/x + \sin(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y1_e-class_method" title="bessel_Y1_e (class method)">.<strong>bessel_Y1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y1_e-class_method" title="bessel_y1_e (class method)">.<strong>bessel_y1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of first order, y_1(x) = -(\cos(x)/x + \sin(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y2-class_method" title="bessel_y2 (class method)">.<strong>bessel_y2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y2_e-class_method" title="bessel_y2_e (class method)">.<strong>bessel_y2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl-class_method" title="bessel_yl (class method)">.<strong>bessel_yl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of order l, y_l(x), for $l \geq 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl_array-class_method" title="bessel_yl_array (class method)">.<strong>bessel_yl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular spherical Bessel functions y_l(x) for l from 0 to lmax inclusive  for $lmax \geq 0$ lmax &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl_e-class_method" title="bessel_yl_e (class method)">.<strong>bessel_yl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of order l, y_l(x), for $l \geq 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn-class_method" title="bessel_Yn (class method)">.<strong>bessel_Yn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn_array-class_method" title="bessel_Yn_array (class method)">.<strong>bessel_Yn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular cylindrical Bessel functions Y_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn_e-class_method" title="bessel_Yn_e (class method)">.<strong>bessel_Yn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Ynu-class_method" title="bessel_Ynu (class method)">.<strong>bessel_Ynu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of fractional order \nu, Y_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Ynu_e-class_method" title="bessel_Ynu_e (class method)">.<strong>bessel_Ynu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of fractional order \nu, Y_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J0-class_method" title="bessel_zero_J0 (class method)">.<strong>bessel_zero_J0</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J0_e-class_method" title="bessel_zero_J0_e (class method)">.<strong>bessel_zero_J0_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J1-class_method" title="bessel_zero_J1 (class method)">.<strong>bessel_zero_J1</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J1_e-class_method" title="bessel_zero_J1_e (class method)">.<strong>bessel_zero_J1_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_Jnu-class_method" title="bessel_zero_Jnu (class method)">.<strong>bessel_zero_Jnu</strong>(nu, s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_Jnu_e-class_method" title="bessel_zero_Jnu_e (class method)">.<strong>bessel_zero_Jnu_e</strong>(nu, s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta-class_method" title="beta (class method)">.<strong>beta</strong>(a, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Beta Function, B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_e-class_method" title="beta_e (class method)">.<strong>beta_e</strong>(a, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Beta Function, B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_inc-class_method" title="beta_inc (class method)">.<strong>beta_inc</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$ B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt for $0 \le x \le 1$ 0 &lt;= x &lt;= 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_inc_e-class_method" title="beta_inc_e (class method)">.<strong>beta_inc_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$ B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt for $0 \le x \le 1$ 0 &lt;= x &lt;= 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Chi-class_method" title="Chi (class method)">.<strong>Chi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Sf.Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$ Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] , where \gamma_E is the Euler constant (available as the macro M_EULER).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Chi_e-class_method" title="Chi_e (class method)">.<strong>Chi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Sf.Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$ Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] , where \gamma_E is the Euler constant (available as the macro M_EULER).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#choose-class_method" title="choose (class method)">.<strong>choose</strong>(n, m)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the combinatorial factor n choose m = n!/(m!(n-m)!) exceptions: GSL_EDOM, GSL_EOVRFLW.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#choose_e-class_method" title="choose_e (class method)">.<strong>choose_e</strong>(n, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the combinatorial factor n choose m = n!/(m!(n-m)!) exceptions: GSL_EDOM, GSL_EOVRFLW.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Ci-class_method" title="Ci (class method)">.<strong>Ci</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Sf.Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$ Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Ci_e-class_method" title="Ci_e (class method)">.<strong>Ci_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Sf.Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$ Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clausen-class_method" title="clausen (class method)">.<strong>clausen</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Clausen integral Cl_2(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clausen_e-class_method" title="clausen_e (class method)">.<strong>clausen_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Clausen integral Cl_2(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_cos_e-class_method" title="complex_cos_e (class method)">.<strong>complex_cos_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the complex cosine, \cos(z_r + i z_i) storing the real and imaginary parts in czr, czi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_dilog_e-class_method" title="complex_dilog_e (class method)">.<strong>complex_dilog_e</strong>(r, theta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the full complex-valued dilogarithm for the complex argument z = r \exp(i \theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_log_e-class_method" title="complex_log_e (class method)">.<strong>complex_log_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the complex logarithm of z = z_r + i z_i.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_logsin_e-class_method" title="complex_logsin_e (class method)">.<strong>complex_logsin_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the logarithm of the complex sine, \log(\sin(z_r + i z_i)) storing the real and imaginary parts in lszr, lszi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_sin_e-class_method" title="complex_sin_e (class method)">.<strong>complex_sin_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the complex sine, \sin(z_r + i z_i) storing the real and imaginary parts in szr, szi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_0-class_method" title="conicalP_0 (class method)">.<strong>conicalP_0</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^0<em>+ i \lambda(x)$ P^0</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_0_e-class_method" title="conicalP_0_e (class method)">.<strong>conicalP_0_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^0<em>+ i \lambda(x)$ P^0</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_1-class_method" title="conicalP_1 (class method)">.<strong>conicalP_1</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^1<em>+ i \lambda(x)$ P^1</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_1_e-class_method" title="conicalP_1_e (class method)">.<strong>conicalP_1_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^1<em>+ i \lambda(x)$ P^1</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_cyl_reg-class_method" title="conicalP_cyl_reg (class method)">.<strong>conicalP_cyl_reg</strong>(m, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Cylindrical Conical Function $P^-m<em>+ i \lambda(x)$ P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$ m &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_cyl_reg_e-class_method" title="conicalP_cyl_reg_e (class method)">.<strong>conicalP_cyl_reg_e</strong>(m, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Cylindrical Conical Function $P^-m<em>+ i \lambda(x)$ P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$ m &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_half-class_method" title="conicalP_half (class method)">.<strong>conicalP_half</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular Spherical Conical Function $P^1/2<em>+ i \lambda(x)$ P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_half_e-class_method" title="conicalP_half_e (class method)">.<strong>conicalP_half_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular Spherical Conical Function $P^1/2<em>+ i \lambda(x)$ P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_mhalf-class_method" title="conicalP_mhalf (class method)">.<strong>conicalP_mhalf</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular Spherical Conical Function $P^-1/2<em>+ i \lambda(x)$ P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_mhalf_e-class_method" title="conicalP_mhalf_e (class method)">.<strong>conicalP_mhalf_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular Spherical Conical Function $P^-1/2<em>+ i \lambda(x)$ P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_sph_reg-class_method" title="conicalP_sph_reg (class method)">.<strong>conicalP_sph_reg</strong>(l, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Spherical Conical Function $P^-1/2-l<em>+ i \lambda(x)$ P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$ l &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_sph_reg_e-class_method" title="conicalP_sph_reg_e (class method)">.<strong>conicalP_sph_reg_e</strong>(l, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Spherical Conical Function $P^-1/2-l<em>+ i \lambda(x)$ P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$ l &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos-class_method" title="cos (class method)">.<strong>cos</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the cosine function \cos(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos_e-class_method" title="cos_e (class method)">.<strong>cos_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the cosine function \cos(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos_err_e-class_method" title="cos_err_e (class method)">.<strong>cos_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the cosine of an angle x with an associated absolute error dx, $\cos(x \pm dx)$ \cos(x \pm dx).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_CL_array-class_method" title="coulomb_CL_array (class method)">.<strong>coulomb_CL_array</strong>(Lmin, kmax, eta)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function normalization constant C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_CL_e-class_method" title="coulomb_CL_e (class method)">.<strong>coulomb_CL_e</strong>(L, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function normalization constant C_L(\eta) for L &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_F_array-class_method" title="coulomb_wave_F_array (class method)">.<strong>coulomb_wave_F_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function F_L(\eta,x) for L = Lmin \dots Lmin + kmax, storing the results in fc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FG_array-class_method" title="coulomb_wave_FG_array (class method)">.<strong>coulomb_wave_FG_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the functions F_L(\eta,x), G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the results in fc_array and gc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FG_e-class_method" title="coulomb_wave_FG_e (class method)">.<strong>coulomb_wave_FG_e</strong>(eta, x, L_F, k)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave functions F_L(\eta,x), $G_L-k(\eta,x)$ G_@L-k@(\eta,x) and their derivatives F’<em>L(\eta,x), $G’</em>L-k(\eta,x)$ G’_@L-k@(\eta,x) with respect to x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FGp_array-class_method" title="coulomb_wave_FGp_array (class method)">.<strong>coulomb_wave_FGp_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the functions F_L(\eta,x), G_L(\eta,x) and their derivatives F’_L(\eta,x), G’_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the results in fc_array, gc_array, fcp_array and gcp_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_sphF_array-class_method" title="coulomb_wave_sphF_array (class method)">.<strong>coulomb_wave_sphF_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function divided by the argument F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the results in fc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_3j-class_method" title="coupling_3j (class method)">.<strong>coupling_3j</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 3-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_3j_e-class_method" title="coupling_3j_e (class method)">.<strong>coupling_3j_e</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 3-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_6j-class_method" title="coupling_6j (class method)">.<strong>coupling_6j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 6-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_6j_e-class_method" title="coupling_6j_e (class method)">.<strong>coupling_6j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 6-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_9j-class_method" title="coupling_9j (class method)">.<strong>coupling_9j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 9-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_9j_e-class_method" title="coupling_9j_e (class method)">.<strong>coupling_9j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 9-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dawson-class_method" title="dawson (class method)">.<strong>dawson</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the value of Dawson’s integral for x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dawson_e-class_method" title="dawson_e (class method)">.<strong>dawson_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the value of Dawson’s integral for x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_1-class_method" title="debye_1 (class method)">.<strong>debye_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first-order Debye function D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_1_e-class_method" title="debye_1_e (class method)">.<strong>debye_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first-order Debye function D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_2-class_method" title="debye_2 (class method)">.<strong>debye_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order Debye function D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_2_e-class_method" title="debye_2_e (class method)">.<strong>debye_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order Debye function D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_3-class_method" title="debye_3 (class method)">.<strong>debye_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order Debye function D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_3_e-class_method" title="debye_3_e (class method)">.<strong>debye_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order Debye function D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_4-class_method" title="debye_4 (class method)">.<strong>debye_4</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_4_e-class_method" title="debye_4_e (class method)">.<strong>debye_4_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_5-class_method" title="debye_5 (class method)">.<strong>debye_5</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_5_e-class_method" title="debye_5_e (class method)">.<strong>debye_5_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_6-class_method" title="debye_6 (class method)">.<strong>debye_6</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_6_e-class_method" title="debye_6_e (class method)">.<strong>debye_6_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dilog-class_method" title="dilog (class method)">.<strong>dilog</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the dilogarithm for a real argument.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dilog_e-class_method" title="dilog_e (class method)">.<strong>dilog_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the dilogarithm for a real argument.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#doublefact-class_method" title="doublefact (class method)">.<strong>doublefact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#doublefact_e-class_method" title="doublefact_e (class method)">.<strong>doublefact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_D-class_method" title="ellint_D (class method)">.<strong>ellint_D</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the incomplete elliptic integral D(\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_D_e-class_method" title="ellint_D_e (class method)">.<strong>ellint_D_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the incomplete elliptic integral D(\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_E-class_method" title="ellint_E (class method)">.<strong>ellint_E</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral E(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_E_e-class_method" title="ellint_E_e (class method)">.<strong>ellint_E_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral E(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Ecomp-class_method" title="ellint_Ecomp (class method)">.<strong>ellint_Ecomp</strong>(k[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Ecomp_e-class_method" title="ellint_Ecomp_e (class method)">.<strong>ellint_Ecomp_e</strong>(k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_F-class_method" title="ellint_F (class method)">.<strong>ellint_F</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral F(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_F_e-class_method" title="ellint_F_e (class method)">.<strong>ellint_F_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral F(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Kcomp-class_method" title="ellint_Kcomp (class method)">.<strong>ellint_Kcomp</strong>(k[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Kcomp_e-class_method" title="ellint_Kcomp_e (class method)">.<strong>ellint_Kcomp_e</strong>(k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_P-class_method" title="ellint_P (class method)">.<strong>ellint_P</strong>(phi, k, n, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_P_e-class_method" title="ellint_P_e (class method)">.<strong>ellint_P_e</strong>(phi, k, n, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Pcomp-class_method" title="ellint_Pcomp (class method)">.<strong>ellint_Pcomp</strong>(k, n, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral \Pi(k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Pcomp_e-class_method" title="ellint_Pcomp_e (class method)">.<strong>ellint_Pcomp_e</strong>(k, n, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral \Pi(k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RC-class_method" title="ellint_RC (class method)">.<strong>ellint_RC</strong>(x, y, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RC_e-class_method" title="ellint_RC_e (class method)">.<strong>ellint_RC_e</strong>(x, y, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RD-class_method" title="ellint_RD (class method)">.<strong>ellint_RD</strong>(x, y, z, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RD_e-class_method" title="ellint_RD_e (class method)">.<strong>ellint_RD_e</strong>(x, y, z, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RF-class_method" title="ellint_RF (class method)">.<strong>ellint_RF</strong>(x, y, z, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RF_e-class_method" title="ellint_RF_e (class method)">.<strong>ellint_RF_e</strong>(x, y, z, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RJ-class_method" title="ellint_RJ (class method)">.<strong>ellint_RJ</strong>(x, y, z, p, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RJ_e-class_method" title="ellint_RJ_e (class method)">.<strong>ellint_RJ_e</strong>(x, y, z, p, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#elljac_e-class_method" title="elljac_e (class method)">.<strong>elljac_e</strong>(u, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This function computes the Jacobian elliptic functions sn(u</td>
      <td>m), cn(u</td>
      <td>m), dn(u</td>
      <td>m) by descending Landen transformations.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf-class_method" title="erf (class method)">.<strong>erf</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the error function $\erf(x)$ erf(x), where $\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$ erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_e-class_method" title="erf_e (class method)">.<strong>erf_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the error function $\erf(x)$ erf(x), where $\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$ erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Q-class_method" title="erf_Q (class method)">.<strong>erf_Q</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the upper tail of the Gaussian probability function $Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$ Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Q_e-class_method" title="erf_Q_e (class method)">.<strong>erf_Q_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the upper tail of the Gaussian probability function $Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$ Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Z-class_method" title="erf_Z (class method)">.<strong>erf_Z</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gaussian probability density function $Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$ Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Z_e-class_method" title="erf_Z_e (class method)">.<strong>erf_Z_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gaussian probability density function $Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$ Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erfc-class_method" title="erfc (class method)">.<strong>erfc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary error function $\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$ erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erfc_e-class_method" title="erfc_e (class method)">.<strong>erfc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary error function $\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$ erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta-class_method" title="eta (class method)">.<strong>eta</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(s) for arbitrary s.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_e-class_method" title="eta_e (class method)">.<strong>eta_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(s) for arbitrary s.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_int-class_method" title="eta_int (class method)">.<strong>eta_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(n) for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_int_e-class_method" title="eta_int_e (class method)">.<strong>eta_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(n) for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp-class_method" title="exp (class method)">.<strong>exp</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines provide an exponential function \exp(x) using GSL semantics and error checking.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_e-class_method" title="exp_e (class method)">.<strong>exp_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines provide an exponential function \exp(x) using GSL semantics and error checking.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_e10_e-class_method" title="exp_e10_e (class method)">.<strong>exp_e10_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the exponential \exp(x) using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_err_e-class_method" title="exp_err_e (class method)">.<strong>exp_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function exponentiates x with an associated absolute error dx.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_err_e10_e-class_method" title="exp_err_e10_e (class method)">.<strong>exp_err_e10_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function exponentiates a quantity x with an associated absolute error dx using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult-class_method" title="exp_mult (class method)">.<strong>exp_mult</strong>(x, y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines exponentiate x and multiply by the factor y to return the product y \exp(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_e-class_method" title="exp_mult_e (class method)">.<strong>exp_mult_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines exponentiate x and multiply by the factor y to return the product y \exp(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_e10_e-class_method" title="exp_mult_e10_e (class method)">.<strong>exp_mult_e10_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the product y \exp(x) using the gsl_sf_result_e10 type to return a result with extended numeric range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_err_e-class_method" title="exp_mult_err_e (class method)">.<strong>exp_mult_err_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the product y \exp(x) for the quantities x, y with associated absolute errors dx, dy.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_err_e10_e-class_method" title="exp_mult_err_e10_e (class method)">.<strong>exp_mult_err_e10_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the product y \exp(x) for the quantities x, y with associated absolute errors dx, dy using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_3-class_method" title="expint_3 (class method)">.<strong>expint_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$ Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_3_e-class_method" title="expint_3_e (class method)">.<strong>expint_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$ Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E1-class_method" title="expint_E1 (class method)">.<strong>expint_E1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_1(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E1_e-class_method" title="expint_E1_e (class method)">.<strong>expint_E1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_1(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E2-class_method" title="expint_E2 (class method)">.<strong>expint_E2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order exponential integral E_2(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E2_e-class_method" title="expint_E2_e (class method)">.<strong>expint_E2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order exponential integral E_2(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_Ei-class_method" title="expint_Ei (class method)">.<strong>expint_Ei</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral $\hboxEi(x)$ Ei(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_Ei_e-class_method" title="expint_Ei_e (class method)">.<strong>expint_Ei_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral $\hboxEi(x)$ Ei(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_En-class_method" title="expint_En (class method)">.<strong>expint_En</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_n(x) of order n,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_En_e-class_method" title="expint_En_e (class method)">.<strong>expint_En_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_n(x) of order n,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expm1-class_method" title="expm1 (class method)">.<strong>expm1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity \exp(x)-1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expm1_e-class_method" title="expm1_e (class method)">.<strong>expm1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity \exp(x)-1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel-class_method" title="exprel (class method)">.<strong>exprel</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity (\exp(x)-1)/x using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_2-class_method" title="exprel_2 (class method)">.<strong>exprel_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_2_e-class_method" title="exprel_2_e (class method)">.<strong>exprel_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_e-class_method" title="exprel_e (class method)">.<strong>exprel_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity (\exp(x)-1)/x using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_n-class_method" title="exprel_n (class method)">.<strong>exprel_n</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_n_e-class_method" title="exprel_n_e (class method)">.<strong>exprel_n_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fact-class_method" title="fact (class method)">.<strong>fact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the factorial n!.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fact_e-class_method" title="fact_e (class method)">.<strong>fact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the factorial n!.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_0-class_method" title="fermi_dirac_0 (class method)">.<strong>fermi_dirac_0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_0_e-class_method" title="fermi_dirac_0_e (class method)">.<strong>fermi_dirac_0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_1-class_method" title="fermi_dirac_1 (class method)">.<strong>fermi_dirac_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_1_e-class_method" title="fermi_dirac_1_e (class method)">.<strong>fermi_dirac_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_2-class_method" title="fermi_dirac_2 (class method)">.<strong>fermi_dirac_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_2_e-class_method" title="fermi_dirac_2_e (class method)">.<strong>fermi_dirac_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_3half-class_method" title="fermi_dirac_3half (class method)">.<strong>fermi_dirac_3half</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_3/2(x)$ F_@3/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_3half_e-class_method" title="fermi_dirac_3half_e (class method)">.<strong>fermi_dirac_3half_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_3/2(x)$ F_@3/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_half-class_method" title="fermi_dirac_half (class method)">.<strong>fermi_dirac_half</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_1/2(x)$ F_@1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_half_e-class_method" title="fermi_dirac_half_e (class method)">.<strong>fermi_dirac_half_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_1/2(x)$ F_@1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_inc_0-class_method" title="fermi_dirac_inc_0 (class method)">.<strong>fermi_dirac_inc_0</strong>(x, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, $F_0(x,b) = \ln(1 + e^b-x) - (b-x)$ F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_inc_0_e-class_method" title="fermi_dirac_inc_0_e (class method)">.<strong>fermi_dirac_inc_0_e</strong>(x, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, $F_0(x,b) = \ln(1 + e^b-x) - (b-x)$ F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_int-class_method" title="fermi_dirac_int (class method)">.<strong>fermi_dirac_int</strong>(j, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_int_e-class_method" title="fermi_dirac_int_e (class method)">.<strong>fermi_dirac_int_e</strong>(j, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_m1-class_method" title="fermi_dirac_m1 (class method)">.<strong>fermi_dirac_m1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_m1_e-class_method" title="fermi_dirac_m1_e (class method)">.<strong>fermi_dirac_m1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_mhalf-class_method" title="fermi_dirac_mhalf (class method)">.<strong>fermi_dirac_mhalf</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_-1/2(x)$ F_@-1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_mhalf_e-class_method" title="fermi_dirac_mhalf_e (class method)">.<strong>fermi_dirac_mhalf_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_-1/2(x)$ F_@-1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma-class_method" title="gamma (class method)">.<strong>gamma</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gamma function \Gamma(x), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_e-class_method" title="gamma_e (class method)">.<strong>gamma_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gamma function \Gamma(x), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc-class_method" title="gamma_inc (class method)">.<strong>gamma_inc</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the unnormalized incomplete Gamma Function $\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$ \Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t) for a real and $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_e-class_method" title="gamma_inc_e (class method)">.<strong>gamma_inc_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the unnormalized incomplete Gamma Function $\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$ \Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t) for a real and $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_P-class_method" title="gamma_inc_P (class method)">.<strong>gamma_inc_P</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary normalized incomplete Gamma Function $P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$ P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_P_e-class_method" title="gamma_inc_P_e (class method)">.<strong>gamma_inc_P_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary normalized incomplete Gamma Function $P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$ P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_Q-class_method" title="gamma_inc_Q (class method)">.<strong>gamma_inc_Q</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Gamma Function $Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$ Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_Q_e-class_method" title="gamma_inc_Q_e (class method)">.<strong>gamma_inc_Q_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Gamma Function $Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$ Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammainv-class_method" title="gammainv (class method)">.<strong>gammainv</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the reciprocal of the gamma function, 1/\Gamma(x) using the real Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammainv_e-class_method" title="gammainv_e (class method)">.<strong>gammainv_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the reciprocal of the gamma function, 1/\Gamma(x) using the real Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammastar-class_method" title="gammastar (class method)">.<strong>gammastar</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regulated Gamma Function \Gamma^*(x) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammastar_e-class_method" title="gammastar_e (class method)">.<strong>gammastar_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regulated Gamma Function \Gamma^*(x) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_1-class_method" title="gegenpoly_1 (class method)">.<strong>gegenpoly_1</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_1_e-class_method" title="gegenpoly_1_e (class method)">.<strong>gegenpoly_1_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_2-class_method" title="gegenpoly_2 (class method)">.<strong>gegenpoly_2</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_2_e-class_method" title="gegenpoly_2_e (class method)">.<strong>gegenpoly_2_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_3-class_method" title="gegenpoly_3 (class method)">.<strong>gegenpoly_3</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_3_e-class_method" title="gegenpoly_3_e (class method)">.<strong>gegenpoly_3_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_array-class_method" title="gegenpoly_array (class method)">.<strong>gegenpoly_array</strong>(nmax, lambda, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an array of Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) for n = 0, 1, 2, \dots, nmax, subject to \lambda &gt; -1/2, $nmax \ge 0$ nmax &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_n-class_method" title="gegenpoly_n (class method)">.<strong>gegenpoly_n</strong>(n, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) for a specific value of n, lambda, x subject to \lambda &gt; -1/2, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_n_e-class_method" title="gegenpoly_n_e (class method)">.<strong>gegenpoly_n_e</strong>(n, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) for a specific value of n, lambda, x subject to \lambda &gt; -1/2, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hazard-class_method" title="hazard (class method)">.<strong>hazard</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hazard function for the normal distribution.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hazard_e-class_method" title="hazard_e (class method)">.<strong>hazard_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hazard function for the normal distribution.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR-class_method" title="hydrogenicR (class method)">.<strong>hydrogenicR</strong>(n, l, Z, r)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the n-th normalized hydrogenic bound state radial wavefunction,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_1-class_method" title="hydrogenicR_1 (class method)">.<strong>hydrogenicR_1</strong>(Z, r)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$ R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_1_e-class_method" title="hydrogenicR_1_e (class method)">.<strong>hydrogenicR_1_e</strong>(Z, r)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$ R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_e-class_method" title="hydrogenicR_e (class method)">.<strong>hydrogenicR_e</strong>(n, l, Z, r)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the n-th normalized hydrogenic bound state radial wavefunction,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_0F1-class_method" title="hyperg_0F1 (class method)">.<strong>hyperg_0F1</strong>(c, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_0F_1(c,x)$ 0F1(c,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_0F1_e-class_method" title="hyperg_0F1_e (class method)">.<strong>hyperg_0F1_e</strong>(c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_0F_1(c,x)$ 0F1(c,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1-class_method" title="hyperg_1F1 (class method)">.<strong>hyperg_1F1</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(a,b,x) = M(a,b,x)$ 1F1(a,b,x) = M(a,b,x) for general parameters a, b.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_e-class_method" title="hyperg_1F1_e (class method)">.<strong>hyperg_1F1_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(a,b,x) = M(a,b,x)$ 1F1(a,b,x) = M(a,b,x) for general parameters a, b.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_int-class_method" title="hyperg_1F1_int (class method)">.<strong>hyperg_1F1_int</strong>(m, n, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(m,n,x) = M(m,n,x)$ 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_int_e-class_method" title="hyperg_1F1_int_e (class method)">.<strong>hyperg_1F1_int_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(m,n,x) = M(m,n,x)$ 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F0-class_method" title="hyperg_2F0 (class method)">.<strong>hyperg_2F0</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$ 2F0(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F0_e-class_method" title="hyperg_2F0_e (class method)">.<strong>hyperg_2F0_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$ 2F0(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1-class_method" title="hyperg_2F1 (class method)">.<strong>hyperg_2F1</strong>(a, b, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a,b,c,x) = F(a,b,c,x)$ 2F1(a,b,c,x) = F(a,b,c,x) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj-class_method" title="hyperg_2F1_conj (class method)">.<strong>hyperg_2F1_conj</strong>(aR, aI, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a_R + i a_I, aR - i aI, c, x)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_e-class_method" title="hyperg_2F1_conj_e (class method)">.<strong>hyperg_2F1_conj_e</strong>(aR, aI, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a_R + i a_I, aR - i aI, c, x)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_renorm-class_method" title="hyperg_2F1_conj_renorm (class method)">.<strong>hyperg_2F1_conj_renorm</strong>(aR, aI, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_renorm_e-class_method" title="hyperg_2F1_conj_renorm_e (class method)">.<strong>hyperg_2F1_conj_renorm_e</strong>(aR, aI, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_e-class_method" title="hyperg_2F1_e (class method)">.<strong>hyperg_2F1_e</strong>(a, b, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a,b,c,x) = F(a,b,c,x)$ 2F1(a,b,c,x) = F(a,b,c,x) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_renorm-class_method" title="hyperg_2F1_renorm (class method)">.<strong>hyperg_2F1_renorm</strong>(a, b, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a,b,c,x) / \Gamma(c)$ 2F1(a,b,c,x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_renorm_e-class_method" title="hyperg_2F1_renorm_e (class method)">.<strong>hyperg_2F1_renorm_e</strong>(a, b, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a,b,c,x) / \Gamma(c)$ 2F1(a,b,c,x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U-class_method" title="hyperg_U (class method)">.<strong>hyperg_U</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_e-class_method" title="hyperg_U_e (class method)">.<strong>hyperg_U_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_e10_e-class_method" title="hyperg_U_e10_e (class method)">.<strong>hyperg_U_e10_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the confluent hypergeometric function U(a,b,x) using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int-class_method" title="hyperg_U_int (class method)">.<strong>hyperg_U_int</strong>(m, n, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int_e-class_method" title="hyperg_U_int_e (class method)">.<strong>hyperg_U_int_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int_e10_e-class_method" title="hyperg_U_int_e10_e (class method)">.<strong>hyperg_U_int_e10_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hypot-class_method" title="hypot (class method)">.<strong>hypot</strong>(x, y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypotenuse function $\sqrt+ y^2$ \sqrt@+ y^2@ avoiding overflow and underflow.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hypot_e-class_method" title="hypot_e (class method)">.<strong>hypot_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypotenuse function $\sqrt+ y^2$ \sqrt@+ y^2@ avoiding overflow and underflow.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hzeta-class_method" title="hzeta (class method)">.<strong>hzeta</strong>(s, q)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Hurwitz zeta function \zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hzeta_e-class_method" title="hzeta_e (class method)">.<strong>hzeta_e</strong>(s, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Hurwitz zeta function \zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_1-class_method" title="laguerre_1 (class method)">.<strong>laguerre_1</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_1_e-class_method" title="laguerre_1_e (class method)">.<strong>laguerre_1_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_2-class_method" title="laguerre_2 (class method)">.<strong>laguerre_2</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_2_e-class_method" title="laguerre_2_e (class method)">.<strong>laguerre_2_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_3-class_method" title="laguerre_3 (class method)">.<strong>laguerre_3</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_3_e-class_method" title="laguerre_3_e (class method)">.<strong>laguerre_3_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_n-class_method" title="laguerre_n (class method)">.<strong>laguerre_n</strong>(n, a, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_n_e-class_method" title="laguerre_n_e (class method)">.<strong>laguerre_n_e</strong>(n, a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_W0-class_method" title="lambert_W0 (class method)">.<strong>lambert_W0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the principal branch of the Lambert W function, W_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_W0_e-class_method" title="lambert_W0_e (class method)">.<strong>lambert_W0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the principal branch of the Lambert W function, W_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_Wm1-class_method" title="lambert_Wm1 (class method)">.<strong>lambert_Wm1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the secondary real-valued branch of the Lambert W function, $W_-1(x)$ W_@-1@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_Wm1_e-class_method" title="lambert_Wm1_e (class method)">.<strong>lambert_Wm1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the secondary real-valued branch of the Lambert W function, $W_-1(x)$ W_@-1@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array-class_method" title="legendre_array (class method)">.<strong>legendre_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre polynomials for 0 \le l \le lmax and 0 \le m \le l for $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_e-class_method" title="legendre_array_e (class method)">.<strong>legendre_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre polynomials for 0 \le l \le lmax and 0 \le m \le l for $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_index-class_method" title="legendre_array_index (class method)">.<strong>legendre_array_index</strong>(l, m)  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index into result_array, result_deriv_array, or result_deriv2_array corresponding to P_l^m(x), P_l^‘m(x), or P_l^‘‘m(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_n-class_method" title="legendre_array_n (class method)">.<strong>legendre_array_n</strong>(lmax)  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the minimum array size for maximum degree lmax needed for the array versions of the associated Legendre functions.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_alt_array-class_method" title="legendre_deriv2_alt_array (class method)">.<strong>legendre_deriv2_alt_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_alt_array_e-class_method" title="legendre_deriv2_alt_array_e (class method)">.<strong>legendre_deriv2_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_array-class_method" title="legendre_deriv2_array (class method)">.<strong>legendre_deriv2_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_array_e-class_method" title="legendre_deriv2_array_e (class method)">.<strong>legendre_deriv2_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_alt_array-class_method" title="legendre_deriv_alt_array (class method)">.<strong>legendre_deriv_alt_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_alt_array_e-class_method" title="legendre_deriv_alt_array_e (class method)">.<strong>legendre_deriv_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_array-class_method" title="legendre_deriv_array (class method)">.<strong>legendre_deriv_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_array_e-class_method" title="legendre_deriv_array_e (class method)">.<strong>legendre_deriv_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d-class_method" title="legendre_H3d (class method)">.<strong>legendre_H3d</strong>(l, lambda, eta)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$ \eta &gt;= 0, $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_0-class_method" title="legendre_H3d_0 (class method)">.<strong>legendre_H3d_0</strong>(lambda, eta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script> L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_0_e-class_method" title="legendre_H3d_0_e (class method)">.<strong>legendre_H3d_0_e</strong>(lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script> L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_1-class_method" title="legendre_H3d_1 (class method)">.<strong>legendre_H3d_1</strong>(lambda, eta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script> L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_1_e-class_method" title="legendre_H3d_1_e (class method)">.<strong>legendre_H3d_1_e</strong>(lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script> L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_array-class_method" title="legendre_H3d_array (class method)">.<strong>legendre_H3d_array</strong>(lmax, lambda, eta)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an array of radial eigenfunctions $L^H3d_l( \lambda, \eta)$ L^@H3d@_l(\lambda, \eta) for $0 \le l \le lmax$ 0 &lt;= l &lt;= lmax.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_e-class_method" title="legendre_H3d_e (class method)">.<strong>legendre_H3d_e</strong>(l, lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$ \eta &gt;= 0, $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P1-class_method" title="legendre_P1 (class method)">.<strong>legendre_P1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P1_e-class_method" title="legendre_P1_e (class method)">.<strong>legendre_P1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P2-class_method" title="legendre_P2 (class method)">.<strong>legendre_P2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P2_e-class_method" title="legendre_P2_e (class method)">.<strong>legendre_P2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P3-class_method" title="legendre_P3 (class method)">.<strong>legendre_P3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P3_e-class_method" title="legendre_P3_e (class method)">.<strong>legendre_P3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl-class_method" title="legendre_Pl (class method)">.<strong>legendre_Pl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions evaluate the Legendre polynomial $P_l(x)$ P_l(x) for a specific value of l, x subject to $l \ge 0$ l &gt;= 0, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_array-class_method" title="legendre_Pl_array (class method)">.<strong>legendre_Pl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions compute arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \dots, lmax, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_deriv_array-class_method" title="legendre_Pl_deriv_array (class method)">.<strong>legendre_Pl_deriv_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions compute arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \dots, lmax, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_e-class_method" title="legendre_Pl_e (class method)">.<strong>legendre_Pl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions evaluate the Legendre polynomial $P_l(x)$ P_l(x) for a specific value of l, x subject to $l \ge 0$ l &gt;= 0, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Plm-class_method" title="legendre_Plm (class method)">.<strong>legendre_Plm</strong>(l, m, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the associated Legendre polynomial P_l^m(x) for $m \ge 0$ m &gt;= 0, $l \ge m$ l &gt;= m, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Plm_e-class_method" title="legendre_Plm_e (class method)">.<strong>legendre_Plm_e</strong>(l, m, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the associated Legendre polynomial P_l^m(x) for $m \ge 0$ m &gt;= 0, $l \ge m$ l &gt;= m, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q0-class_method" title="legendre_Q0 (class method)">.<strong>legendre_Q0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_0(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q0_e-class_method" title="legendre_Q0_e (class method)">.<strong>legendre_Q0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_0(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q1-class_method" title="legendre_Q1 (class method)">.<strong>legendre_Q1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_1(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q1_e-class_method" title="legendre_Q1_e (class method)">.<strong>legendre_Q1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_1(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Ql-class_method" title="legendre_Ql (class method)">.<strong>legendre_Ql</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_l(x) for x &gt; -1, $x \ne 1$ x != 1 and $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Ql_e-class_method" title="legendre_Ql_e (class method)">.<strong>legendre_Ql_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_l(x) for x &gt; -1, $x \ne 1$ x != 1 and $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_sphPlm-class_method" title="legendre_sphPlm (class method)">.<strong>legendre_sphPlm</strong>(l, m, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized associated Legendre polynomial $\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$ \sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable for use in spherical harmonics.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_sphPlm_e-class_method" title="legendre_sphPlm_e (class method)">.<strong>legendre_sphPlm_e</strong>(l, m, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized associated Legendre polynomial $\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$ \sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable for use in spherical harmonics.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnbeta-class_method" title="lnbeta (class method)">.<strong>lnbeta</strong>(a, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Beta Function, \log(B(a,b)) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnbeta_e-class_method" title="lnbeta_e (class method)">.<strong>lnbeta_e</strong>(a, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Beta Function, \log(B(a,b)) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnchoose-class_method" title="lnchoose (class method)">.<strong>lnchoose</strong>(n, m)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of n choose m.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnchoose_e-class_method" title="lnchoose_e (class method)">.<strong>lnchoose_e</strong>(n, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of n choose m.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lncosh-class_method" title="lncosh (class method)">.<strong>lncosh</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\cosh(x)) for any x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lncosh_e-class_method" title="lncosh_e (class method)">.<strong>lncosh_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\cosh(x)) for any x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lndoublefact-class_method" title="lndoublefact (class method)">.<strong>lndoublefact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the double factorial of n, \log(n!!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lndoublefact_e-class_method" title="lndoublefact_e (class method)">.<strong>lndoublefact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the double factorial of n, \log(n!!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnfact-class_method" title="lnfact (class method)">.<strong>lnfact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the factorial of n, \log(n!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnfact_e-class_method" title="lnfact_e (class method)">.<strong>lnfact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the factorial of n, \log(n!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma-class_method" title="lngamma (class method)">.<strong>lngamma</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Gamma function, \log(\Gamma(x)), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_complex_e-class_method" title="lngamma_complex_e (class method)">.<strong>lngamma_complex_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes \log(\Gamma(z)) for complex z=z_r+i z_i and z not a negative integer or zero, using the complex Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_e-class_method" title="lngamma_e (class method)">.<strong>lngamma_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Gamma function, \log(\Gamma(x)), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_sgn_e-class_method" title="lngamma_sgn_e (class method)">.<strong>lngamma_sgn_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the sign of the gamma function and the logarithm of its magnitude, subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch-class_method" title="lnpoch (class method)">.<strong>lnpoch</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Pochhammer symbol, \log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch_e-class_method" title="lnpoch_e (class method)">.<strong>lnpoch_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Pochhammer symbol, \log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch_sgn_e-class_method" title="lnpoch_sgn_e (class method)">.<strong>lnpoch_sgn_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sign of the Pochhammer symbol and the logarithm of its magnitude.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnsinh-class_method" title="lnsinh (class method)">.<strong>lnsinh</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\sinh(x)) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnsinh_e-class_method" title="lnsinh_e (class method)">.<strong>lnsinh_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\sinh(x)) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log-class_method" title="log (class method)">.<strong>log</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of x, \log(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx-class_method" title="log_1plusx (class method)">.<strong>log_1plusx</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_e-class_method" title="log_1plusx_e (class method)">.<strong>log_1plusx_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_mx-class_method" title="log_1plusx_mx (class method)">.<strong>log_1plusx_mx</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_mx_e-class_method" title="log_1plusx_mx_e (class method)">.<strong>log_1plusx_mx_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_abs-class_method" title="log_abs (class method)">.<strong>log_abs</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the logarithm of the magnitude of x, \log(</td>
      <td>x</td>
      <td>), for x \ne 0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_abs_e-class_method" title="log_abs_e (class method)">.<strong>log_abs_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the logarithm of the magnitude of x, \log(</td>
      <td>x</td>
      <td>), for x \ne 0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_e-class_method" title="log_e (class method)">.<strong>log_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of x, \log(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_erfc-class_method" title="log_erfc (class method)">.<strong>log_erfc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the complementary error function \log(\erfc(x)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_erfc_e-class_method" title="log_erfc_e (class method)">.<strong>log_erfc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the complementary error function \log(\erfc(x)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_a-class_method" title="mathieu_a (class method)">.<strong>mathieu_a</strong>(n, q)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_a_e-class_method" title="mathieu_a_e (class method)">.<strong>mathieu_a_e</strong>(n, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_b-class_method" title="mathieu_b (class method)">.<strong>mathieu_b</strong>(n, q)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_b_e-class_method" title="mathieu_b_e (class method)">.<strong>mathieu_b_e</strong>(n, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_ce-class_method" title="mathieu_ce (class method)">.<strong>mathieu_ce</strong>(n, q, x)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_ce_e-class_method" title="mathieu_ce_e (class method)">.<strong>mathieu_ce_e</strong>(n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Mc-class_method" title="mathieu_Mc (class method)">.<strong>mathieu_Mc</strong>(j, n, q, x)  &#x21d2; Numo::Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Mc_e-class_method" title="mathieu_Mc_e (class method)">.<strong>mathieu_Mc_e</strong>(j, n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Ms-class_method" title="mathieu_Ms (class method)">.<strong>mathieu_Ms</strong>(j, n, q, x)  &#x21d2; Numo::Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Ms_e-class_method" title="mathieu_Ms_e (class method)">.<strong>mathieu_Ms_e</strong>(j, n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_se-class_method" title="mathieu_se (class method)">.<strong>mathieu_se</strong>(n, q, x)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_se_e-class_method" title="mathieu_se_e (class method)">.<strong>mathieu_se_e</strong>(n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#multiply_e-class_method" title="multiply_e (class method)">.<strong>multiply_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function multiplies x and y storing the product and its associated error in result.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#multiply_err_e-class_method" title="multiply_err_e (class method)">.<strong>multiply_err_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function multiplies x and y with associated absolute errors dx and dy.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#poch-class_method" title="poch (class method)">.<strong>poch</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#poch_e-class_method" title="poch_e (class method)">.<strong>poch_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pochrel-class_method" title="pochrel (class method)">.<strong>pochrel</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pochrel_e-class_method" title="pochrel_e (class method)">.<strong>pochrel_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#polar_to_rect-class_method" title="polar_to_rect (class method)">.<strong>polar_to_rect</strong>(r, theta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function converts the polar coordinates (r,theta) to rectilinear coordinates (x,y), x = r\cos(\theta), y = r\sin(\theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow_int-class_method" title="pow_int (class method)">.<strong>pow_int</strong>(x, n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the power x^n for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow_int_e-class_method" title="pow_int_e (class method)">.<strong>pow_int_e</strong>(x, n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the power x^n for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi-class_method" title="psi (class method)">.<strong>psi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(x) for general x, x \ne 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1-class_method" title="psi_1 (class method)">.<strong>psi_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(x) for general x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_e-class_method" title="psi_1_e (class method)">.<strong>psi_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(x) for general x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_int-class_method" title="psi_1_int (class method)">.<strong>psi_1_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_int_e-class_method" title="psi_1_int_e (class method)">.<strong>psi_1_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1piy-class_method" title="psi_1piy (class method)">.<strong>psi_1piy</strong>(y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the real part of the digamma function on the line 1+i y, \Re[\psi(1 + i y)].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1piy_e-class_method" title="psi_1piy_e (class method)">.<strong>psi_1piy_e</strong>(y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the real part of the digamma function on the line 1+i y, \Re[\psi(1 + i y)].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_e-class_method" title="psi_e (class method)">.<strong>psi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(x) for general x, x \ne 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_int-class_method" title="psi_int (class method)">.<strong>psi_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_int_e-class_method" title="psi_int_e (class method)">.<strong>psi_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_n-class_method" title="psi_n (class method)">.<strong>psi_n</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the polygamma function $\psi^(n)(x)$ \psi^@(n)@(x) for $n \ge 0$ n &gt;= 0, x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_n_e-class_method" title="psi_n_e (class method)">.<strong>psi_n_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the polygamma function $\psi^(n)(x)$ \psi^@(n)@(x) for $n \ge 0$ n &gt;= 0, x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rect_to_polar-class_method" title="rect_to_polar (class method)">.<strong>rect_to_polar</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function converts the rectilinear coordinates (x,y) to polar coordinates (r,theta), such that x = r\cos(\theta), y = r\sin(\theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Shi-class_method" title="Shi (class method)">.<strong>Shi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Sf.Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$ Shi(x) = \int_0^x dt \sinh(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Shi_e-class_method" title="Shi_e (class method)">.<strong>Shi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Sf.Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$ Shi(x) = \int_0^x dt \sinh(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Si-class_method" title="Si (class method)">.<strong>Si</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Sf.Si</a></span>(x) = \int_0^x dt \sin(t)/t$ Si(x) = \int_0^x dt \sin(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Si_e-class_method" title="Si_e (class method)">.<strong>Si_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Sf.Si</a></span>(x) = \int_0^x dt \sin(t)/t$ Si(x) = \int_0^x dt \sin(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin-class_method" title="sin (class method)">.<strong>sin</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sine function \sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin_e-class_method" title="sin_e (class method)">.<strong>sin_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sine function \sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin_err_e-class_method" title="sin_err_e (class method)">.<strong>sin_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the sine of an angle x with an associated absolute error dx, $\sin(x \pm dx)$ \sin(x \pm dx).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sinc-class_method" title="sinc (class method)">.<strong>sinc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any value of x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sinc_e-class_method" title="sinc_e (class method)">.<strong>sinc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any value of x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_1-class_method" title="synchrotron_1 (class method)">.<strong>synchrotron_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first synchrotron function $x \int_x^\infty dt K_5/3(t)$ x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_1_e-class_method" title="synchrotron_1_e (class method)">.<strong>synchrotron_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first synchrotron function $x \int_x^\infty dt K_5/3(t)$ x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_2-class_method" title="synchrotron_2 (class method)">.<strong>synchrotron_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second synchrotron function $x K_2/3(x)$ x K_@2/3@(x) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_2_e-class_method" title="synchrotron_2_e (class method)">.<strong>synchrotron_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second synchrotron function $x K_2/3(x)$ x K_@2/3@(x) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#taylorcoeff-class_method" title="taylorcoeff (class method)">.<strong>taylorcoeff</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Taylor coefficient x^n / n! for $x \ge 0$ x &gt;= 0, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#taylorcoeff_e-class_method" title="taylorcoeff_e (class method)">.<strong>taylorcoeff_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Taylor coefficient x^n / n! for $x \ge 0$ x &gt;= 0, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_2-class_method" title="transport_2 (class method)">.<strong>transport_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(2,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_2_e-class_method" title="transport_2_e (class method)">.<strong>transport_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(2,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_3-class_method" title="transport_3 (class method)">.<strong>transport_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(3,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_3_e-class_method" title="transport_3_e (class method)">.<strong>transport_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(3,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_4-class_method" title="transport_4 (class method)">.<strong>transport_4</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(4,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_4_e-class_method" title="transport_4_e (class method)">.<strong>transport_4_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(4,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_5-class_method" title="transport_5 (class method)">.<strong>transport_5</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(5,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_5_e-class_method" title="transport_5_e (class method)">.<strong>transport_5_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(5,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta-class_method" title="zeta (class method)">.<strong>zeta</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(s) for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_e-class_method" title="zeta_e (class method)">.<strong>zeta_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(s) for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_int-class_method" title="zeta_int (class method)">.<strong>zeta_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(n) for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_int_e-class_method" title="zeta_int_e (class method)">.<strong>zeta_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(n) for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1-class_method" title="zetam1 (class method)">.<strong>zetam1</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(s) - 1 for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_e-class_method" title="zetam1_e (class method)">.<strong>zetam1_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(s) - 1 for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_int-class_method" title="zetam1_int (class method)">.<strong>zetam1_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(n) - 1 for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_int_e-class_method" title="zetam1_int_e (class method)">.<strong>zetam1_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(n) - 1 for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="airy_Ai-class_method">
  
    .<strong>airy_Ai</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Ai(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 90</span>

static VALUE
sf_s_airy_Ai(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv-class_method">
  
    .<strong>airy_Ai_deriv</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Ai’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 562</span>

static VALUE
sf_s_airy_Ai_deriv(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_e-class_method">
  
    .<strong>airy_Ai_deriv_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Ai’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 617</span>

static VALUE
sf_s_airy_Ai_deriv_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_scaled-class_method">
  
    .<strong>airy_Ai_deriv_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_A(x) Ai’(x).
For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 796</span>

static VALUE
sf_s_airy_Ai_deriv_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_scaled_e-class_method">
  
    .<strong>airy_Ai_deriv_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_A(x) Ai’(x).
For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 853</span>

static VALUE
sf_s_airy_Ai_deriv_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_e-class_method">
  
    .<strong>airy_Ai_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Ai(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 145</span>

static VALUE
sf_s_airy_Ai_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_scaled-class_method">
  
    .<strong>airy_Ai_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)),
and is 1
for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 325</span>

static VALUE
sf_s_airy_Ai_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_scaled_e-class_method">
  
    .<strong>airy_Ai_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)),
and is 1
for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 383</span>

static VALUE
sf_s_airy_Ai_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi-class_method">
  
    .<strong>airy_Bi</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Bi(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 206</span>

static VALUE
sf_s_airy_Bi(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv-class_method">
  
    .<strong>airy_Bi_deriv</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Bi’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 678</span>

static VALUE
sf_s_airy_Bi_deriv(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_e-class_method">
  
    .<strong>airy_Bi_deriv_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Bi’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 733</span>

static VALUE
sf_s_airy_Bi_deriv_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_scaled-class_method">
  
    .<strong>airy_Bi_deriv_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_B(x) Bi’(x).
For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 916</span>

static VALUE
sf_s_airy_Bi_deriv_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_scaled_e-class_method">
  
    .<strong>airy_Bi_deriv_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_B(x) Bi’(x).
For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
997
998
999
1000</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 973</span>

static VALUE
sf_s_airy_Bi_deriv_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_e-class_method">
  
    .<strong>airy_Bi_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Bi(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 261</span>

static VALUE
sf_s_airy_Bi_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_scaled-class_method">
  
    .<strong>airy_Bi_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 445</span>

static VALUE
sf_s_airy_Bi_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_scaled_e-class_method">
  
    .<strong>airy_Bi_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 501</span>

static VALUE
sf_s_airy_Bi_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai-class_method">
  
    .<strong>airy_zero_Ai</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Ai(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1031
1032
1033
1034
1035
1036
1037
1038
1039</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1031</span>

static VALUE
sf_s_airy_zero_Ai(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_deriv-class_method">
  
    .<strong>airy_zero_Ai_deriv</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Ai’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1209
1210
1211
1212
1213
1214
1215
1216
1217</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1209</span>

static VALUE
sf_s_airy_zero_Ai_deriv(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_deriv_e-class_method">
  
    .<strong>airy_zero_Ai_deriv_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Ai’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1251</span>

static VALUE
sf_s_airy_zero_Ai_deriv_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_e-class_method">
  
    .<strong>airy_zero_Ai_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Ai(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1073</span>

static VALUE
sf_s_airy_zero_Ai_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi-class_method">
  
    .<strong>airy_zero_Bi</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Bi(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1120
1121
1122
1123
1124
1125
1126
1127
1128</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1120</span>

static VALUE
sf_s_airy_zero_Bi(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_deriv-class_method">
  
    .<strong>airy_zero_Bi_deriv</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Bi’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1298
1299
1300
1301
1302
1303
1304
1305
1306</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1298</span>

static VALUE
sf_s_airy_zero_Bi_deriv(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_deriv_e-class_method">
  
    .<strong>airy_zero_Bi_deriv_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Bi’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1340</span>

static VALUE
sf_s_airy_zero_Bi_deriv_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_e-class_method">
  
    .<strong>airy_zero_Bi_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Bi(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1162</span>

static VALUE
sf_s_airy_zero_Bi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="angle_restrict_pos-class_method">
  
    .<strong>angle_restrict_pos</strong>(theta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines force the angle theta to lie in the range [0,
2\pi).</p>

<p>Note that the mathematical value of 2\pi is slightly greater
than 2<em>M_PI, so the machine number 2</em>M_PI is included in
the range.</p>

<p>Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24212
24213
24214
24215
24216
24217
24218
24219
24220</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24212</span>

static VALUE
sf_s_angle_restrict_pos(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_angle_restrict_pos, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="angle_restrict_symm-class_method">
  
    .<strong>angle_restrict_symm</strong>(theta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines force the angle theta to lie in the range
(-\pi,\pi].</p>

<p>Note that the mathematical value of \pi is slightly greater
than M_PI, so the machine numbers M_PI and -M_PI
are included in the range.
Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24168
24169
24170
24171
24172
24173
24174
24175
24176</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24168</span>

static VALUE
sf_s_angle_restrict_symm(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_angle_restrict_symm, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="atanint-class_method">
  
    .<strong>atanint</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$
AtanInt(x) = \int_0^x dt \arctan(t)/t.
Domain:
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12398
12399
12400
12401
12402
12403
12404
12405
12406</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12398</span>

static VALUE
sf_s_atanint(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_atanint, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="atanint_e-class_method">
  
    .<strong>atanint_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$
AtanInt(x) = \int_0^x dt \arctan(t)/t.
Domain:
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12442
12443
12444
12445
12446
12447
12448
12449
12450
12451
12452
12453
12454
12455
12456
12457
12458</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12442</span>

static VALUE
sf_s_atanint_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_atanint_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0-class_method">
  
    .<strong>bessel_I0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2108
2109
2110
2111
2112
2113
2114
2115
2116</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2108</span>

static VALUE
sf_s_bessel_I0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_e-class_method">
  
    .<strong>bessel_I0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2151</span>

static VALUE
sf_s_bessel_I0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_scaled-class_method">
  
    .<strong>bessel_I0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2471
2472
2473
2474
2475
2476
2477
2478
2479</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2471</span>

static VALUE
sf_s_bessel_I0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i0_scaled-class_method">
  
    .<strong>bessel_i0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4541
4542
4543
4544
4545
4546
4547
4548
4549</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4541</span>

static VALUE
sf_s_bessel_i0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_scaled_e-class_method">
  
    .<strong>bessel_I0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2514</span>

static VALUE
sf_s_bessel_I0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i0_scaled_e-class_method">
  
    .<strong>bessel_i0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4584
4585
4586
4587
4588
4589
4590
4591
4592
4593
4594
4595
4596
4597
4598
4599
4600</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4584</span>

static VALUE
sf_s_bessel_i0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1-class_method">
  
    .<strong>bessel_I1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2198
2199
2200
2201
2202
2203
2204
2205
2206</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2198</span>

static VALUE
sf_s_bessel_I1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_e-class_method">
  
    .<strong>bessel_I1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2241</span>

static VALUE
sf_s_bessel_I1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_scaled-class_method">
  
    .<strong>bessel_I1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2561
2562
2563
2564
2565
2566
2567
2568
2569</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2561</span>

static VALUE
sf_s_bessel_I1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i1_scaled-class_method">
  
    .<strong>bessel_i1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4631
4632
4633
4634
4635
4636
4637
4638
4639</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4631</span>

static VALUE
sf_s_bessel_i1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_scaled_e-class_method">
  
    .<strong>bessel_I1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2604</span>

static VALUE
sf_s_bessel_I1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i1_scaled_e-class_method">
  
    .<strong>bessel_i1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4674
4675
4676
4677
4678
4679
4680
4681
4682
4683
4684
4685
4686
4687
4688
4689
4690</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4674</span>

static VALUE
sf_s_bessel_i1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i2_scaled-class_method">
  
    .<strong>bessel_i2_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4721
4722
4723
4724
4725
4726
4727
4728
4729</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4721</span>

static VALUE
sf_s_bessel_i2_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i2_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i2_scaled_e-class_method">
  
    .<strong>bessel_i2_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4764
4765
4766
4767
4768
4769
4770
4771
4772
4773
4774
4775
4776
4777
4778
4779
4780</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4764</span>

static VALUE
sf_s_bessel_i2_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i2_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled-class_method">
  
    .<strong>bessel_il_scaled</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of order l,  \exp(-|x|) i_l(x)
Domain: l &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4815
4816
4817
4818
4819
4820
4821
4822
4823
4824
4825
4826</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4815</span>

static VALUE
sf_s_bessel_il_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled_array-class_method">
  
    .<strong>bessel_il_scaled_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled regular modified
spherical Bessel functions \exp(-|x|) i_l(x) for l from
0 to lmax inclusive for $lmax \geq 0$
lmax &gt;= 0, storing the results in
the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4933
4934
4935
4936
4937
4938
4939
4940
4941
4942
4943
4944
4945
4946
4947
4948
4949
4950
4951
4952
4953
4954
4955
4956</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4933</span>

static VALUE
sf_s_bessel_il_scaled_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled_e-class_method">
  
    .<strong>bessel_il_scaled_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of order l,  \exp(-|x|) i_l(x)
Domain: l &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4867
4868
4869
4870
4871
4872
4873
4874
4875
4876
4877
4878
4879
4880
4881
4882
4883
4884
4885
4886</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4867</span>

static VALUE
sf_s_bessel_il_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In-class_method">
  
    .<strong>bessel_In</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of order n, I_n(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2291</span>

static VALUE
sf_s_bessel_In(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_array-class_method">
  
    .<strong>bessel_In_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular modified cylindrical
Bessel functions I_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array.  The start of the range nmin must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: nmin &gt;=0, nmax &gt;= nmin
Conditions: n=nmin,…,nmax, nmin &gt;=0, nmax &gt;= nmin
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2412</span>

static VALUE
sf_s_bessel_In_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_e-class_method">
  
    .<strong>bessel_In_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of order n, I_n(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
2361</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2342</span>

static VALUE
sf_s_bessel_In_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled-class_method">
  
    .<strong>bessel_In_scaled</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of order n, \exp(-|x|) I_n(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2654</span>

static VALUE
sf_s_bessel_In_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled_array-class_method">
  
    .<strong>bessel_In_scaled_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled regular cylindrical
Bessel functions \exp(-|x|) I_n(x) for n from
nmin to nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: nmin &gt;=0, nmax &gt;= nmin
Conditions:  n=nmin,…,nmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2775</span>

static VALUE
sf_s_bessel_In_scaled_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled_e-class_method">
  
    .<strong>bessel_In_scaled_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of order n, \exp(-|x|) I_n(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2705</span>

static VALUE
sf_s_bessel_In_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu-class_method">
  
    .<strong>bessel_Inu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5636
5637
5638
5639
5640
5641
5642
5643
5644</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5636</span>

static VALUE
sf_s_bessel_Inu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_e-class_method">
  
    .<strong>bessel_Inu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5684
5685
5686
5687
5688
5689
5690
5691
5692
5693
5694
5695
5696
5697
5698
5699
5700</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5684</span>

static VALUE
sf_s_bessel_Inu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_scaled-class_method">
  
    .<strong>bessel_Inu_scaled</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&gt;0,
\nu&gt;0.
\exp(-|x|) I_@\nu@(x)
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5737
5738
5739
5740
5741
5742
5743
5744
5745</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5737</span>

static VALUE
sf_s_bessel_Inu_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_scaled, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_scaled_e-class_method">
  
    .<strong>bessel_Inu_scaled_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&gt;0,
\nu&gt;0.
\exp(-|x|) I_@\nu@(x)
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5786
5787
5788
5789
5790
5791
5792
5793
5794
5795
5796
5797
5798
5799
5800
5801
5802</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5786</span>

static VALUE
sf_s_bessel_Inu_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J0-class_method">
  
    .<strong>bessel_J0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1387
1388
1389
1390
1391
1392
1393
1394
1395</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1387</span>

static VALUE
sf_s_bessel_J0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j0-class_method">
  
    .<strong>bessel_j0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3574
3575
3576
3577
3578
3579
3580
3581
3582</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3574</span>

static VALUE
sf_s_bessel_j0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J0_e-class_method">
  
    .<strong>bessel_J0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1430</span>

static VALUE
sf_s_bessel_J0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j0_e-class_method">
  
    .<strong>bessel_j0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
3627
3628
3629
3630
3631
3632
3633</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3617</span>

static VALUE
sf_s_bessel_j0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J1-class_method">
  
    .<strong>bessel_J1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1477
1478
1479
1480
1481
1482
1483
1484
1485</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1477</span>

static VALUE
sf_s_bessel_J1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j1-class_method">
  
    .<strong>bessel_j1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3664
3665
3666
3667
3668
3669
3670
3671
3672</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3664</span>

static VALUE
sf_s_bessel_j1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J1_e-class_method">
  
    .<strong>bessel_J1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1520</span>

static VALUE
sf_s_bessel_J1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j1_e-class_method">
  
    .<strong>bessel_j1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3707
3708
3709
3710
3711
3712
3713
3714
3715
3716
3717
3718
3719
3720
3721
3722
3723</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3707</span>

static VALUE
sf_s_bessel_j1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j2-class_method">
  
    .<strong>bessel_j2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3754
3755
3756
3757
3758
3759
3760
3761
3762</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3754</span>

static VALUE
sf_s_bessel_j2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j2_e-class_method">
  
    .<strong>bessel_j2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3797
3798
3799
3800
3801
3802
3803
3804
3805
3806
3807
3808
3809
3810
3811
3812
3813</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3797</span>

static VALUE
sf_s_bessel_j2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl-class_method">
  
    .<strong>bessel_jl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of
order l, j_l(x), for $l \geq 0$
l &gt;= 0 and $x \geq 0$
x &gt;= 0.
Domain: l &gt;= 0, x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3850
3851
3852
3853
3854
3855
3856
3857
3858
3859
3860
3861</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3850</span>

static VALUE
sf_s_bessel_jl(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_array-class_method">
  
    .<strong>bessel_jl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular spherical Bessel
functions j_l(x) for l from 0 to lmax
inclusive  for $lmax \geq 0$
lmax &gt;= 0 and $x \geq 0$
x &gt;= 0, storing the results in the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3970
3971
3972
3973
3974
3975
3976
3977
3978
3979
3980
3981
3982
3983
3984
3985
3986
3987
3988
3989
3990
3991
3992
3993</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3970</span>

static VALUE
sf_s_bessel_jl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_e-class_method">
  
    .<strong>bessel_jl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of
order l, j_l(x), for $l \geq 0$
l &gt;= 0 and $x \geq 0$
x &gt;= 0.
Domain: l &gt;= 0, x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3904
3905
3906
3907
3908
3909
3910
3911
3912
3913
3914
3915
3916
3917
3918
3919
3920
3921
3922
3923</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3904</span>

static VALUE
sf_s_bessel_jl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_steed_array-class_method">
  
    .<strong>bessel_jl_steed_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine uses Steed’s method to compute the values of the regular
spherical Bessel functions j_l(x) for l from 0 to
lmax inclusive for $lmax \geq 0$
lmax &gt;= 0 and $x \geq 0$
x &gt;= 0, storing the results in the array
result_array.
The Steed/Barnett algorithm is described in Comp. Phys. Comm. 21,
297 (1981).  Steed’s method is more stable than the
recurrence used in the other functions but is also slower.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057
4058
4059
4060
4061
4062
4063
4064
4065</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4042</span>

static VALUE
sf_s_bessel_jl_steed_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_steed_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn-class_method">
  
    .<strong>bessel_Jn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
order n, J_n(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1570</span>

static VALUE
sf_s_bessel_Jn(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn_array-class_method">
  
    .<strong>bessel_Jn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular cylindrical Bessel
functions J_n(x) for n from nmin to nmax
inclusive, storing the results in the array result_array.  The
values are computed using recurrence relations for efficiency, and
therefore may differ slightly from the exact values.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1688</span>

static VALUE
sf_s_bessel_Jn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn_e-class_method">
  
    .<strong>bessel_Jn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
order n, J_n(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1621</span>

static VALUE
sf_s_bessel_Jn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jnu-class_method">
  
    .<strong>bessel_Jnu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5442
5443
5444
5445
5446
5447
5448
5449
5450</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5442</span>

static VALUE
sf_s_bessel_Jnu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jnu_e-class_method">
  
    .<strong>bessel_Jnu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5488
5489
5490
5491
5492
5493
5494
5495
5496
5497
5498
5499
5500
5501
5502
5503
5504</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5488</span>

static VALUE
sf_s_bessel_Jnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0-class_method">
  
    .<strong>bessel_K0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2835
2836
2837
2838
2839
2840
2841
2842
2843</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2835</span>

static VALUE
sf_s_bessel_K0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_e-class_method">
  
    .<strong>bessel_K0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2879
2880
2881
2882
2883
2884
2885
2886
2887
2888
2889
2890
2891
2892
2893
2894
2895</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2879</span>

static VALUE
sf_s_bessel_K0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_scaled-class_method">
  
    .<strong>bessel_K0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3205
3206
3207
3208
3209
3210
3211
3212
3213</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3205</span>

static VALUE
sf_s_bessel_K0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k0_scaled-class_method">
  
    .<strong>bessel_k0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4988
4989
4990
4991
4992
4993
4994
4995
4996</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4988</span>

static VALUE
sf_s_bessel_k0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_scaled_e-class_method">
  
    .<strong>bessel_K0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
3260
3261
3262
3263
3264
3265</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3249</span>

static VALUE
sf_s_bessel_K0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k0_scaled_e-class_method">
  
    .<strong>bessel_k0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5032
5033
5034
5035
5036
5037
5038
5039
5040
5041
5042
5043
5044
5045
5046
5047
5048</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5032</span>

static VALUE
sf_s_bessel_k0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1-class_method">
  
    .<strong>bessel_K1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2927
2928
2929
2930
2931
2932
2933
2934
2935</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2927</span>

static VALUE
sf_s_bessel_K1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_e-class_method">
  
    .<strong>bessel_K1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2971
2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983
2984
2985
2986
2987</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2971</span>

static VALUE
sf_s_bessel_K1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_scaled-class_method">
  
    .<strong>bessel_K1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3297
3298
3299
3300
3301
3302
3303
3304
3305</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3297</span>

static VALUE
sf_s_bessel_K1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k1_scaled-class_method">
  
    .<strong>bessel_k1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5080
5081
5082
5083
5084
5085
5086
5087
5088</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5080</span>

static VALUE
sf_s_bessel_k1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_scaled_e-class_method">
  
    .<strong>bessel_K1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3341</span>

static VALUE
sf_s_bessel_K1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k1_scaled_e-class_method">
  
    .<strong>bessel_k1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5124
5125
5126
5127
5128
5129
5130
5131
5132
5133
5134
5135
5136
5137
5138
5139
5140</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5124</span>

static VALUE
sf_s_bessel_k1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k2_scaled-class_method">
  
    .<strong>bessel_k2_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5172
5173
5174
5175
5176
5177
5178
5179
5180</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5172</span>

static VALUE
sf_s_bessel_k2_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k2_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k2_scaled_e-class_method">
  
    .<strong>bessel_k2_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5216
5217
5218
5219
5220
5221
5222
5223
5224
5225
5226
5227
5228
5229
5230
5231
5232</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5216</span>

static VALUE
sf_s_bessel_k2_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k2_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled-class_method">
  
    .<strong>bessel_kl_scaled</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of order l, \exp(x) k_l(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5267
5268
5269
5270
5271
5272
5273
5274
5275
5276
5277
5278</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5267</span>

static VALUE
sf_s_bessel_kl_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled_array-class_method">
  
    .<strong>bessel_kl_scaled_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled irregular modified
spherical Bessel functions \exp(x) k_l(x) for l from
0 to lmax inclusive for $lmax \geq 0$
lmax &gt;= 0 and x&gt;0, storing the results in
the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5385
5386
5387
5388
5389
5390
5391
5392
5393
5394
5395
5396
5397
5398
5399
5400
5401
5402
5403
5404
5405
5406
5407
5408</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5385</span>

static VALUE
sf_s_bessel_kl_scaled_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled_e-class_method">
  
    .<strong>bessel_kl_scaled_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of order l, \exp(x) k_l(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5319
5320
5321
5322
5323
5324
5325
5326
5327
5328
5329
5330
5331
5332
5333
5334
5335
5336
5337
5338</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5319</span>

static VALUE
sf_s_bessel_kl_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn-class_method">
  
    .<strong>bessel_Kn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of order n, K_n(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3022
3023
3024
3025
3026
3027
3028
3029
3030
3031
3032
3033</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3022</span>

static VALUE
sf_s_bessel_Kn(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_array-class_method">
  
    .<strong>bessel_Kn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular modified cylindrical
Bessel functions K_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero. The domain of the function is x&gt;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
Conditions: n=nmin,…,nmax
Domain: x &gt; 0.0, nmin&gt;=0, nmax &gt;= nmin
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165
3166
3167
3168
3169
3170
3171
3172
3173</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3145</span>

static VALUE
sf_s_bessel_Kn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_e-class_method">
  
    .<strong>bessel_Kn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of order n, K_n(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085
3086
3087
3088
3089
3090
3091
3092
3093</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3074</span>

static VALUE
sf_s_bessel_Kn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled-class_method">
  
    .<strong>bessel_Kn_scaled</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of order n, \exp(x) K_n(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3392</span>

static VALUE
sf_s_bessel_Kn_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled_array-class_method">
  
    .<strong>bessel_Kn_scaled_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled irregular cylindrical
Bessel functions \exp(x) K_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero.  The domain of the function is x&gt;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
Domain: x &gt; 0.0, nmin &gt;=0, nmax &gt;= nmin
Conditions: n=nmin,…,nmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530
3531
3532
3533
3534
3535
3536
3537
3538
3539
3540
3541
3542
3543</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3515</span>

static VALUE
sf_s_bessel_Kn_scaled_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled_e-class_method">
  
    .<strong>bessel_Kn_scaled_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of order n, \exp(x) K_n(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455
3456
3457
3458
3459
3460
3461
3462
3463</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3444</span>

static VALUE
sf_s_bessel_Kn_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu-class_method">
  
    .<strong>bessel_Knu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5838
5839
5840
5841
5842
5843
5844
5845
5846</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5838</span>

static VALUE
sf_s_bessel_Knu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_e-class_method">
  
    .<strong>bessel_Knu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5886
5887
5888
5889
5890
5891
5892
5893
5894
5895
5896
5897
5898
5899
5900
5901
5902</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5886</span>

static VALUE
sf_s_bessel_Knu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_scaled-class_method">
  
    .<strong>bessel_Knu_scaled</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6038
6039
6040
6041
6042
6043
6044
6045
6046</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6038</span>

static VALUE
sf_s_bessel_Knu_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_scaled, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_scaled_e-class_method">
  
    .<strong>bessel_Knu_scaled_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6086
6087
6088
6089
6090
6091
6092
6093
6094
6095
6096
6097
6098
6099
6100
6101
6102</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6086</span>

static VALUE
sf_s_bessel_Knu_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_lnKnu-class_method">
  
    .<strong>bessel_lnKnu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&gt;0, \nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5938
5939
5940
5941
5942
5943
5944
5945
5946</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5938</span>

static VALUE
sf_s_bessel_lnKnu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_lnKnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_lnKnu_e-class_method">
  
    .<strong>bessel_lnKnu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&gt;0, \nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5986
5987
5988
5989
5990
5991
5992
5993
5994
5995
5996
5997
5998
5999
6000
6001
6002</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5986</span>

static VALUE
sf_s_bessel_lnKnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_lnKnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y0-class_method">
  
    .<strong>bessel_Y0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1747
1748
1749
1750
1751
1752
1753
1754
1755</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1747</span>

static VALUE
sf_s_bessel_Y0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y0-class_method">
  
    .<strong>bessel_y0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4096
4097
4098
4099
4100
4101
4102
4103
4104</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4096</span>

static VALUE
sf_s_bessel_y0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y0_e-class_method">
  
    .<strong>bessel_Y0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1790</span>

static VALUE
sf_s_bessel_Y0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y0_e-class_method">
  
    .<strong>bessel_y0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4139
4140
4141
4142
4143
4144
4145
4146
4147
4148
4149
4150
4151
4152
4153
4154
4155</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4139</span>

static VALUE
sf_s_bessel_y0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y1-class_method">
  
    .<strong>bessel_Y1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1837
1838
1839
1840
1841
1842
1843
1844
1845</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1837</span>

static VALUE
sf_s_bessel_Y1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y1-class_method">
  
    .<strong>bessel_y1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4186
4187
4188
4189
4190
4191
4192
4193
4194</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4186</span>

static VALUE
sf_s_bessel_y1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y1_e-class_method">
  
    .<strong>bessel_Y1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1880</span>

static VALUE
sf_s_bessel_Y1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y1_e-class_method">
  
    .<strong>bessel_y1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4229
4230
4231
4232
4233
4234
4235
4236
4237
4238
4239
4240
4241
4242
4243
4244
4245</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4229</span>

static VALUE
sf_s_bessel_y1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y2-class_method">
  
    .<strong>bessel_y2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4276
4277
4278
4279
4280
4281
4282
4283
4284</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4276</span>

static VALUE
sf_s_bessel_y2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y2_e-class_method">
  
    .<strong>bessel_y2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4319
4320
4321
4322
4323
4324
4325
4326
4327
4328
4329
4330
4331
4332
4333
4334
4335</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4319</span>

static VALUE
sf_s_bessel_y2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl-class_method">
  
    .<strong>bessel_yl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of
order l, y_l(x), for $l \geq 0$
l &gt;= 0.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4370
4371
4372
4373
4374
4375
4376
4377
4378
4379
4380
4381</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4370</span>

static VALUE
sf_s_bessel_yl(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl_array-class_method">
  
    .<strong>bessel_yl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular spherical Bessel
functions y_l(x) for l from 0 to lmax
inclusive  for $lmax \geq 0$
lmax &gt;= 0, storing the results in the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4487
4488
4489
4490
4491
4492
4493
4494
4495
4496
4497
4498
4499
4500
4501
4502
4503
4504
4505
4506
4507
4508
4509
4510</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4487</span>

static VALUE
sf_s_bessel_yl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl_e-class_method">
  
    .<strong>bessel_yl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of
order l, y_l(x), for $l \geq 0$
l &gt;= 0.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4422
4423
4424
4425
4426
4427
4428
4429
4430
4431
4432
4433
4434
4435
4436
4437
4438
4439
4440
4441</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4422</span>

static VALUE
sf_s_bessel_yl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn-class_method">
  
    .<strong>bessel_Yn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
order n, Y_n(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1930</span>

static VALUE
sf_s_bessel_Yn(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn_array-class_method">
  
    .<strong>bessel_Yn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular cylindrical Bessel
functions Y_n(x) for n from nmin to nmax
inclusive, storing the results in the array result_array.  The
domain of the function is x&gt;0.  The values are computed using
recurrence relations for efficiency, and therefore may differ slightly
from the exact values.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2049</span>

static VALUE
sf_s_bessel_Yn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn_e-class_method">
  
    .<strong>bessel_Yn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
order n, Y_n(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1981</span>

static VALUE
sf_s_bessel_Yn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Ynu-class_method">
  
    .<strong>bessel_Ynu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5538
5539
5540
5541
5542
5543
5544
5545
5546</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5538</span>

static VALUE
sf_s_bessel_Ynu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Ynu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Ynu_e-class_method">
  
    .<strong>bessel_Ynu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5584
5585
5586
5587
5588
5589
5590
5591
5592
5593
5594
5595
5596
5597
5598
5599
5600</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5584</span>

static VALUE
sf_s_bessel_Ynu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Ynu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J0-class_method">
  
    .<strong>bessel_zero_J0</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_0(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6134
6135
6136
6137
6138
6139
6140
6141
6142</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6134</span>

static VALUE
sf_s_bessel_zero_J0(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J0_e-class_method">
  
    .<strong>bessel_zero_J0_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_0(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6177
6178
6179
6180
6181
6182
6183
6184
6185
6186
6187
6188
6189
6190
6191
6192
6193</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6177</span>

static VALUE
sf_s_bessel_zero_J0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J1-class_method">
  
    .<strong>bessel_zero_J1</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_1(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6225
6226
6227
6228
6229
6230
6231
6232
6233</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6225</span>

static VALUE
sf_s_bessel_zero_J1(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J1_e-class_method">
  
    .<strong>bessel_zero_J1_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_1(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6268
6269
6270
6271
6272
6273
6274
6275
6276
6277
6278
6279
6280
6281
6282
6283
6284</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6268</span>

static VALUE
sf_s_bessel_zero_J1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_Jnu-class_method">
  
    .<strong>bessel_zero_Jnu</strong>(nu, s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of nu.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6320
6321
6322
6323
6324
6325
6326
6327
6328</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6320</span>

static VALUE
sf_s_bessel_zero_Jnu(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_DFloat_f_DFloat_UInt.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cUInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_Jnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_Jnu_e-class_method">
  
    .<strong>bessel_zero_Jnu_e</strong>(nu, s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of nu.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6367
6368
6369
6370
6371
6372
6373
6374
6375
6376
6377
6378
6379
6380
6381
6382
6383</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6367</span>

static VALUE
sf_s_bessel_zero_Jnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_Jnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta-class_method">
  
    .<strong>beta</strong>(a, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not
being negative integers.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15204
15205
15206
15207
15208
15209
15210
15211
15212</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15204</span>

static VALUE
sf_s_beta(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_beta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_e-class_method">
  
    .<strong>beta_e</strong>(a, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not
being negative integers.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15251
15252
15253
15254
15255
15256
15257
15258
15259
15260
15261
15262
15263
15264
15265
15266
15267</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15251</span>

static VALUE
sf_s_beta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_beta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_inc-class_method">
  
    .<strong>beta_inc</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Beta function
I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$
B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt
for $0 \le x \le 1$
0 &lt;= x &lt;= 1.   For a &gt; 0, b &gt; 0 the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation $I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)$
I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15407
15408
15409
15410
15411
15412
15413
15414
15415</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15407</span>

static VALUE
sf_s_beta_inc(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_beta_inc, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_inc_e-class_method">
  
    .<strong>beta_inc_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Beta function
I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$
B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt
for $0 \le x \le 1$
0 &lt;= x &lt;= 1.   For a &gt; 0, b &gt; 0 the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation $I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)$
I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15461
15462
15463
15464
15465
15466
15467
15468
15469
15470
15471
15472
15473
15474
15475
15476
15477</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15461</span>

static VALUE
sf_s_beta_inc_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_beta_inc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Chi-class_method">
  
    .<strong>Chi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$
Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] ,
where \gamma_E is the Euler constant (available as the macro M_EULER).
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12031
12032
12033
12034
12035
12036
12037
12038
12039</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12031</span>

static VALUE
sf_s_Chi(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Chi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Chi_e-class_method">
  
    .<strong>Chi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$
Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] ,
where \gamma_E is the Euler constant (available as the macro M_EULER).
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12076
12077
12078
12079
12080
12081
12082
12083
12084
12085
12086
12087
12088
12089
12090
12091
12092</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12076</span>

static VALUE
sf_s_Chi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Chi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="choose-class_method">
  
    .<strong>choose</strong>(n, m)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the combinatorial factor n choose m
= n!/(m!(n-m)!)
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14221
14222
14223
14224
14225
14226
14227
14228
14229
14230
14231
14232
14233
14234
14235
14236
14237</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14221</span>

static VALUE
sf_s_choose(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_choose,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="choose_e-class_method">
  
    .<strong>choose_e</strong>(n, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the combinatorial factor n choose m
= n!/(m!(n-m)!)
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14275
14276
14277
14278
14279
14280
14281
14282
14283
14284
14285
14286
14287
14288
14289
14290
14291</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14275</span>

static VALUE
sf_s_choose_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_choose_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Ci-class_method">
  
    .<strong>Ci</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$
Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12306
12307
12308
12309
12310
12311
12312
12313
12314</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12306</span>

static VALUE
sf_s_Ci(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Ci, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Ci_e-class_method">
  
    .<strong>Ci_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$
Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12350
12351
12352
12353
12354
12355
12356
12357
12358
12359
12360
12361
12362
12363
12364
12365
12366</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12350</span>

static VALUE
sf_s_Ci_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Ci_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="clausen-class_method">
  
    .<strong>clausen</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Clausen integral Cl_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6412
6413
6414
6415
6416
6417
6418
6419
6420</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6412</span>

static VALUE
sf_s_clausen(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_clausen, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="clausen_e-class_method">
  
    .<strong>clausen_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Clausen integral Cl_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6453
6454
6455
6456
6457
6458
6459
6460
6461
6462
6463
6464
6465
6466
6467
6468
6469</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6453</span>

static VALUE
sf_s_clausen_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_clausen_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_cos_e-class_method">
  
    .<strong>complex_cos_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the complex cosine, \cos(z_r + i z_i) storing
the real and imaginary parts in czr, czi.
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [czr.val, czr.err, czi.val, czi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23764
23765
23766
23767
23768
23769
23770
23771
23772
23773
23774
23775
23776
23777
23778
23779
23780</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23764</span>

static VALUE
sf_s_complex_cos_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_cos_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_dilog_e-class_method">
  
    .<strong>complex_dilog_e</strong>(r, theta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the full complex-valued dilogarithm for the
complex argument z = r \exp(i \theta). The real and imaginary
parts of the result are returned in result_re, result_im.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_re.val, result_re.err, result_im.val, result_im.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8322
8323
8324
8325
8326
8327
8328
8329
8330
8331
8332
8333
8334
8335
8336
8337
8338</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8322</span>

static VALUE
sf_s_complex_dilog_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_dilog_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_log_e-class_method">
  
    .<strong>complex_log_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the complex logarithm of z = z_r + i
z_i. The results are returned as lnr, theta such that
\exp(lnr + i \theta) = z_r + i z_i, where \theta lies in
the range [-\pi,\pi].
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lnr.val, lnr.err, theta.val, theta.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21152
21153
21154
21155
21156
21157
21158
21159
21160
21161
21162
21163
21164
21165
21166
21167
21168</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21152</span>

static VALUE
sf_s_complex_log_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_log_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_logsin_e-class_method">
  
    .<strong>complex_logsin_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the logarithm of the complex sine,
\log(\sin(z_r + i z_i)) storing the real and imaginary parts in
lszr, lszi.
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lszr.val, lszr.err, lszi.val, lszi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23822
23823
23824
23825
23826
23827
23828
23829
23830
23831
23832
23833
23834
23835
23836
23837
23838</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23822</span>

static VALUE
sf_s_complex_logsin_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_logsin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_sin_e-class_method">
  
    .<strong>complex_sin_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the complex sine, \sin(z_r + i z_i) storing
the real and imaginary parts in szr, szi.
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [szr.val, szr.err, szi.val, szi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23707
23708
23709
23710
23711
23712
23713
23714
23715
23716
23717
23718
23719
23720
23721
23722
23723</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23707</span>

static VALUE
sf_s_complex_sin_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_sin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_0-class_method">
  
    .<strong>conicalP_0</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^0<em>+ i \lambda(x)$
P^0</em>@+ i \lambda@(x)
for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20106
20107
20108
20109
20110
20111
20112
20113
20114</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20106</span>

static VALUE
sf_s_conicalP_0(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_0_e-class_method">
  
    .<strong>conicalP_0_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^0<em>+ i \lambda(x)$
P^0</em>@+ i \lambda@(x)
for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20154
20155
20156
20157
20158
20159
20160
20161
20162
20163
20164
20165
20166
20167
20168
20169
20170</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20154</span>

static VALUE
sf_s_conicalP_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_1-class_method">
  
    .<strong>conicalP_1</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^1<em>+ i \lambda(x)$
P^1</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20205
20206
20207
20208
20209
20210
20211
20212
20213</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20205</span>

static VALUE
sf_s_conicalP_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_1_e-class_method">
  
    .<strong>conicalP_1_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^1<em>+ i \lambda(x)$
P^1</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20252
20253
20254
20255
20256
20257
20258
20259
20260
20261
20262
20263
20264
20265
20266
20267
20268</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20252</span>

static VALUE
sf_s_conicalP_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_cyl_reg-class_method">
  
    .<strong>conicalP_cyl_reg</strong>(m, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Cylindrical Conical Function
$P^-m<em>+ i \lambda(x)$
P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$
m &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20433
20434
20435
20436
20437
20438
20439
20440
20441
20442
20443
20444
20445
20446
20447
20448
20449
20450
20451
20452</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20433</span>

static VALUE
sf_s_conicalP_cyl_reg(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_cyl_reg,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_cyl_reg_e-class_method">
  
    .<strong>conicalP_cyl_reg_e</strong>(m, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Cylindrical Conical Function
$P^-m<em>+ i \lambda(x)$
P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$
m &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20497
20498
20499
20500
20501
20502
20503
20504
20505
20506
20507
20508
20509
20510
20511
20512
20513
20514
20515
20516</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20497</span>

static VALUE
sf_s_conicalP_cyl_reg_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_cyl_reg_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_half-class_method">
  
    .<strong>conicalP_half</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular Spherical Conical Function
$P^1/2<em>+ i \lambda(x)$
P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19909
19910
19911
19912
19913
19914
19915
19916
19917</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19909</span>

static VALUE
sf_s_conicalP_half(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_half, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_half_e-class_method">
  
    .<strong>conicalP_half_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular Spherical Conical Function
$P^1/2<em>+ i \lambda(x)$
P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19956
19957
19958
19959
19960
19961
19962
19963
19964
19965
19966
19967
19968
19969
19970
19971
19972</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19956</span>

static VALUE
sf_s_conicalP_half_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_mhalf-class_method">
  
    .<strong>conicalP_mhalf</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular Spherical Conical Function
$P^-1/2<em>+ i \lambda(x)$
P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20007
20008
20009
20010
20011
20012
20013
20014
20015</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20007</span>

static VALUE
sf_s_conicalP_mhalf(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_mhalf, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_mhalf_e-class_method">
  
    .<strong>conicalP_mhalf_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular Spherical Conical Function
$P^-1/2<em>+ i \lambda(x)$
P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20054
20055
20056
20057
20058
20059
20060
20061
20062
20063
20064
20065
20066
20067
20068
20069
20070</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20054</span>

static VALUE
sf_s_conicalP_mhalf_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_mhalf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_sph_reg-class_method">
  
    .<strong>conicalP_sph_reg</strong>(l, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Spherical Conical Function
$P^-1/2-l<em>+ i \lambda(x)$
P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$
l &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20309
20310
20311
20312
20313
20314
20315
20316
20317
20318
20319
20320
20321
20322
20323
20324
20325
20326
20327
20328</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20309</span>

static VALUE
sf_s_conicalP_sph_reg(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_sph_reg,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_sph_reg_e-class_method">
  
    .<strong>conicalP_sph_reg_e</strong>(l, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Spherical Conical Function
$P^-1/2-l<em>+ i \lambda(x)$
P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$
l &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20373
20374
20375
20376
20377
20378
20379
20380
20381
20382
20383
20384
20385
20386
20387
20388
20389
20390
20391
20392</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20373</span>

static VALUE
sf_s_conicalP_sph_reg_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_sph_reg_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos-class_method">
  
    .<strong>cos</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the cosine function \cos(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23422
23423
23424
23425
23426
23427
23428
23429
23430</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23422</span>

static VALUE
sf_s_cos(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_cos, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos_e-class_method">
  
    .<strong>cos_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the cosine function \cos(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23464
23465
23466
23467
23468
23469
23470
23471
23472
23473
23474
23475
23476
23477
23478
23479
23480</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23464</span>

static VALUE
sf_s_cos_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_cos_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos_err_e-class_method">
  
    .<strong>cos_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the cosine of an angle x with an associated
absolute error dx,
$\cos(x \pm dx)$
\cos(x \pm dx).  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24316
24317
24318
24319
24320
24321
24322
24323
24324
24325
24326
24327
24328
24329
24330
24331
24332</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24316</span>

static VALUE
sf_s_cos_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_cos_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_CL_array-class_method">
  
    .<strong>coulomb_CL_array</strong>(Lmin, kmax, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function normalization constant
C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &gt; -1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Lmin</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [cl[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7199
7200
7201
7202
7203
7204
7205
7206
7207
7208
7209
7210
7211
7212
7213
7214
7215
7216
7217
7218
7219
7220
7221
7222</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7199</span>

static VALUE
sf_s_coulomb_CL_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_CL_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v0,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_CL_e-class_method">
  
    .<strong>coulomb_CL_e</strong>(L, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function normalization constant
C_L(\eta) for L &gt; -1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7141
7142
7143
7144
7145
7146
7147
7148
7149
7150
7151
7152
7153
7154
7155
7156
7157</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7141</span>

static VALUE
sf_s_coulomb_CL_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_CL_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_F_array-class_method">
  
    .<strong>coulomb_wave_F_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function F_L(\eta,x) for
L = Lmin \dots Lmin + kmax, storing the results in fc_array.
In the case of overflow the exponent is stored in F_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], F_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6841
6842
6843
6844
6845
6846
6847
6848
6849
6850
6851
6852
6853
6854
6855
6856
6857
6858
6859
6860
6861
6862
6863
6864</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6841</span>

static VALUE
sf_s_coulomb_wave_F_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_F_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FG_array-class_method">
  
    .<strong>coulomb_wave_FG_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the functions F_L(\eta,x),
G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in fc_array and gc_array.  In the case of overflow the
exponents are stored in F_exponent and G_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], gc_array[], F_exponent, G_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6920
6921
6922
6923
6924
6925
6926
6927
6928
6929
6930
6931
6932
6933
6934
6935
6936
6937
6938
6939
6940
6941
6942
6943</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6920</span>

static VALUE
sf_s_coulomb_wave_FG_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,1,shape},{cDF,1,shape},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FG_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,5,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FG_e-class_method">
  
    .<strong>coulomb_wave_FG_e</strong>(eta, x, L_F, k)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave functions F_L(\eta,x),
$G_L-k(\eta,x)$
G_@L-k@(\eta,x) and their derivatives
F’<em>L(\eta,x),
$G’</em>L-k(\eta,x)$
G’_@L-k@(\eta,x)
with respect to x.  The parameters are restricted to L,
L-k &gt; -1/2, x &gt; 0 and integer k.  Note that L
itself is not restricted to being an integer. The results are stored in
the parameters F, G for the function values and Fp,
Gp for the derivative values.  If an overflow occurs,
GSL_EOVRFLW is returned and scaling exponents are stored in
the modifiable parameters exp_F, exp_G.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>L_F</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [F.val, F.err, Fp.val, Fp.err, G.val, G.err, Gp.val, Gp.err, exp_F, exp_G, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6773
6774
6775
6776
6777
6778
6779
6780
6781
6782
6783
6784
6785
6786
6787
6788
6789
6790
6791
6792</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6773</span>

static VALUE
sf_s_coulomb_wave_FG_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[11] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FG_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,11,ain,aout};
    
    void *opt;
    c3 = NUM2INT(v3); opt = &amp;c3; //k
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FGp_array-class_method">
  
    .<strong>coulomb_wave_FGp_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the functions F_L(\eta,x),
G_L(\eta,x) and their derivatives F’_L(\eta,x),
G’_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in fc_array, gc_array, fcp_array and gcp_array.
In the case of overflow the exponents are stored in F_exponent
and G_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], fcp_array[], gc_array[], gcp_array[], F_exponent, G_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7007
7008
7009
7010
7011
7012
7013
7014
7015
7016
7017
7018
7019
7020
7021
7022
7023
7024
7025
7026
7027
7028
7029
7030</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7007</span>

static VALUE
sf_s_coulomb_wave_FGp_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[7] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FGp_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,7,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_sphF_array-class_method">
  
    .<strong>coulomb_wave_sphF_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function divided by the argument
F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the
results in fc_array.  In the case of overflow the exponent is
stored in F_exponent. This function reduces to spherical Bessel
functions in the limit \eta \to 0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], F_exponent[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7081
7082
7083
7084
7085
7086
7087
7088
7089
7090
7091
7092
7093
7094
7095
7096
7097
7098
7099
7100
7101
7102
7103
7104</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7081</span>

static VALUE
sf_s_coulomb_wave_sphF_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_sphF_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_3j-class_method">
  
    .<strong>coupling_3j</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 3-j coefficient,</p>

<p>(ja jb jc
ma mb mc)</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ma</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7245
7246
7247
7248
7249
7250
7251
7252
7253
7254
7255
7256
7257
7258
7259
7260
7261
7262
7263
7264
7265
7266
7267
7268
7269</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7245</span>

static VALUE
sf_s_coupling_3j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    double c6;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c6 = gsl_sf_coupling_3j(c0,c1,c2,c3,c4,c5);
    
    return DBL2NUM(c6);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_3j_e-class_method">
  
    .<strong>coupling_3j_e</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 3-j coefficient,</p>

<p>(ja jb jc
ma mb mc)</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ma</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7292
7293
7294
7295
7296
7297
7298
7299
7300
7301
7302
7303
7304
7305
7306
7307
7308
7309
7310
7311
7312
7313
7314
7315
7316
7317
7318
7319
7320
7321
7322
7323
7324
7325</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7292</span>

static VALUE
sf_s_coupling_3j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    gsl_sf_result c6;
    int c7;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c7 = gsl_sf_coupling_3j_e(c0,c1,c2,c3,c4,c5,&amp;c6);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c6.val));
        rb_ary_push(va,DBL2NUM(c6.err));
        rb_ary_push(va,INT2NUM(c7));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_6j-class_method">
  
    .<strong>coupling_6j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 6-j coefficient,</p>

<p>@jb jc
jd je jf@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7348
7349
7350
7351
7352
7353
7354
7355
7356
7357
7358
7359
7360
7361
7362
7363
7364
7365
7366
7367
7368
7369
7370
7371
7372</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7348</span>

static VALUE
sf_s_coupling_6j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    double c6;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c6 = gsl_sf_coupling_6j(c0,c1,c2,c3,c4,c5);
    
    return DBL2NUM(c6);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_6j_e-class_method">
  
    .<strong>coupling_6j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 6-j coefficient,</p>

<p>@jb jc
jd je jf@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7395
7396
7397
7398
7399
7400
7401
7402
7403
7404
7405
7406
7407
7408
7409
7410
7411
7412
7413
7414
7415
7416
7417
7418
7419
7420
7421
7422
7423
7424
7425
7426
7427
7428</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7395</span>

static VALUE
sf_s_coupling_6j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    gsl_sf_result c6;
    int c7;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c7 = gsl_sf_coupling_6j_e(c0,c1,c2,c3,c4,c5,&amp;c6);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c6.val));
        rb_ary_push(va,DBL2NUM(c6.err));
        rb_ary_push(va,INT2NUM(c7));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_9j-class_method">
  
    .<strong>coupling_9j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 9-j coefficient,</p>

<p>@jb jc
jd je jf
jg jh ji@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jg</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jh</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ji</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7455
7456
7457
7458
7459
7460
7461
7462
7463
7464
7465
7466
7467
7468
7469
7470
7471
7472
7473
7474
7475
7476
7477
7478
7479
7480
7481
7482
7483
7484
7485</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7455</span>

static VALUE
sf_s_coupling_9j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5,VALUE v6,VALUE v7,VALUE v8)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    int c6;
    int c7;
    int c8;
    double c9;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = NUM2INT(v6);
    c7 = NUM2INT(v7);
    c8 = NUM2INT(v8);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c9 = gsl_sf_coupling_9j(c0,c1,c2,c3,c4,c5,c6,c7,c8);
    
    return DBL2NUM(c9);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_9j_e-class_method">
  
    .<strong>coupling_9j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 9-j coefficient,</p>

<p>@jb jc
jd je jf
jg jh ji@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jg</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jh</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ji</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7512
7513
7514
7515
7516
7517
7518
7519
7520
7521
7522
7523
7524
7525
7526
7527
7528
7529
7530
7531
7532
7533
7534
7535
7536
7537
7538
7539
7540
7541
7542
7543
7544
7545
7546
7547
7548
7549
7550
7551</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7512</span>

static VALUE
sf_s_coupling_9j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5,VALUE v6,VALUE v7,VALUE v8)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    int c6;
    int c7;
    int c8;
    gsl_sf_result c9;
    int c10;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = NUM2INT(v6);
    c7 = NUM2INT(v7);
    c8 = NUM2INT(v8);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c10 = gsl_sf_coupling_9j_e(c0,c1,c2,c3,c4,c5,c6,c7,c8,&amp;c9);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c9.val));
        rb_ary_push(va,DBL2NUM(c9.err));
        rb_ary_push(va,INT2NUM(c10));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dawson-class_method">
  
    .<strong>dawson</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the value of Dawson’s integral for x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7581
7582
7583
7584
7585
7586
7587
7588
7589</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7581</span>

static VALUE
sf_s_dawson(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_dawson, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dawson_e-class_method">
  
    .<strong>dawson_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the value of Dawson’s integral for x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7623
7624
7625
7626
7627
7628
7629
7630
7631
7632
7633
7634
7635
7636
7637
7638
7639</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7623</span>

static VALUE
sf_s_dawson_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_dawson_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_1-class_method">
  
    .<strong>debye_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first-order Debye function
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7670
7671
7672
7673
7674
7675
7676
7677
7678</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7670</span>

static VALUE
sf_s_debye_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_1_e-class_method">
  
    .<strong>debye_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first-order Debye function
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7713
7714
7715
7716
7717
7718
7719
7720
7721
7722
7723
7724
7725
7726
7727
7728
7729</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7713</span>

static VALUE
sf_s_debye_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_2-class_method">
  
    .<strong>debye_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order Debye function
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7760
7761
7762
7763
7764
7765
7766
7767
7768</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7760</span>

static VALUE
sf_s_debye_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_2_e-class_method">
  
    .<strong>debye_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order Debye function
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7803
7804
7805
7806
7807
7808
7809
7810
7811
7812
7813
7814
7815
7816
7817
7818
7819</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7803</span>

static VALUE
sf_s_debye_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_3-class_method">
  
    .<strong>debye_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order Debye function
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7850
7851
7852
7853
7854
7855
7856
7857
7858</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7850</span>

static VALUE
sf_s_debye_3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_3_e-class_method">
  
    .<strong>debye_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order Debye function
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7893
7894
7895
7896
7897
7898
7899
7900
7901
7902
7903
7904
7905
7906
7907
7908
7909</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7893</span>

static VALUE
sf_s_debye_3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_4-class_method">
  
    .<strong>debye_4</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fourth-order Debye function
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7940
7941
7942
7943
7944
7945
7946
7947
7948</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7940</span>

static VALUE
sf_s_debye_4(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_4, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_4_e-class_method">
  
    .<strong>debye_4_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fourth-order Debye function
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7983
7984
7985
7986
7987
7988
7989
7990
7991
7992
7993
7994
7995
7996
7997
7998
7999</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7983</span>

static VALUE
sf_s_debye_4_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_4_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_5-class_method">
  
    .<strong>debye_5</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fifth-order Debye function
D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8030
8031
8032
8033
8034
8035
8036
8037
8038</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8030</span>

static VALUE
sf_s_debye_5(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_5, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_5_e-class_method">
  
    .<strong>debye_5_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fifth-order Debye function
D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8073
8074
8075
8076
8077
8078
8079
8080
8081
8082
8083
8084
8085
8086
8087
8088
8089</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8073</span>

static VALUE
sf_s_debye_5_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_5_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_6-class_method">
  
    .<strong>debye_6</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sixth-order Debye function
D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8120
8121
8122
8123
8124
8125
8126
8127
8128</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8120</span>

static VALUE
sf_s_debye_6(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_6, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_6_e-class_method">
  
    .<strong>debye_6_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sixth-order Debye function
D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8163
8164
8165
8166
8167
8168
8169
8170
8171
8172
8173
8174
8175
8176
8177
8178
8179</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8163</span>

static VALUE
sf_s_debye_6_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_6_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dilog-class_method">
  
    .<strong>dilog</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.
Note that \Im(Li_2(x)) = 0 for $x \le 1$
x &lt;= 1, and -\pi\log(x) for x &gt; 1.</p>

<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8216
8217
8218
8219
8220
8221
8222
8223
8224</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8216</span>

static VALUE
sf_s_dilog(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_dilog, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dilog_e-class_method">
  
    .<strong>dilog_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.
Note that \Im(Li_2(x)) = 0 for $x \le 1$
x &lt;= 1, and -\pi\log(x) for x &gt; 1.</p>

<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8265
8266
8267
8268
8269
8270
8271
8272
8273
8274
8275
8276
8277
8278
8279
8280
8281</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8265</span>

static VALUE
sf_s_dilog_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_dilog_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="doublefact-class_method">
  
    .<strong>doublefact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.
The maximum value of n such that n!! is not
considered an overflow is given by the macro GSL_SF_DOUBLEFACT_NMAX
and is 297.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13940
13941
13942
13943
13944
13945
13946
13947
13948</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13940</span>

static VALUE
sf_s_doublefact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_doublefact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="doublefact_e-class_method">
  
    .<strong>doublefact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.
The maximum value of n such that n!! is not
considered an overflow is given by the macro GSL_SF_DOUBLEFACT_NMAX
and is 297.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13985
13986
13987
13988
13989
13990
13991
13992
13993
13994
13995
13996
13997
13998
13999
14000
14001</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13985</span>

static VALUE
sf_s_doublefact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_doublefact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_D-class_method">
  
    .<strong>ellint_D</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the incomplete elliptic integral
D(\phi,k) which is defined through the Carlson form RD(x,y,z)
by the following relation,</p>

<p>D(\phi,k) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).</p>

<p>Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9312
9313
9314
9315
9316
9317
9318
9319
9320
9321
9322
9323
9324
9325
9326
9327
9328
9329
9330
9331
9332
9333
9334
9335
9336
9337
9338
9339</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9312</span>

static VALUE
sf_s_ellint_D(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_D,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_D_e-class_method">
  
    .<strong>ellint_D_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the incomplete elliptic integral
D(\phi,k) which is defined through the Carlson form RD(x,y,z)
by the following relation,</p>

<p>D(\phi,k) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).</p>

<p>Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9386
9387
9388
9389
9390
9391
9392
9393
9394
9395
9396
9397
9398
9399
9400
9401
9402
9403
9404
9405
9406
9407
9408
9409
9410
9411
9412
9413</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9386</span>

static VALUE
sf_s_ellint_D_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_D_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_E-class_method">
  
    .<strong>ellint_E</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9022
9023
9024
9025
9026
9027
9028
9029
9030
9031
9032
9033
9034
9035
9036
9037
9038
9039
9040
9041
9042
9043
9044
9045
9046
9047
9048
9049</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9022</span>

static VALUE
sf_s_ellint_E(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_E,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_E_e-class_method">
  
    .<strong>ellint_E_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9094
9095
9096
9097
9098
9099
9100
9101
9102
9103
9104
9105
9106
9107
9108
9109
9110
9111
9112
9113
9114
9115
9116
9117
9118
9119
9120
9121</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9094</span>

static VALUE
sf_s_ellint_E_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_E_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Ecomp-class_method">
  
    .<strong>ellint_Ecomp</strong>(k[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8614
8615
8616
8617
8618
8619
8620
8621
8622
8623
8624
8625
8626
8627
8628
8629
8630</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8614</span>

static VALUE
sf_s_ellint_Ecomp(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Ecomp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Ecomp_e-class_method">
  
    .<strong>ellint_Ecomp_e</strong>(k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8672
8673
8674
8675
8676
8677
8678
8679
8680
8681
8682
8683
8684
8685
8686
8687
8688
8689
8690
8691
8692
8693
8694
8695
8696
8697
8698
8699</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8672</span>

static VALUE
sf_s_ellint_Ecomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Ecomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_F-class_method">
  
    .<strong>ellint_F</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8882
8883
8884
8885
8886
8887
8888
8889
8890
8891
8892
8893
8894
8895
8896
8897
8898
8899
8900
8901
8902
8903
8904
8905
8906
8907
8908
8909</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8882</span>

static VALUE
sf_s_ellint_F(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_F,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_F_e-class_method">
  
    .<strong>ellint_F_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8954
8955
8956
8957
8958
8959
8960
8961
8962
8963
8964
8965
8966
8967
8968
8969
8970
8971
8972
8973
8974
8975
8976
8977
8978
8979
8980
8981</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8954</span>

static VALUE
sf_s_ellint_F_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_F_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Kcomp-class_method">
  
    .<strong>ellint_Kcomp</strong>(k[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral K(k) to
the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8492
8493
8494
8495
8496
8497
8498
8499
8500
8501
8502
8503
8504
8505
8506
8507
8508</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8492</span>

static VALUE
sf_s_ellint_Kcomp(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Kcomp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Kcomp_e-class_method">
  
    .<strong>ellint_Kcomp_e</strong>(k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral K(k) to
the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8550
8551
8552
8553
8554
8555
8556
8557
8558
8559
8560
8561
8562
8563
8564
8565
8566
8567
8568
8569
8570
8571
8572
8573
8574
8575
8576
8577</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8550</span>

static VALUE
sf_s_ellint_Kcomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Kcomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_P-class_method">
  
    .<strong>ellint_P</strong>(phi, k, n, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9166
9167
9168
9169
9170
9171
9172
9173
9174
9175
9176
9177
9178
9179
9180
9181
9182
9183
9184
9185
9186
9187
9188
9189
9190
9191
9192
9193</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9166</span>

static VALUE
sf_s_ellint_P(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_P,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_P_e-class_method">
  
    .<strong>ellint_P_e</strong>(phi, k, n, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9242
9243
9244
9245
9246
9247
9248
9249
9250
9251
9252
9253
9254
9255
9256
9257
9258
9259
9260
9261
9262
9263
9264
9265
9266
9267
9268
9269</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9242</span>

static VALUE
sf_s_ellint_P_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_P_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Pcomp-class_method">
  
    .<strong>ellint_Pcomp</strong>(k, n, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral \Pi(k,n) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8741
8742
8743
8744
8745
8746
8747
8748
8749
8750
8751
8752
8753
8754
8755
8756
8757
8758
8759
8760
8761
8762
8763
8764
8765
8766
8767
8768</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8741</span>

static VALUE
sf_s_ellint_Pcomp(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Pcomp,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Pcomp_e-class_method">
  
    .<strong>ellint_Pcomp_e</strong>(k, n, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral \Pi(k,n) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8814
8815
8816
8817
8818
8819
8820
8821
8822
8823
8824
8825
8826
8827
8828
8829
8830
8831
8832
8833
8834
8835
8836
8837
8838
8839
8840
8841</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8814</span>

static VALUE
sf_s_ellint_Pcomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Pcomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RC-class_method">
  
    .<strong>ellint_RC</strong>(x, y, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9452
9453
9454
9455
9456
9457
9458
9459
9460
9461
9462
9463
9464
9465
9466
9467
9468
9469
9470
9471
9472
9473
9474
9475
9476
9477
9478
9479</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9452</span>

static VALUE
sf_s_ellint_RC(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RC,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RC_e-class_method">
  
    .<strong>ellint_RC_e</strong>(x, y, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9522
9523
9524
9525
9526
9527
9528
9529
9530
9531
9532
9533
9534
9535
9536
9537
9538
9539
9540
9541
9542
9543
9544
9545
9546
9547
9548
9549</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9522</span>

static VALUE
sf_s_ellint_RC_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RC_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RD-class_method">
  
    .<strong>ellint_RD</strong>(x, y, z, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9591
9592
9593
9594
9595
9596
9597
9598
9599
9600
9601
9602
9603
9604
9605
9606
9607
9608
9609
9610
9611
9612
9613
9614
9615
9616
9617
9618</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9591</span>

static VALUE
sf_s_ellint_RD(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RD,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RD_e-class_method">
  
    .<strong>ellint_RD_e</strong>(x, y, z, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9664
9665
9666
9667
9668
9669
9670
9671
9672
9673
9674
9675
9676
9677
9678
9679
9680
9681
9682
9683
9684
9685
9686
9687
9688
9689
9690
9691</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9664</span>

static VALUE
sf_s_ellint_RD_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RD_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RF-class_method">
  
    .<strong>ellint_RF</strong>(x, y, z, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9733
9734
9735
9736
9737
9738
9739
9740
9741
9742
9743
9744
9745
9746
9747
9748
9749
9750
9751
9752
9753
9754
9755
9756
9757
9758
9759
9760</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9733</span>

static VALUE
sf_s_ellint_RF(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RF,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RF_e-class_method">
  
    .<strong>ellint_RF_e</strong>(x, y, z, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9806
9807
9808
9809
9810
9811
9812
9813
9814
9815
9816
9817
9818
9819
9820
9821
9822
9823
9824
9825
9826
9827
9828
9829
9830
9831
9832
9833</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9806</span>

static VALUE
sf_s_ellint_RF_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RF_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RJ-class_method">
  
    .<strong>ellint_RJ</strong>(x, y, z, p, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>p</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9878
9879
9880
9881
9882
9883
9884
9885
9886
9887
9888
9889
9890
9891
9892
9893
9894
9895
9896
9897
9898
9899
9900
9901
9902
9903
9904
9905</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9878</span>

static VALUE
sf_s_ellint_RJ(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c4;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RJ,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    void *opt;
    if (argc==4) {
        c4 = GSL_MODE_DEFAULT;
    } else if (argc==5) {
        c4 = NUM2INT(v[4]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 4 or 5&quot;,argc);
    }
    opt = &amp;c4; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,4,v[0],v[1],v[2],v[3]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RJ_e-class_method">
  
    .<strong>ellint_RJ_e</strong>(x, y, z, p, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>p</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9954
9955
9956
9957
9958
9959
9960
9961
9962
9963
9964
9965
9966
9967
9968
9969
9970
9971
9972
9973
9974
9975
9976
9977
9978
9979
9980
9981</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9954</span>

static VALUE
sf_s_ellint_RJ_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c4;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RJ_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    void *opt;
    if (argc==4) {
        c4 = GSL_MODE_DEFAULT;
    } else if (argc==5) {
        c4 = NUM2INT(v[4]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 4 or 5&quot;,argc);
    }
    opt = &amp;c4; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,4,v[0],v[1],v[2],v[3]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="elljac_e-class_method">
  
    .<strong>elljac_e</strong>(u, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Jacobian elliptic functions sn(u|m),
cn(u|m), dn(u|m) by descending Landen
transformations.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>u</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [sn, cn, dn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10026
10027
10028
10029
10030
10031
10032
10033
10034
10035
10036
10037
10038
10039
10040
10041
10042</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10026</span>

static VALUE
sf_s_elljac_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_elljac_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf-class_method">
  
    .<strong>erf</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the error function $\erf(x)$
erf(x), where
$\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10075
10076
10077
10078
10079
10080
10081
10082
10083</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10075</span>

static VALUE
sf_s_erf(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_e-class_method">
  
    .<strong>erf_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the error function $\erf(x)$
erf(x), where
$\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10120
10121
10122
10123
10124
10125
10126
10127
10128
10129
10130
10131
10132
10133
10134
10135
10136</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10120</span>

static VALUE
sf_s_erf_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Q-class_method">
  
    .<strong>erf_Q</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the upper tail of the Gaussian probability
function
$Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$
Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10441
10442
10443
10444
10445
10446
10447
10448
10449</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10441</span>

static VALUE
sf_s_erf_Q(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Q, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Q_e-class_method">
  
    .<strong>erf_Q_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the upper tail of the Gaussian probability
function
$Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$
Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10486
10487
10488
10489
10490
10491
10492
10493
10494
10495
10496
10497
10498
10499
10500
10501
10502</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10486</span>

static VALUE
sf_s_erf_Q_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Q_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Z-class_method">
  
    .<strong>erf_Z</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gaussian probability density function
$Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$
Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10349
10350
10351
10352
10353
10354
10355
10356
10357</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10349</span>

static VALUE
sf_s_erf_Z(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Z, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Z_e-class_method">
  
    .<strong>erf_Z_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gaussian probability density function
$Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$
Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10392
10393
10394
10395
10396
10397
10398
10399
10400
10401
10402
10403
10404
10405
10406
10407
10408</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10392</span>

static VALUE
sf_s_erf_Z_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Z_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erfc-class_method">
  
    .<strong>erfc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary error function
$\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10168
10169
10170
10171
10172
10173
10174
10175
10176</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10168</span>

static VALUE
sf_s_erfc(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erfc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erfc_e-class_method">
  
    .<strong>erfc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary error function
$\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10212
10213
10214
10215
10216
10217
10218
10219
10220
10221
10222
10223
10224
10225
10226
10227
10228</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10212</span>

static VALUE
sf_s_erfc_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erfc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta-class_method">
  
    .<strong>eta</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(s) for arbitrary s.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24878
24879
24880
24881
24882
24883
24884
24885
24886</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24878</span>

static VALUE
sf_s_eta(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_eta, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_e-class_method">
  
    .<strong>eta_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(s) for arbitrary s.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24920
24921
24922
24923
24924
24925
24926
24927
24928
24929
24930
24931
24932
24933
24934
24935
24936</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24920</span>

static VALUE
sf_s_eta_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_eta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_int-class_method">
  
    .<strong>eta_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(n) for integer n.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24805
24806
24807
24808
24809
24810
24811
24812
24813</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24805</span>

static VALUE
sf_s_eta_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_eta_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_int_e-class_method">
  
    .<strong>eta_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(n) for integer n.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24825
24826
24827
24828
24829
24830
24831
24832
24833
24834
24835
24836
24837
24838
24839
24840
24841
24842
24843
24844
24845
24846
24847
24848</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24825</span>

static VALUE
sf_s_eta_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_eta_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp-class_method">
  
    .<strong>exp</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10621
10622
10623
10624
10625
10626
10627
10628
10629</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10621</span>

static VALUE
sf_s_exp(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_e-class_method">
  
    .<strong>exp_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10664
10665
10666
10667
10668
10669
10670
10671
10672
10673
10674
10675
10676
10677
10678
10679
10680</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10664</span>

static VALUE
sf_s_exp_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_e10_e-class_method">
  
    .<strong>exp_e10_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the exponential \exp(x) using the
gsl_sf_result_e10 type to return a result with extended range.
This function may be useful if the value of \exp(x) would
overflow the  numeric range of double.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10717
10718
10719
10720
10721
10722
10723
10724
10725
10726
10727
10728
10729
10730
10731
10732
10733</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10717</span>

static VALUE
sf_s_exp_e10_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_err_e-class_method">
  
    .<strong>exp_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function exponentiates x with an associated absolute error
dx.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11314
11315
11316
11317
11318
11319
11320
11321
11322
11323
11324
11325
11326
11327
11328
11329
11330</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11314</span>

static VALUE
sf_s_exp_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_err_e10_e-class_method">
  
    .<strong>exp_err_e10_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function exponentiates a quantity x with an associated absolute
error dx using the gsl_sf_result_e10 type to return a result with
extended range.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11369
11370
11371
11372
11373
11374
11375
11376
11377
11378
11379
11380
11381
11382
11383
11384
11385</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11369</span>

static VALUE
sf_s_exp_err_e10_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_err_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult-class_method">
  
    .<strong>exp_mult</strong>(x, y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines exponentiate x and multiply by the factor y
to return the product y \exp(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10767
10768
10769
10770
10771
10772
10773
10774
10775</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10767</span>

static VALUE
sf_s_exp_mult(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_e-class_method">
  
    .<strong>exp_mult_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines exponentiate x and multiply by the factor y
to return the product y \exp(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10813
10814
10815
10816
10817
10818
10819
10820
10821
10822
10823
10824
10825
10826
10827
10828
10829</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10813</span>

static VALUE
sf_s_exp_mult_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_e10_e-class_method">
  
    .<strong>exp_mult_e10_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the product y \exp(x) using the
gsl_sf_result_e10 type to return a result with extended numeric
range.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10868
10869
10870
10871
10872
10873
10874
10875
10876
10877
10878
10879
10880
10881
10882
10883
10884</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10868</span>

static VALUE
sf_s_exp_mult_e10_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_err_e-class_method">
  
    .<strong>exp_mult_err_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the product y \exp(x) for the quantities
x, y with associated absolute errors dx, dy.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11429
11430
11431
11432
11433
11434
11435
11436
11437
11438
11439
11440
11441
11442
11443
11444
11445</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11429</span>

static VALUE
sf_s_exp_mult_err_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_err_e10_e-class_method">
  
    .<strong>exp_mult_err_e10_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the product y \exp(x) for the quantities
x, y with associated absolute errors dx, dy using the
gsl_sf_result_e10 type to return a result with extended range.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11490
11491
11492
11493
11494
11495
11496
11497
11498
11499
11500
11501
11502
11503
11504
11505
11506</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11490</span>

static VALUE
sf_s_exp_mult_err_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_err_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_3-class_method">
  
    .<strong>expint_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$
Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$
x &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12124
12125
12126
12127
12128
12129
12130
12131
12132</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12124</span>

static VALUE
sf_s_expint_3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_3_e-class_method">
  
    .<strong>expint_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$
Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$
x &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12168
12169
12170
12171
12172
12173
12174
12175
12176
12177
12178
12179
12180
12181
12182
12183
12184</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12168</span>

static VALUE
sf_s_expint_3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E1-class_method">
  
    .<strong>expint_E1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_1(x),</p>

<p>E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11540
11541
11542
11543
11544
11545
11546
11547
11548</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11540</span>

static VALUE
sf_s_expint_E1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E1_e-class_method">
  
    .<strong>expint_E1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_1(x),</p>

<p>E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11586
11587
11588
11589
11590
11591
11592
11593
11594
11595
11596
11597
11598
11599
11600
11601
11602</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11586</span>

static VALUE
sf_s_expint_E1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E2-class_method">
  
    .<strong>expint_E2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order exponential integral E_2(x),</p>

<p>E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11636
11637
11638
11639
11640
11641
11642
11643
11644</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11636</span>

static VALUE
sf_s_expint_E2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E2_e-class_method">
  
    .<strong>expint_E2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order exponential integral E_2(x),</p>

<p>E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11682
11683
11684
11685
11686
11687
11688
11689
11690
11691
11692
11693
11694
11695
11696
11697
11698</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11682</span>

static VALUE
sf_s_expint_E2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_Ei-class_method">
  
    .<strong>expint_Ei</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral $\hboxEi(x)$
Ei(x),</p>

<p>Ei(x) := - PV(\int_@-x@^\infty dt \exp(-t)/t)</p>

<p>where PV denotes the principal value of the integral.
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11844
11845
11846
11847
11848
11849
11850
11851
11852</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11844</span>

static VALUE
sf_s_expint_Ei(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_Ei, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_Ei_e-class_method">
  
    .<strong>expint_Ei_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral $\hboxEi(x)$
Ei(x),</p>

<p>Ei(x) := - PV(\int_@-x@^\infty dt \exp(-t)/t)</p>

<p>where PV denotes the principal value of the integral.
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11892
11893
11894
11895
11896
11897
11898
11899
11900
11901
11902
11903
11904
11905
11906
11907
11908</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11892</span>

static VALUE
sf_s_expint_Ei_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_Ei_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_En-class_method">
  
    .<strong>expint_En</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_n(x) of order n,</p>

<p>E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11735
11736
11737
11738
11739
11740
11741
11742
11743
11744
11745
11746</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11735</span>

static VALUE
sf_s_expint_En(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_En, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_En_e-class_method">
  
    .<strong>expint_En_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_n(x) of order n,</p>

<p>E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11789
11790
11791
11792
11793
11794
11795
11796
11797
11798
11799
11800
11801
11802
11803
11804
11805
11806
11807
11808</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11789</span>

static VALUE
sf_s_expint_En_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_En_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expm1-class_method">
  
    .<strong>expm1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10915
10916
10917
10918
10919
10920
10921
10922
10923</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10915</span>

static VALUE
sf_s_expm1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expm1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expm1_e-class_method">
  
    .<strong>expm1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10958
10959
10960
10961
10962
10963
10964
10965
10966
10967
10968
10969
10970
10971
10972
10973
10974</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10958</span>

static VALUE
sf_s_expm1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expm1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel-class_method">
  
    .<strong>exprel</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2<em>3) + x^3/(2</em>3*4) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11007
11008
11009
11010
11011
11012
11013
11014
11015</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11007</span>

static VALUE
sf_s_exprel(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_2-class_method">
  
    .<strong>exprel_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 =
1 + x/3 + x^2/(3<em>4) + x^3/(3</em>4*5) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11101
11102
11103
11104
11105
11106
11107
11108
11109</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11101</span>

static VALUE
sf_s_exprel_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_2_e-class_method">
  
    .<strong>exprel_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 =
1 + x/3 + x^2/(3<em>4) + x^3/(3</em>4*5) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11146
11147
11148
11149
11150
11151
11152
11153
11154
11155
11156
11157
11158
11159
11160
11161
11162</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11146</span>

static VALUE
sf_s_exprel_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_e-class_method">
  
    .<strong>exprel_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2<em>3) + x^3/(2</em>3*4) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11052
11053
11054
11055
11056
11057
11058
11059
11060
11061
11062
11063
11064
11065
11066
11067
11068</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11052</span>

static VALUE
sf_s_exprel_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_n-class_method">
  
    .<strong>exprel_n</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the N-relative exponential, which is the
n-th generalization of the functions gsl_sf_exprel and
gsl_sf_exprel_2.  The N-relative exponential is given by,</p>

<p>exprel_N(x) = N!/x^N (\exp(x) - \sum_@k=0@^@N-1@ x^k/k!)
          = 1 + x/(N+1) + x^2/((N+1)(N+2)) + …
          = 1F1 (1,1+N,x)
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11201
11202
11203
11204
11205
11206
11207
11208
11209
11210
11211
11212</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11201</span>

static VALUE
sf_s_exprel_n(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_n, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_n_e-class_method">
  
    .<strong>exprel_n_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the N-relative exponential, which is the
n-th generalization of the functions gsl_sf_exprel and
gsl_sf_exprel_2.  The N-relative exponential is given by,</p>

<p>exprel_N(x) = N!/x^N (\exp(x) - \sum_@k=0@^@N-1@ x^k/k!)
          = 1 + x/(N+1) + x^2/((N+1)(N+2)) + …
          = 1F1 (1,1+N,x)
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11257
11258
11259
11260
11261
11262
11263
11264
11265
11266
11267
11268
11269
11270
11271
11272
11273
11274
11275
11276</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11257</span>

static VALUE
sf_s_exprel_n_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fact-class_method">
  
    .<strong>fact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
The maximum value of n such that n! is not
considered an overflow is given by the macro GSL_SF_FACT_NMAX
and is 170.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13844
13845
13846
13847
13848
13849
13850
13851
13852</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13844</span>

static VALUE
sf_s_fact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fact_e-class_method">
  
    .<strong>fact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
The maximum value of n such that n! is not
considered an overflow is given by the macro GSL_SF_FACT_NMAX
and is 170.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13890
13891
13892
13893
13894
13895
13896
13897
13898
13899
13900
13901
13902
13903
13904
13905
13906</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13890</span>

static VALUE
sf_s_fact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_0-class_method">
  
    .<strong>fermi_dirac_0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 0.
This integral is given by F_0(x) = \ln(1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12583
12584
12585
12586
12587
12588
12589
12590
12591</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12583</span>

static VALUE
sf_s_fermi_dirac_0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_0_e-class_method">
  
    .<strong>fermi_dirac_0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 0.
This integral is given by F_0(x) = \ln(1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12626
12627
12628
12629
12630
12631
12632
12633
12634
12635
12636
12637
12638
12639
12640
12641
12642</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12626</span>

static VALUE
sf_s_fermi_dirac_0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_1-class_method">
  
    .<strong>fermi_dirac_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12673
12674
12675
12676
12677
12678
12679
12680
12681</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12673</span>

static VALUE
sf_s_fermi_dirac_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_1_e-class_method">
  
    .<strong>fermi_dirac_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12716
12717
12718
12719
12720
12721
12722
12723
12724
12725
12726
12727
12728
12729
12730
12731
12732</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12716</span>

static VALUE
sf_s_fermi_dirac_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_2-class_method">
  
    .<strong>fermi_dirac_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12764
12765
12766
12767
12768
12769
12770
12771
12772</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12764</span>

static VALUE
sf_s_fermi_dirac_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_2_e-class_method">
  
    .<strong>fermi_dirac_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12808
12809
12810
12811
12812
12813
12814
12815
12816
12817
12818
12819
12820
12821
12822
12823
12824</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12808</span>

static VALUE
sf_s_fermi_dirac_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_3half-class_method">
  
    .<strong>fermi_dirac_3half</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_3/2(x)$
F_@3/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13148
13149
13150
13151
13152
13153
13154
13155
13156</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13148</span>

static VALUE
sf_s_fermi_dirac_3half(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_3half, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_3half_e-class_method">
  
    .<strong>fermi_dirac_3half_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_3/2(x)$
F_@3/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13192
13193
13194
13195
13196
13197
13198
13199
13200
13201
13202
13203
13204
13205
13206
13207
13208</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13192</span>

static VALUE
sf_s_fermi_dirac_3half_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_3half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_half-class_method">
  
    .<strong>fermi_dirac_half</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_1/2(x)$
F_@1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13056
13057
13058
13059
13060
13061
13062
13063
13064</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13056</span>

static VALUE
sf_s_fermi_dirac_half(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_half, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_half_e-class_method">
  
    .<strong>fermi_dirac_half_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_1/2(x)$
F_@1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13100
13101
13102
13103
13104
13105
13106
13107
13108
13109
13110
13111
13112
13113
13114
13115
13116</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13100</span>

static VALUE
sf_s_fermi_dirac_half_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_inc_0-class_method">
  
    .<strong>fermi_dirac_inc_0</strong>(x, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
$F_0(x,b) = \ln(1 + e^b-x) - (b-x)$
F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13244
13245
13246
13247
13248
13249
13250
13251
13252</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13244</span>

static VALUE
sf_s_fermi_dirac_inc_0(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_inc_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_inc_0_e-class_method">
  
    .<strong>fermi_dirac_inc_0_e</strong>(x, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
$F_0(x,b) = \ln(1 + e^b-x) - (b-x)$
F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13292
13293
13294
13295
13296
13297
13298
13299
13300
13301
13302
13303
13304
13305
13306
13307
13308</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13292</span>

static VALUE
sf_s_fermi_dirac_inc_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_inc_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_int-class_method">
  
    .<strong>fermi_dirac_int</strong>(j, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
Complete integral F_j(x) for integer j
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12860
12861
12862
12863
12864
12865
12866
12867
12868
12869
12870
12871</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12860</span>

static VALUE
sf_s_fermi_dirac_int(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_int_e-class_method">
  
    .<strong>fermi_dirac_int_e</strong>(j, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
Complete integral F_j(x) for integer j
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12913
12914
12915
12916
12917
12918
12919
12920
12921
12922
12923
12924
12925
12926
12927
12928
12929
12930
12931
12932</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12913</span>

static VALUE
sf_s_fermi_dirac_int_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //j
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_m1-class_method">
  
    .<strong>fermi_dirac_m1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of -1.
This integral is given by
$F_-1(x) = e^x / (1 + e^x)$
F_@-1@(x) = e^x / (1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12491
12492
12493
12494
12495
12496
12497
12498
12499</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12491</span>

static VALUE
sf_s_fermi_dirac_m1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_m1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_m1_e-class_method">
  
    .<strong>fermi_dirac_m1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of -1.
This integral is given by
$F_-1(x) = e^x / (1 + e^x)$
F_@-1@(x) = e^x / (1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12536
12537
12538
12539
12540
12541
12542
12543
12544
12545
12546
12547
12548
12549
12550
12551
12552</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12536</span>

static VALUE
sf_s_fermi_dirac_m1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_m1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_mhalf-class_method">
  
    .<strong>fermi_dirac_mhalf</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_-1/2(x)$
F_@-1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12964
12965
12966
12967
12968
12969
12970
12971
12972</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12964</span>

static VALUE
sf_s_fermi_dirac_mhalf(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_mhalf, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_mhalf_e-class_method">
  
    .<strong>fermi_dirac_mhalf_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_-1/2(x)$
F_@-1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13008
13009
13010
13011
13012
13013
13014
13015
13016
13017
13018
13019
13020
13021
13022
13023
13024</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13008</span>

static VALUE
sf_s_fermi_dirac_mhalf_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_mhalf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma-class_method">
  
    .<strong>gamma</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro GSL_SF_GAMMA_XMAX
and is 171.0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13342
13343
13344
13345
13346
13347
13348
13349
13350</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13342</span>

static VALUE
sf_s_gamma(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_e-class_method">
  
    .<strong>gamma_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro GSL_SF_GAMMA_XMAX
and is 171.0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13388
13389
13390
13391
13392
13393
13394
13395
13396
13397
13398
13399
13400
13401
13402
13403
13404</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13388</span>

static VALUE
sf_s_gamma_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc-class_method">
  
    .<strong>gamma_inc</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the unnormalized incomplete Gamma Function
$\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$
\Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t)
for a real and $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14894
14895
14896
14897
14898
14899
14900
14901
14902</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14894</span>

static VALUE
sf_s_gamma_inc(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_e-class_method">
  
    .<strong>gamma_inc_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the unnormalized incomplete Gamma Function
$\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$
\Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t)
for a real and $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14943
14944
14945
14946
14947
14948
14949
14950
14951
14952
14953
14954
14955
14956
14957
14958
14959</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14943</span>

static VALUE
sf_s_gamma_inc_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_P-class_method">
  
    .<strong>gamma_inc_P</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary normalized incomplete Gamma Function
$P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$
P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.</p>

<p>Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15101
15102
15103
15104
15105
15106
15107
15108
15109</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15101</span>

static VALUE
sf_s_gamma_inc_P(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_P, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_P_e-class_method">
  
    .<strong>gamma_inc_P_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary normalized incomplete Gamma Function
$P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$
P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.</p>

<p>Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15153
15154
15155
15156
15157
15158
15159
15160
15161
15162
15163
15164
15165
15166
15167
15168
15169</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15153</span>

static VALUE
sf_s_gamma_inc_P_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_P_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_Q-class_method">
  
    .<strong>gamma_inc_Q</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Gamma Function
$Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14996
14997
14998
14999
15000
15001
15002
15003
15004</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14996</span>

static VALUE
sf_s_gamma_inc_Q(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_Q, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_Q_e-class_method">
  
    .<strong>gamma_inc_Q_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Gamma Function
$Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15045
15046
15047
15048
15049
15050
15051
15052
15053
15054
15055
15056
15057
15058
15059
15060
15061</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15045</span>

static VALUE
sf_s_gamma_inc_Q_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_Q_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammainv-class_method">
  
    .<strong>gammainv</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
exceptions: GSL_EUNDRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13687
13688
13689
13690
13691
13692
13693
13694
13695</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13687</span>

static VALUE
sf_s_gammainv(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gammainv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammainv_e-class_method">
  
    .<strong>gammainv_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
exceptions: GSL_EUNDRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13730
13731
13732
13733
13734
13735
13736
13737
13738
13739
13740
13741
13742
13743
13744
13745
13746</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13730</span>

static VALUE
sf_s_gammainv_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gammainv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammastar-class_method">
  
    .<strong>gammastar</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regulated Gamma Function \Gamma^*(x)
for x &gt; 0. The regulated gamma function is given by,</p>

<p>\Gamma^*(x) = \Gamma(x)/(\sqrt@2\pi@ x^@(x-1/2)@ \exp(-x))
          = (1 + (1/12x) + …)  for x \to \infty
and is a useful suggestion of Temme.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13593
13594
13595
13596
13597
13598
13599
13600
13601</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13593</span>

static VALUE
sf_s_gammastar(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gammastar, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammastar_e-class_method">
  
    .<strong>gammastar_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regulated Gamma Function \Gamma^*(x)
for x &gt; 0. The regulated gamma function is given by,</p>

<p>\Gamma^*(x) = \Gamma(x)/(\sqrt@2\pi@ x^@(x-1/2)@ \exp(-x))
          = (1 + (1/12x) + …)  for x \to \infty
and is a useful suggestion of Temme.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13640
13641
13642
13643
13644
13645
13646
13647
13648
13649
13650
13651
13652
13653
13654
13655
13656</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13640</span>

static VALUE
sf_s_gammastar_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gammastar_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_1-class_method">
  
    .<strong>gegenpoly_1</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15513
15514
15515
15516
15517
15518
15519
15520
15521</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15513</span>

static VALUE
sf_s_gegenpoly_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_1_e-class_method">
  
    .<strong>gegenpoly_1_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15649
15650
15651
15652
15653
15654
15655
15656
15657
15658
15659
15660
15661
15662
15663
15664
15665</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15649</span>

static VALUE
sf_s_gegenpoly_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_2-class_method">
  
    .<strong>gegenpoly_2</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15557
15558
15559
15560
15561
15562
15563
15564
15565</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15557</span>

static VALUE
sf_s_gegenpoly_2(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_2, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_2_e-class_method">
  
    .<strong>gegenpoly_2_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15705
15706
15707
15708
15709
15710
15711
15712
15713
15714
15715
15716
15717
15718
15719
15720
15721</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15705</span>

static VALUE
sf_s_gegenpoly_2_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_3-class_method">
  
    .<strong>gegenpoly_3</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15601
15602
15603
15604
15605
15606
15607
15608
15609</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15601</span>

static VALUE
sf_s_gegenpoly_3(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_3, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_3_e-class_method">
  
    .<strong>gegenpoly_3_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15761
15762
15763
15764
15765
15766
15767
15768
15769
15770
15771
15772
15773
15774
15775
15776
15777</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15761</span>

static VALUE
sf_s_gegenpoly_3_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_array-class_method">
  
    .<strong>gegenpoly_array</strong>(nmax, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an array of Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) for n = 0, 1, 2, \dots, nmax, subject
to \lambda &gt; -1/2, $nmax \ge 0$
nmax &gt;= 0.
Conditions: n = 0, 1, 2, … nmax
Domain: lambda &gt; -1/2, nmax &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15951
15952
15953
15954
15955
15956
15957
15958
15959
15960
15961
15962
15963
15964
15965
15966
15967
15968
15969
15970
15971
15972
15973
15974</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15951</span>

static VALUE
sf_s_gegenpoly_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //nmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_n-class_method">
  
    .<strong>gegenpoly_n</strong>(n, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) for a specific value of n,
lambda, x subject to \lambda &gt; -1/2, $n \ge 0$
n &gt;= 0.
Domain: lambda &gt; -1/2, n &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15819
15820
15821
15822
15823
15824
15825
15826
15827
15828
15829
15830
15831
15832
15833
15834
15835
15836
15837
15838</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15819</span>

static VALUE
sf_s_gegenpoly_n(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_n,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_n_e-class_method">
  
    .<strong>gegenpoly_n_e</strong>(n, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) for a specific value of n,
lambda, x subject to \lambda &gt; -1/2, $n \ge 0$
n &gt;= 0.
Domain: lambda &gt; -1/2, n &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15884
15885
15886
15887
15888
15889
15890
15891
15892
15893
15894
15895
15896
15897
15898
15899
15900
15901
15902
15903</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15884</span>

static VALUE
sf_s_gegenpoly_n_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hazard-class_method">
  
    .<strong>hazard</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hazard function for the normal distribution.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10532
10533
10534
10535
10536
10537
10538
10539
10540</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10532</span>

static VALUE
sf_s_hazard(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hazard, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hazard_e-class_method">
  
    .<strong>hazard_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hazard function for the normal distribution.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10574
10575
10576
10577
10578
10579
10580
10581
10582
10583
10584
10585
10586
10587
10588
10589
10590</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10574</span>

static VALUE
sf_s_hazard_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hazard_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR-class_method">
  
    .<strong>hydrogenicR</strong>(n, l, Z, r)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the n-th normalized hydrogenic bound state
radial wavefunction,</p>

<p>R_n := 2 (Z^@3/2@/n^2) \sqrt@(n-l-1)!/(n+l)!@ \exp(-Z r/n) (2Zr/n)^l
        L^@2l+1@_@n-l-1@(2Zr/n).</p>

<p>where L^a_b(x) is the generalized Laguerre polynomial (Laguerre Functions).
The normalization is chosen such that the wavefunction \psi is
given by
$\psi(n,l,r) = R_n Y_lm$
\psi(n,l,r) = R_n Y_@lm@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6611
6612
6613
6614
6615
6616
6617
6618
6619
6620
6621
6622
6623</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6611</span>

static VALUE
sf_s_hydrogenicR(VALUE mod, VALUE v0, VALUE v1, VALUE v2, VALUE v3){
#line 37 &quot;../gen/tmpl/m_DFloat_f_int_x2_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[2];

    opts[0] = NUM2INT(v0);
    opts[1] = NUM2INT(v1);

    return na_ndloop3(&amp;ndf, opts, 2, v2, v3);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_1-class_method">
  
    .<strong>hydrogenicR_1</strong>(Z, r)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$
R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6503
6504
6505
6506
6507
6508
6509
6510
6511</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6503</span>

static VALUE
sf_s_hydrogenicR_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_1_e-class_method">
  
    .<strong>hydrogenicR_1_e</strong>(Z, r)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$
R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6549
6550
6551
6552
6553
6554
6555
6556
6557
6558
6559
6560
6561
6562
6563
6564
6565</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6549</span>

static VALUE
sf_s_hydrogenicR_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_e-class_method">
  
    .<strong>hydrogenicR_e</strong>(n, l, Z, r)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the n-th normalized hydrogenic bound state
radial wavefunction,</p>

<p>R_n := 2 (Z^@3/2@/n^2) \sqrt@(n-l-1)!/(n+l)!@ \exp(-Z r/n) (2Zr/n)^l
        L^@2l+1@_@n-l-1@(2Zr/n).</p>

<p>where L^a_b(x) is the generalized Laguerre polynomial (Laguerre Functions).
The normalization is chosen such that the wavefunction \psi is
given by
$\psi(n,l,r) = R_n Y_lm$
\psi(n,l,r) = R_n Y_@lm@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6679
6680
6681
6682
6683
6684
6685
6686
6687
6688
6689
6690
6691
6692
6693
6694
6695
6696
6697
6698
6699
6700
6701
6702</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6679</span>

static VALUE
sf_s_hydrogenicR_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //n
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_0F1-class_method">
  
    .<strong>hyperg_0F1</strong>(c, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}<em>0F_1(c,x)$
0F1(c,x).
It is related to Bessel functions
0F1[c,x] =
Gamma[c]    x^(1/2(1-c)) I</em>(c-1)(2 Sqrt[x])
Gamma[c] (-x)^(1/2(1-c)) J_(c-1)(2 Sqrt[-x])
exceptions: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16012
16013
16014
16015
16016
16017
16018
16019
16020</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16012</span>

static VALUE
sf_s_hyperg_0F1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_0F1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_0F1_e-class_method">
  
    .<strong>hyperg_0F1_e</strong>(c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}<em>0F_1(c,x)$
0F1(c,x).
It is related to Bessel functions
0F1[c,x] =
Gamma[c]    x^(1/2(1-c)) I</em>(c-1)(2 Sqrt[x])
Gamma[c] (-x)^(1/2(1-c)) J_(c-1)(2 Sqrt[-x])
exceptions: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16062
16063
16064
16065
16066
16067
16068
16069
16070
16071
16072
16073
16074
16075
16076
16077
16078</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16062</span>

static VALUE
sf_s_hyperg_0F1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_0F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1-class_method">
  
    .<strong>hyperg_1F1</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(a,b,x) = M(a,b,x)$
1F1(a,b,x) = M(a,b,x) for general parameters a, b.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16250
16251
16252
16253
16254
16255
16256
16257
16258</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16250</span>

static VALUE
sf_s_hyperg_1F1(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_e-class_method">
  
    .<strong>hyperg_1F1_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(a,b,x) = M(a,b,x)$
1F1(a,b,x) = M(a,b,x) for general parameters a, b.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16300
16301
16302
16303
16304
16305
16306
16307
16308
16309
16310
16311
16312
16313
16314
16315
16316</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16300</span>

static VALUE
sf_s_hyperg_1F1_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_int-class_method">
  
    .<strong>hyperg_1F1_int</strong>(m, n, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(m,n,x) = M(m,n,x)$
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16120
16121
16122
16123
16124
16125
16126
16127
16128
16129
16130
16131
16132
16133
16134
16135
16136
16137
16138
16139
16140
16141
16142
16143</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16120</span>

static VALUE
sf_s_hyperg_1F1_int(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_int,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_int_e-class_method">
  
    .<strong>hyperg_1F1_int_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(m,n,x) = M(m,n,x)$
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16189
16190
16191
16192
16193
16194
16195
16196
16197
16198
16199
16200
16201
16202
16203
16204
16205
16206
16207
16208
16209
16210
16211
16212</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16189</span>

static VALUE
sf_s_hyperg_1F1_int_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F0-class_method">
  
    .<strong>hyperg_2F0</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &lt; 0 we
have
${}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)$
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17197
17198
17199
17200
17201
17202
17203
17204
17205</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17197</span>

static VALUE
sf_s_hyperg_2F0(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F0, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F0_e-class_method">
  
    .<strong>hyperg_2F0_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &lt; 0 we
have
${}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)$
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17250
17251
17252
17253
17254
17255
17256
17257
17258
17259
17260
17261
17262
17263
17264
17265
17266</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17250</span>

static VALUE
sf_s_hyperg_2F0_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1-class_method">
  
    .<strong>hyperg_2F1</strong>(a, b, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a,b,c,x) = F(a,b,c,x)$
2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.</p>

<p>If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code GSL_EMAXITER when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16720
16721
16722
16723
16724
16725
16726
16727
16728
16729
16730
16731
16732
16733
16734
16735
16736</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16720</span>

static VALUE
sf_s_hyperg_2F1(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj-class_method">
  
    .<strong>hyperg_2F1_conj</strong>(aR, aI, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a_R + i a_I, aR - i aI, c, x)$
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters
for |x| &lt; 1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16843
16844
16845
16846
16847
16848
16849
16850
16851
16852
16853
16854
16855
16856
16857
16858
16859</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16843</span>

static VALUE
sf_s_hyperg_2F1_conj(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_e-class_method">
  
    .<strong>hyperg_2F1_conj_e</strong>(aR, aI, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a_R + i a_I, aR - i aI, c, x)$
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters
for |x| &lt; 1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16904
16905
16906
16907
16908
16909
16910
16911
16912
16913
16914
16915
16916
16917
16918
16919
16920</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16904</span>

static VALUE
sf_s_hyperg_2F1_conj_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_renorm-class_method">
  
    .<strong>hyperg_2F1_conj_renorm</strong>(aR, aI, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17079
17080
17081
17082
17083
17084
17085
17086
17087
17088
17089
17090
17091
17092
17093
17094
17095</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17079</span>

static VALUE
sf_s_hyperg_2F1_conj_renorm(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_renorm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_renorm_e-class_method">
  
    .<strong>hyperg_2F1_conj_renorm_e</strong>(aR, aI, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17140
17141
17142
17143
17144
17145
17146
17147
17148
17149
17150
17151
17152
17153
17154
17155
17156</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17140</span>

static VALUE
sf_s_hyperg_2F1_conj_renorm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_renorm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_e-class_method">
  
    .<strong>hyperg_2F1_e</strong>(a, b, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a,b,c,x) = F(a,b,c,x)$
2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.</p>

<p>If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code GSL_EMAXITER when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16786
16787
16788
16789
16790
16791
16792
16793
16794
16795
16796
16797
16798
16799
16800
16801
16802</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16786</span>

static VALUE
sf_s_hyperg_2F1_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_renorm-class_method">
  
    .<strong>hyperg_2F1_renorm</strong>(a, b, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a,b,c,x) / \Gamma(c)$
2F1(a,b,c,x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16961
16962
16963
16964
16965
16966
16967
16968
16969
16970
16971
16972
16973
16974
16975
16976
16977</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16961</span>

static VALUE
sf_s_hyperg_2F1_renorm(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_renorm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_renorm_e-class_method">
  
    .<strong>hyperg_2F1_renorm_e</strong>(a, b, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a,b,c,x) / \Gamma(c)$
2F1(a,b,c,x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17022
17023
17024
17025
17026
17027
17028
17029
17030
17031
17032
17033
17034
17035
17036
17037
17038</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17022</span>

static VALUE
sf_s_hyperg_2F1_renorm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_renorm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U-class_method">
  
    .<strong>hyperg_U</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function U(a,b,x).
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16552
16553
16554
16555
16556
16557
16558
16559
16560</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16552</span>

static VALUE
sf_s_hyperg_U(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_e-class_method">
  
    .<strong>hyperg_U_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function U(a,b,x).
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16600
16601
16602
16603
16604
16605
16606
16607
16608
16609
16610
16611
16612
16613
16614
16615
16616</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16600</span>

static VALUE
sf_s_hyperg_U_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_e10_e-class_method">
  
    .<strong>hyperg_U_e10_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the confluent hypergeometric function
U(a,b,x) using the gsl_sf_result_e10 type to return a
result with extended range.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16658
16659
16660
16661
16662
16663
16664
16665
16666
16667
16668
16669
16670
16671
16672
16673
16674</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16658</span>

static VALUE
sf_s_hyperg_U_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int-class_method">
  
    .<strong>hyperg_U_int</strong>(m, n, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16357
16358
16359
16360
16361
16362
16363
16364
16365
16366
16367
16368
16369
16370
16371
16372
16373
16374
16375
16376
16377
16378
16379
16380</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16357</span>

static VALUE
sf_s_hyperg_U_int(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int_e-class_method">
  
    .<strong>hyperg_U_int_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16425
16426
16427
16428
16429
16430
16431
16432
16433
16434
16435
16436
16437
16438
16439
16440
16441
16442
16443
16444
16445
16446
16447
16448</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16425</span>

static VALUE
sf_s_hyperg_U_int_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int_e10_e-class_method">
  
    .<strong>hyperg_U_int_e10_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the confluent hypergeometric function
U(m,n,x) for integer parameters m, n using the
gsl_sf_result_e10 type to return a result with extended range.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16493
16494
16495
16496
16497
16498
16499
16500
16501
16502
16503
16504
16505
16506
16507
16508
16509
16510
16511
16512
16513
16514
16515
16516</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16493</span>

static VALUE
sf_s_hyperg_U_int_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hypot-class_method">
  
    .<strong>hypot</strong>(x, y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypotenuse function $\sqrt+ y^2$
\sqrt@+ y^2@ avoiding overflow and underflow.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23514
23515
23516
23517
23518
23519
23520
23521
23522</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23514</span>

static VALUE
sf_s_hypot(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hypot, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hypot_e-class_method">
  
    .<strong>hypot_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypotenuse function $\sqrt+ y^2$
\sqrt@+ y^2@ avoiding overflow and underflow.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23560
23561
23562
23563
23564
23565
23566
23567
23568
23569
23570
23571
23572
23573
23574
23575
23576</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23560</span>

static VALUE
sf_s_hypot_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hypot_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hzeta-class_method">
  
    .<strong>hzeta</strong>(s, q)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Hurwitz zeta function \zeta(s,q) for
s &gt; 1, q &gt; 0.
Domain: s &gt; 1.0, q &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24711
24712
24713
24714
24715
24716
24717
24718
24719</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24711</span>

static VALUE
sf_s_hzeta(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hzeta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hzeta_e-class_method">
  
    .<strong>hzeta_e</strong>(s, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Hurwitz zeta function \zeta(s,q) for
s &gt; 1, q &gt; 0.
Domain: s &gt; 1.0, q &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24758
24759
24760
24761
24762
24763
24764
24765
24766
24767
24768
24769
24770
24771
24772
24773
24774</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24758</span>

static VALUE
sf_s_hzeta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hzeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_1-class_method">
  
    .<strong>laguerre_1</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17481
17482
17483
17484
17485
17486
17487
17488
17489</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17481</span>

static VALUE
sf_s_laguerre_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_1_e-class_method">
  
    .<strong>laguerre_1_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17614
17615
17616
17617
17618
17619
17620
17621
17622
17623
17624
17625
17626
17627
17628
17629
17630</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17614</span>

static VALUE
sf_s_laguerre_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_2-class_method">
  
    .<strong>laguerre_2</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17524
17525
17526
17527
17528
17529
17530
17531
17532</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17524</span>

static VALUE
sf_s_laguerre_2(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_2, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_2_e-class_method">
  
    .<strong>laguerre_2_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17669
17670
17671
17672
17673
17674
17675
17676
17677
17678
17679
17680
17681
17682
17683
17684
17685</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17669</span>

static VALUE
sf_s_laguerre_2_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_3-class_method">
  
    .<strong>laguerre_3</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17567
17568
17569
17570
17571
17572
17573
17574
17575</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17567</span>

static VALUE
sf_s_laguerre_3(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_3, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_3_e-class_method">
  
    .<strong>laguerre_3_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17724
17725
17726
17727
17728
17729
17730
17731
17732
17733
17734
17735
17736
17737
17738
17739
17740</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17724</span>

static VALUE
sf_s_laguerre_3_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_n-class_method">
  
    .<strong>laguerre_n</strong>(n, a, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &gt; -1,
$n \ge 0$
n &gt;= 0.</p>

<p>Domain: a &gt; -1.0, n &gt;= 0
Evaluate generalized Laguerre polynomials.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17784
17785
17786
17787
17788
17789
17790
17791
17792
17793
17794
17795
17796
17797
17798
17799
17800
17801
17802
17803</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17784</span>

static VALUE
sf_s_laguerre_n(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_n,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_n_e-class_method">
  
    .<strong>laguerre_n_e</strong>(n, a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &gt; -1,
$n \ge 0$
n &gt;= 0.</p>

<p>Domain: a &gt; -1.0, n &gt;= 0
Evaluate generalized Laguerre polynomials.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17851
17852
17853
17854
17855
17856
17857
17858
17859
17860
17861
17862
17863
17864
17865
17866
17867
17868
17869
17870</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17851</span>

static VALUE
sf_s_laguerre_n_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_W0-class_method">
  
    .<strong>lambert_W0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the principal branch of the Lambert W function, W_0(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17296
17297
17298
17299
17300
17301
17302
17303
17304</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17296</span>

static VALUE
sf_s_lambert_W0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_W0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_W0_e-class_method">
  
    .<strong>lambert_W0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the principal branch of the Lambert W function, W_0(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17338
17339
17340
17341
17342
17343
17344
17345
17346
17347
17348
17349
17350
17351
17352
17353
17354</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17338</span>

static VALUE
sf_s_lambert_W0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_W0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_Wm1-class_method">
  
    .<strong>lambert_Wm1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the secondary real-valued branch of the Lambert W function,
$W_-1(x)$
W_@-1@(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17386
17387
17388
17389
17390
17391
17392
17393
17394</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17386</span>

static VALUE
sf_s_lambert_Wm1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_Wm1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_Wm1_e-class_method">
  
    .<strong>lambert_Wm1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the secondary real-valued branch of the Lambert W function,
$W_-1(x)$
W_@-1@(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17430
17431
17432
17433
17434
17435
17436
17437
17438
17439
17440
17441
17442
17443
17444
17445
17446</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17430</span>

static VALUE
sf_s_lambert_Wm1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_Wm1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array-class_method">
  
    .<strong>legendre_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
polynomials for 0 \le l \le lmax and
0 \le m \le l for
$|x| \le 1$
|x| &lt;= 1.
The norm parameter specifies which normalization is used.
The normalized P_l^m(x) values are stored in result_array, whose
minimum size can be obtained from calling gsl_sf_legendre_array_n.
The array index of P_l^m(x) is obtained from calling
gsl_sf_legendre_array_index(l, m). To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18740
18741
18742
18743
18744
18745
18746
18747
18748
18749
18750
18751
18752
18753
18754
18755
18756
18757
18758
18759
18760
18761
18762
18763
18764</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18740</span>

static VALUE
sf_s_legendre_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_e-class_method">
  
    .<strong>legendre_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
polynomials for 0 \le l \le lmax and
0 \le m \le l for
$|x| \le 1$
|x| &lt;= 1.
The norm parameter specifies which normalization is used.
The normalized P_l^m(x) values are stored in result_array, whose
minimum size can be obtained from calling gsl_sf_legendre_array_n.
The array index of P_l^m(x) is obtained from calling
gsl_sf_legendre_array_index(l, m). To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18822
18823
18824
18825
18826
18827
18828
18829
18830
18831
18832
18833
18834
18835
18836
18837
18838
18839
18840
18841
18842
18843
18844
18845
18846
18847
18848</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18822</span>

static VALUE
sf_s_legendre_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_index-class_method">
  
    .<strong>legendre_array_index</strong>(l, m)  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index into result_array,
result_deriv_array, or result_deriv2_array corresponding
to P_l^m(x), P_l^‘m(x), or P_l^‘‘m(x). The
index is given by l(l+1)/2 + m.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19576
19577
19578
19579
19580
19581
19582
19583
19584
19585
19586
19587
19588
19589
19590
19591
19592</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19576</span>

static VALUE
sf_s_legendre_array_index(VALUE mod,VALUE v0,VALUE v1)
{
    
    size_t c0;
    size_t c1;
    size_t c2;
    
    c0 = NUM2SIZET(v0);
    c1 = NUM2SIZET(v1);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_legendre_array_index(c0,c1);
    
    return SIZET2NUM(c2);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_n-class_method">
  
    .<strong>legendre_array_n</strong>(lmax)  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the minimum array size for maximum degree lmax
needed for the array versions of the associated Legendre functions.
Size is calculated as the total number of P_l^m(x) functions,
plus extra space for precomputing multiplicative factors used in the
recurrence relations.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19547
19548
19549
19550
19551
19552
19553
19554
19555
19556
19557
19558
19559
19560
19561</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19547</span>

static VALUE
sf_s_legendre_array_n(VALUE mod,VALUE v0)
{
    
    size_t c0;
    size_t c1;
    
    c0 = NUM2SIZET(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c1 = gsl_sf_legendre_array_n(c0);
    
    return SIZET2NUM(c1);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_alt_array-class_method">
  
    .<strong>legendre_deriv2_alt_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(\cos\theta)/d\theta, and their second derivatives
d^2 P_l^m(\cos\theta)/d\theta^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19417
19418
19419
19420
19421
19422
19423
19424
19425
19426
19427
19428
19429
19430
19431
19432
19433
19434
19435
19436
19437
19438
19439
19440
19441</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19417</span>

static VALUE
sf_s_legendre_deriv2_alt_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_alt_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_alt_array_e-class_method">
  
    .<strong>legendre_deriv2_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(\cos\theta)/d\theta, and their second derivatives
d^2 P_l^m(\cos\theta)/d\theta^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19506
19507
19508
19509
19510
19511
19512
19513
19514
19515
19516
19517
19518
19519
19520
19521
19522
19523
19524
19525
19526
19527
19528
19529
19530
19531
19532</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19506</span>

static VALUE
sf_s_legendre_deriv2_alt_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_alt_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_array-class_method">
  
    .<strong>legendre_deriv2_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(x)/dx, and their second derivatives
d^2 P_l^m(x)/dx^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19241
19242
19243
19244
19245
19246
19247
19248
19249
19250
19251
19252
19253
19254
19255
19256
19257
19258
19259
19260
19261
19262
19263
19264
19265</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19241</span>

static VALUE
sf_s_legendre_deriv2_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_array_e-class_method">
  
    .<strong>legendre_deriv2_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(x)/dx, and their second derivatives
d^2 P_l^m(x)/dx^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19329
19330
19331
19332
19333
19334
19335
19336
19337
19338
19339
19340
19341
19342
19343
19344
19345
19346
19347
19348
19349
19350
19351
19352
19353
19354
19355</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19329</span>

static VALUE
sf_s_legendre_deriv2_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_alt_array-class_method">
  
    .<strong>legendre_deriv_alt_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The normalized P_l^m(x) values and their derivatives
dP_l^m(\cos\theta)/d\theta are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19071
19072
19073
19074
19075
19076
19077
19078
19079
19080
19081
19082
19083
19084
19085
19086
19087
19088
19089
19090
19091
19092
19093
19094
19095</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19071</span>

static VALUE
sf_s_legendre_deriv_alt_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_alt_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_alt_array_e-class_method">
  
    .<strong>legendre_deriv_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The normalized P_l^m(x) values and their derivatives
dP_l^m(\cos\theta)/d\theta are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19154
19155
19156
19157
19158
19159
19160
19161
19162
19163
19164
19165
19166
19167
19168
19169
19170
19171
19172
19173
19174
19175
19176
19177
19178
19179
19180</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19154</span>

static VALUE
sf_s_legendre_deriv_alt_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_alt_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_array-class_method">
  
    .<strong>legendre_deriv_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x) values and their derivatives
dP_l^m(x)/dx are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18905
18906
18907
18908
18909
18910
18911
18912
18913
18914
18915
18916
18917
18918
18919
18920
18921
18922
18923
18924
18925
18926
18927
18928
18929</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18905</span>

static VALUE
sf_s_legendre_deriv_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_array_e-class_method">
  
    .<strong>legendre_deriv_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x) values and their derivatives
dP_l^m(x)/dx are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18989
18990
18991
18992
18993
18994
18995
18996
18997
18998
18999
19000
19001
19002
19003
19004
19005
19006
19007
19008
19009
19010
19011
19012
19013
19014
19015</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18989</span>

static VALUE
sf_s_legendre_deriv_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d-class_method">
  
    .<strong>legendre_H3d</strong>(l, lambda, eta)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the l-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$
\eta &gt;= 0, $l \ge 0$
l &gt;= 0. In the flat limit this takes the form
$L^H3d_l(\lambda,\eta) = j_l(\lambda\eta)$
L^@H3d@_l(\lambda,\eta) = j_l(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20779
20780
20781
20782
20783
20784
20785
20786
20787
20788
20789
20790
20791
20792
20793
20794
20795
20796
20797
20798</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20779</span>

static VALUE
sf_s_legendre_H3d(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_0-class_method">
  
    .<strong>legendre_H3d_0</strong>(lambda, eta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script>
L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_0(\lambda,\eta) = j_0(\lambda\eta)$
L^@H3d@_0(\lambda,\eta) = j_0(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20557
20558
20559
20560
20561
20562
20563
20564
20565</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20557</span>

static VALUE
sf_s_legendre_H3d_0(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_0_e-class_method">
  
    .<strong>legendre_H3d_0_e</strong>(lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script>
L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_0(\lambda,\eta) = j_0(\lambda\eta)$
L^@H3d@_0(\lambda,\eta) = j_0(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20610
20611
20612
20613
20614
20615
20616
20617
20618
20619
20620
20621
20622
20623
20624
20625
20626</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20610</span>

static VALUE
sf_s_legendre_H3d_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_1-class_method">
  
    .<strong>legendre_H3d_1</strong>(lambda, eta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script>
L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_1(\lambda,\eta) = j_1(\lambda\eta)$
L^@H3d@_1(\lambda,\eta) = j_1(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20667
20668
20669
20670
20671
20672
20673
20674
20675</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20667</span>

static VALUE
sf_s_legendre_H3d_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_1_e-class_method">
  
    .<strong>legendre_H3d_1_e</strong>(lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script>
L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_1(\lambda,\eta) = j_1(\lambda\eta)$
L^@H3d@_1(\lambda,\eta) = j_1(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20720
20721
20722
20723
20724
20725
20726
20727
20728
20729
20730
20731
20732
20733
20734
20735
20736</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20720</span>

static VALUE
sf_s_legendre_H3d_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_array-class_method">
  
    .<strong>legendre_H3d_array</strong>(lmax, lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an array of radial eigenfunctions
$L^H3d_l( \lambda, \eta)$
L^@H3d@_l(\lambda, \eta)
for $0 \le l \le lmax$
0 &lt;= l &lt;= lmax.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20910
20911
20912
20913
20914
20915
20916
20917
20918
20919
20920
20921
20922
20923
20924
20925
20926
20927
20928
20929</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20910</span>

static VALUE
sf_s_legendre_H3d_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_e-class_method">
  
    .<strong>legendre_H3d_e</strong>(l, lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the l-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$
\eta &gt;= 0, $l \ge 0$
l &gt;= 0. In the flat limit this takes the form
$L^H3d_l(\lambda,\eta) = j_l(\lambda\eta)$
L^@H3d@_l(\lambda,\eta) = j_l(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20845
20846
20847
20848
20849
20850
20851
20852
20853
20854
20855
20856
20857
20858
20859
20860
20861
20862
20863
20864</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20845</span>

static VALUE
sf_s_legendre_H3d_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P1-class_method">
  
    .<strong>legendre_P1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17903
17904
17905
17906
17907
17908
17909
17910
17911</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17903</span>

static VALUE
sf_s_legendre_P1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P1_e-class_method">
  
    .<strong>legendre_P1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18030
18031
18032
18033
18034
18035
18036
18037
18038
18039
18040
18041
18042
18043
18044
18045
18046</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18030</span>

static VALUE
sf_s_legendre_P1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P2-class_method">
  
    .<strong>legendre_P2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17944
17945
17946
17947
17948
17949
17950
17951
17952</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17944</span>

static VALUE
sf_s_legendre_P2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P2_e-class_method">
  
    .<strong>legendre_P2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18083
18084
18085
18086
18087
18088
18089
18090
18091
18092
18093
18094
18095
18096
18097
18098
18099</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18083</span>

static VALUE
sf_s_legendre_P2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P3-class_method">
  
    .<strong>legendre_P3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17985
17986
17987
17988
17989
17990
17991
17992
17993</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17985</span>

static VALUE
sf_s_legendre_P3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P3_e-class_method">
  
    .<strong>legendre_P3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18136
18137
18138
18139
18140
18141
18142
18143
18144
18145
18146
18147
18148
18149
18150
18151
18152</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18136</span>

static VALUE
sf_s_legendre_P3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl-class_method">
  
    .<strong>legendre_Pl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomial $P_l(x)$
P_l(x) for a specific value of l,
x subject to $l \ge 0$
l &gt;= 0,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18190
18191
18192
18193
18194
18195
18196
18197
18198
18199
18200
18201</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18190</span>

static VALUE
sf_s_legendre_Pl(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_array-class_method">
  
    .<strong>legendre_Pl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute arrays of Legendre polynomials
P_l(x) and derivatives dP_l(x)/dx,
for l = 0, \dots, lmax,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18308
18309
18310
18311
18312
18313
18314
18315
18316
18317
18318
18319
18320
18321
18322
18323
18324
18325
18326
18327</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18308</span>

static VALUE
sf_s_legendre_Pl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_deriv_array-class_method">
  
    .<strong>legendre_Pl_deriv_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute arrays of Legendre polynomials
P_l(x) and derivatives dP_l(x)/dx,
for l = 0, \dots, lmax,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18374
18375
18376
18377
18378
18379
18380
18381
18382
18383
18384
18385
18386
18387
18388
18389
18390
18391
18392
18393</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18374</span>

static VALUE
sf_s_legendre_Pl_deriv_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_deriv_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_e-class_method">
  
    .<strong>legendre_Pl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomial $P_l(x)$
P_l(x) for a specific value of l,
x subject to $l \ge 0$
l &gt;= 0,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18245
18246
18247
18248
18249
18250
18251
18252
18253
18254
18255
18256
18257
18258
18259
18260
18261
18262
18263
18264</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18245</span>

static VALUE
sf_s_legendre_Pl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Plm-class_method">
  
    .<strong>legendre_Plm</strong>(l, m, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the associated Legendre polynomial
P_l^m(x) for $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19636
19637
19638
19639
19640
19641
19642
19643
19644
19645
19646
19647
19648
19649
19650
19651
19652
19653
19654
19655
19656
19657
19658
19659</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19636</span>

static VALUE
sf_s_legendre_Plm(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Plm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Plm_e-class_method">
  
    .<strong>legendre_Plm_e</strong>(l, m, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the associated Legendre polynomial
P_l^m(x) for $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19707
19708
19709
19710
19711
19712
19713
19714
19715
19716
19717
19718
19719
19720
19721
19722
19723
19724
19725
19726
19727
19728
19729
19730</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19707</span>

static VALUE
sf_s_legendre_Plm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Plm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q0-class_method">
  
    .<strong>legendre_Q0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_0(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18425
18426
18427
18428
18429
18430
18431
18432
18433</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18425</span>

static VALUE
sf_s_legendre_Q0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q0_e-class_method">
  
    .<strong>legendre_Q0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_0(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18469
18470
18471
18472
18473
18474
18475
18476
18477
18478
18479
18480
18481
18482
18483
18484
18485</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18469</span>

static VALUE
sf_s_legendre_Q0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q1-class_method">
  
    .<strong>legendre_Q1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_1(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18517
18518
18519
18520
18521
18522
18523
18524
18525</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18517</span>

static VALUE
sf_s_legendre_Q1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q1_e-class_method">
  
    .<strong>legendre_Q1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_1(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18561
18562
18563
18564
18565
18566
18567
18568
18569
18570
18571
18572
18573
18574
18575
18576
18577</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18561</span>

static VALUE
sf_s_legendre_Q1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Ql-class_method">
  
    .<strong>legendre_Ql</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_l(x) for x &gt;
-1, $x \ne 1$
x != 1 and $l \ge 0$
l &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18613
18614
18615
18616
18617
18618
18619
18620
18621
18622
18623
18624</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18613</span>

static VALUE
sf_s_legendre_Ql(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Ql, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Ql_e-class_method">
  
    .<strong>legendre_Ql_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_l(x) for x &gt;
-1, $x \ne 1$
x != 1 and $l \ge 0$
l &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18666
18667
18668
18669
18670
18671
18672
18673
18674
18675
18676
18677
18678
18679
18680
18681
18682
18683
18684
18685</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18666</span>

static VALUE
sf_s_legendre_Ql_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Ql_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_sphPlm-class_method">
  
    .<strong>legendre_sphPlm</strong>(l, m, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized associated Legendre polynomial
$\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$
\sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable
for use in spherical harmonics.  The parameters must satisfy $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19777
19778
19779
19780
19781
19782
19783
19784
19785
19786
19787
19788
19789
19790
19791
19792
19793
19794
19795
19796
19797
19798
19799
19800</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19777</span>

static VALUE
sf_s_legendre_sphPlm(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_sphPlm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_sphPlm_e-class_method">
  
    .<strong>legendre_sphPlm_e</strong>(l, m, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized associated Legendre polynomial
$\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$
\sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable
for use in spherical harmonics.  The parameters must satisfy $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19851
19852
19853
19854
19855
19856
19857
19858
19859
19860
19861
19862
19863
19864
19865
19866
19867
19868
19869
19870
19871
19872
19873
19874</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19851</span>

static VALUE
sf_s_legendre_sphPlm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_sphPlm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnbeta-class_method">
  
    .<strong>lnbeta</strong>(a, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Beta Function, \log(B(a,b))
subject to a and b not
being negative integers.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15302
15303
15304
15305
15306
15307
15308
15309
15310</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15302</span>

static VALUE
sf_s_lnbeta(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnbeta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnbeta_e-class_method">
  
    .<strong>lnbeta_e</strong>(a, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Beta Function, \log(B(a,b))
subject to a and b not
being negative integers.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15349
15350
15351
15352
15353
15354
15355
15356
15357
15358
15359
15360
15361
15362
15363
15364
15365</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15349</span>

static VALUE
sf_s_lnbeta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnbeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnchoose-class_method">
  
    .<strong>lnchoose</strong>(n, m)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of n choose m.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14325
14326
14327
14328
14329
14330
14331
14332
14333
14334
14335
14336
14337
14338
14339
14340
14341</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14325</span>

static VALUE
sf_s_lnchoose(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnchoose,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnchoose_e-class_method">
  
    .<strong>lnchoose_e</strong>(n, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of n choose m.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14379
14380
14381
14382
14383
14384
14385
14386
14387
14388
14389
14390
14391
14392
14393
14394
14395</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14379</span>

static VALUE
sf_s_lnchoose_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnchoose_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lncosh-class_method">
  
    .<strong>lncosh</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\cosh(x)) for any x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23958
23959
23960
23961
23962
23963
23964
23965
23966</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23958</span>

static VALUE
sf_s_lncosh(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lncosh, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lncosh_e-class_method">
  
    .<strong>lncosh_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\cosh(x)) for any x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24000
24001
24002
24003
24004
24005
24006
24007
24008
24009
24010
24011
24012
24013
24014
24015
24016</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24000</span>

static VALUE
sf_s_lncosh_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lncosh_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lndoublefact-class_method">
  
    .<strong>lndoublefact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the double factorial of n,
\log(n!!).
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14128
14129
14130
14131
14132
14133
14134
14135
14136</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14128</span>

static VALUE
sf_s_lndoublefact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lndoublefact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lndoublefact_e-class_method">
  
    .<strong>lndoublefact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the double factorial of n,
\log(n!!).
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14171
14172
14173
14174
14175
14176
14177
14178
14179
14180
14181
14182
14183
14184
14185
14186
14187</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14171</span>

static VALUE
sf_s_lndoublefact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lndoublefact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnfact-class_method">
  
    .<strong>lnfact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the factorial of n,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170,
but defers for larger n.
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14035
14036
14037
14038
14039
14040
14041
14042
14043</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14035</span>

static VALUE
sf_s_lnfact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnfact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnfact_e-class_method">
  
    .<strong>lnfact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the factorial of n,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170,
but defers for larger n.
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14080
14081
14082
14083
14084
14085
14086
14087
14088
14089
14090
14091
14092
14093
14094
14095
14096</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14080</span>

static VALUE
sf_s_lnfact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnfact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma-class_method">
  
    .<strong>lngamma</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not being a negative
integer or zero.  For x&lt;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13438
13439
13440
13441
13442
13443
13444
13445
13446</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13438</span>

static VALUE
sf_s_lngamma(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_complex_e-class_method">
  
    .<strong>lngamma_complex_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes \log(\Gamma(z)) for complex z=z_r+i
z_i and z not a negative integer or zero, using the complex Lanczos
method.  The returned parameters are lnr = \log|\Gamma(z)| and
arg = \arg(\Gamma(z)) in (-\pi,\pi].  Note that the phase
part (arg) is not well-determined when |z| is very large,
due to inevitable roundoff in restricting to (-\pi,\pi].  This
will result in a GSL_ELOSS error when it occurs.  The absolute
value part (lnr), however, never suffers from loss of precision.
exceptions: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lnr.val, lnr.err, arg.val, arg.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13793
13794
13795
13796
13797
13798
13799
13800
13801
13802
13803
13804
13805
13806
13807
13808
13809</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13793</span>

static VALUE
sf_s_lngamma_complex_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_complex_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_e-class_method">
  
    .<strong>lngamma_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not being a negative
integer or zero.  For x&lt;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13484
13485
13486
13487
13488
13489
13490
13491
13492
13493
13494
13495
13496
13497
13498
13499
13500</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13484</span>

static VALUE
sf_s_lngamma_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_sgn_e-class_method">
  
    .<strong>lngamma_sgn_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the sign of the gamma function and the logarithm of
its magnitude, subject to x not being a negative integer or zero.  The
function is computed using the real Lanczos method.  The value of the
gamma function and its error can be reconstructed using the relation
\Gamma(x) = sgn * \exp(result_lg), taking into account the two
components of result_lg.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_lg.val, result_lg.err, sgn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13542
13543
13544
13545
13546
13547
13548
13549
13550
13551
13552
13553
13554
13555
13556
13557
13558</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13542</span>

static VALUE
sf_s_lngamma_sgn_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_sgn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch-class_method">
  
    .<strong>lnpoch</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14639
14640
14641
14642
14643
14644
14645
14646
14647</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14639</span>

static VALUE
sf_s_lnpoch(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch_e-class_method">
  
    .<strong>lnpoch_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14685
14686
14687
14688
14689
14690
14691
14692
14693
14694
14695
14696
14697
14698
14699
14700
14701</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14685</span>

static VALUE
sf_s_lnpoch_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch_sgn_e-class_method">
  
    .<strong>lnpoch_sgn_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sign of the Pochhammer symbol and the
logarithm of its magnitude.  The computed parameters are result =
\log(|(a)_x|) with a corresponding error term,
and sgn = \sgn((a)_x) where (a)_x =
\Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, sgn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14745
14746
14747
14748
14749
14750
14751
14752
14753
14754
14755
14756
14757
14758
14759
14760
14761</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14745</span>

static VALUE
sf_s_lnpoch_sgn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch_sgn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnsinh-class_method">
  
    .<strong>lnsinh</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\sinh(x)) for x &gt; 0.
Domain: x &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23869
23870
23871
23872
23873
23874
23875
23876
23877</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23869</span>

static VALUE
sf_s_lnsinh(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnsinh, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnsinh_e-class_method">
  
    .<strong>lnsinh_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\sinh(x)) for x &gt; 0.
Domain: x &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23912
23913
23914
23915
23916
23917
23918
23919
23920
23921
23922
23923
23924
23925
23926
23927
23928</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23912</span>

static VALUE
sf_s_lnsinh_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnsinh_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log-class_method">
  
    .<strong>log</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of x, \log(x), for
x &gt; 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20960
20961
20962
20963
20964
20965
20966
20967
20968</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20960</span>

static VALUE
sf_s_log(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx-class_method">
  
    .<strong>log_1plusx</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21200
21201
21202
21203
21204
21205
21206
21207
21208</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21200</span>

static VALUE
sf_s_log_1plusx(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_e-class_method">
  
    .<strong>log_1plusx_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21244
21245
21246
21247
21248
21249
21250
21251
21252
21253
21254
21255
21256
21257
21258
21259
21260</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21244</span>

static VALUE
sf_s_log_1plusx_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_mx-class_method">
  
    .<strong>log_1plusx_mx</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) - x for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21292
21293
21294
21295
21296
21297
21298
21299
21300</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21292</span>

static VALUE
sf_s_log_1plusx_mx(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_mx, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_mx_e-class_method">
  
    .<strong>log_1plusx_mx_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) - x for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21336
21337
21338
21339
21340
21341
21342
21343
21344
21345
21346
21347
21348
21349
21350
21351
21352</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21336</span>

static VALUE
sf_s_log_1plusx_mx_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_mx_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_abs-class_method">
  
    .<strong>log_abs</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the magnitude of x,
\log(|x|), for x \ne 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21050
21051
21052
21053
21054
21055
21056
21057
21058</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21050</span>

static VALUE
sf_s_log_abs(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_abs, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_abs_e-class_method">
  
    .<strong>log_abs_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the magnitude of x,
\log(|x|), for x \ne 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21093
21094
21095
21096
21097
21098
21099
21100
21101
21102
21103
21104
21105
21106
21107
21108
21109</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21093</span>

static VALUE
sf_s_log_abs_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_abs_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_e-class_method">
  
    .<strong>log_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of x, \log(x), for
x &gt; 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21003
21004
21005
21006
21007
21008
21009
21010
21011
21012
21013
21014
21015
21016
21017
21018
21019</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21003</span>

static VALUE
sf_s_log_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_erfc-class_method">
  
    .<strong>log_erfc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10259
10260
10261
10262
10263
10264
10265
10266
10267</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10259</span>

static VALUE
sf_s_log_erfc(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_erfc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_erfc_e-class_method">
  
    .<strong>log_erfc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10302
10303
10304
10305
10306
10307
10308
10309
10310
10311
10312
10313
10314
10315
10316
10317
10318</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10302</span>

static VALUE
sf_s_log_erfc_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_erfc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_a-class_method">
  
    .<strong>mathieu_a</strong>(n, q)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21387
21388
21389
21390
21391
21392
21393
21394
21395
21396
21397
21398</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21387</span>

static VALUE
sf_s_mathieu_a(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_Int_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_a, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_a_e-class_method">
  
    .<strong>mathieu_a_e</strong>(n, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21438
21439
21440
21441
21442
21443
21444
21445
21446
21447
21448
21449
21450
21451
21452
21453
21454
21455
21456
21457</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21438</span>

static VALUE
sf_s_mathieu_a_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_a_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_b-class_method">
  
    .<strong>mathieu_b</strong>(n, q)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21492
21493
21494
21495
21496
21497
21498
21499
21500
21501
21502
21503</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21492</span>

static VALUE
sf_s_mathieu_b(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_Int_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_b, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_b_e-class_method">
  
    .<strong>mathieu_b_e</strong>(n, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21543
21544
21545
21546
21547
21548
21549
21550
21551
21552
21553
21554
21555
21556
21557
21558
21559
21560
21561
21562</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21543</span>

static VALUE
sf_s_mathieu_b_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_b_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_ce-class_method">
  
    .<strong>mathieu_ce</strong>(n, q, x)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21599
21600
21601
21602
21603
21604
21605
21606
21607
21608
21609
21610</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21599</span>

static VALUE
sf_s_mathieu_ce(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 37 &quot;../gen/tmpl/m_Int_f_int_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_ce, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[1];

    opts[0] = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, opts, 2, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_ce_e-class_method">
  
    .<strong>mathieu_ce_e</strong>(n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21652
21653
21654
21655
21656
21657
21658
21659
21660
21661
21662
21663
21664
21665
21666
21667
21668
21669
21670
21671</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21652</span>

static VALUE
sf_s_mathieu_ce_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_ce_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Mc-class_method">
  
    .<strong>mathieu_Mc</strong>(j, n, q, x)  &#x21d2; <tt>Numo::Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21838
21839
21840
21841
21842
21843
21844
21845
21846
21847
21848
21849
21850
21851
21852
21853
21854
21855
21856
21857
21858
21859
21860
21861</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21838</span>

static VALUE
sf_s_mathieu_Mc(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Mc,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Mc_e-class_method">
  
    .<strong>mathieu_Mc_e</strong>(j, n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21923
21924
21925
21926
21927
21928
21929
21930
21931
21932
21933
21934
21935
21936
21937
21938
21939
21940
21941
21942
21943
21944
21945
21946</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21923</span>

static VALUE
sf_s_mathieu_Mc_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Mc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Ms-class_method">
  
    .<strong>mathieu_Ms</strong>(j, n, q, x)  &#x21d2; <tt>Numo::Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22004
22005
22006
22007
22008
22009
22010
22011
22012
22013
22014
22015
22016
22017
22018
22019
22020
22021
22022
22023
22024
22025
22026
22027</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22004</span>

static VALUE
sf_s_mathieu_Ms(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Ms,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Ms_e-class_method">
  
    .<strong>mathieu_Ms_e</strong>(j, n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22089
22090
22091
22092
22093
22094
22095
22096
22097
22098
22099
22100
22101
22102
22103
22104
22105
22106
22107
22108
22109
22110
22111
22112</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22089</span>

static VALUE
sf_s_mathieu_Ms_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Ms_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_se-class_method">
  
    .<strong>mathieu_se</strong>(n, q, x)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21708
21709
21710
21711
21712
21713
21714
21715
21716
21717
21718
21719</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21708</span>

static VALUE
sf_s_mathieu_se(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 37 &quot;../gen/tmpl/m_Int_f_int_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_se, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[1];

    opts[0] = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, opts, 2, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_se_e-class_method">
  
    .<strong>mathieu_se_e</strong>(n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21761
21762
21763
21764
21765
21766
21767
21768
21769
21770
21771
21772
21773
21774
21775
21776
21777
21778
21779
21780</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21761</span>

static VALUE
sf_s_mathieu_se_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_se_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="multiply_e-class_method">
  
    .<strong>multiply_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function multiplies x and y storing the product and its
associated error in result.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8376
8377
8378
8379
8380
8381
8382
8383
8384
8385
8386
8387
8388
8389
8390
8391
8392</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8376</span>

static VALUE
sf_s_multiply_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_multiply_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="multiply_err_e-class_method">
  
    .<strong>multiply_err_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function multiplies x and y with associated absolute
errors dx and dy.  The product
$xy \pm xy \sqrt+(dy/y)^2$
xy +/- xy \sqrt((dx/x)^2 +(dy/y)^2)
is stored in result.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8439
8440
8441
8442
8443
8444
8445
8446
8447
8448
8449
8450
8451
8452
8453
8454
8455</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8439</span>

static VALUE
sf_s_multiply_err_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_multiply_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="poch-class_method">
  
    .<strong>poch</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a +
x)/\Gamma(a).  The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).  When a and a+x
are negative integers or zero, the limiting value of the ratio is returned.
exceptions:  GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14541
14542
14543
14544
14545
14546
14547
14548
14549</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14541</span>

static VALUE
sf_s_poch(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_poch, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="poch_e-class_method">
  
    .<strong>poch_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a +
x)/\Gamma(a).  The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).  When a and a+x
are negative integers or zero, the limiting value of the ratio is returned.
exceptions:  GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14589
14590
14591
14592
14593
14594
14595
14596
14597
14598
14599
14600
14601
14602
14603
14604
14605</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14589</span>

static VALUE
sf_s_poch_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_poch_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pochrel-class_method">
  
    .<strong>pochrel</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14795
14796
14797
14798
14799
14800
14801
14802
14803</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14795</span>

static VALUE
sf_s_pochrel(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_pochrel, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pochrel_e-class_method">
  
    .<strong>pochrel_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14841
14842
14843
14844
14845
14846
14847
14848
14849
14850
14851
14852
14853
14854
14855
14856
14857</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14841</span>

static VALUE
sf_s_pochrel_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_pochrel_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="polar_to_rect-class_method">
  
    .<strong>polar_to_rect</strong>(r, theta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function converts the polar coordinates (r,theta) to
rectilinear coordinates (x,y), x = r\cos(\theta),
y = r\sin(\theta).
Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [x.val, x.err, y.val, y.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24058
24059
24060
24061
24062
24063
24064
24065
24066
24067
24068
24069
24070
24071
24072
24073
24074</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24058</span>

static VALUE
sf_s_polar_to_rect(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_polar_to_rect,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pow_int-class_method">
  
    .<strong>pow_int</strong>(x, n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the power x^n for integer n.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22149
22150
22151
22152
22153
22154
22155
22156
22157</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22149</span>

static VALUE
sf_s_pow_int(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_DFloat_f_DFloat_Int.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_pow_int, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pow_int_e-class_method">
  
    .<strong>pow_int_e</strong>(x, n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the power x^n for integer n.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22199
22200
22201
22202
22203
22204
22205
22206
22207
22208
22209
22210
22211
22212
22213
22214
22215
22216
22217
22218</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22199</span>

static VALUE
sf_s_pow_int_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_pow_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi-class_method">
  
    .<strong>psi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(x) for general
x, x \ne 0.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22328
22329
22330
22331
22332
22333
22334
22335
22336</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22328</span>

static VALUE
sf_s_psi(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1-class_method">
  
    .<strong>psi_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(x) for
general x.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22590
22591
22592
22593
22594
22595
22596
22597
22598</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22590</span>

static VALUE
sf_s_psi_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_e-class_method">
  
    .<strong>psi_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(x) for
general x.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22634
22635
22636
22637
22638
22639
22640
22641
22642
22643
22644
22645
22646
22647
22648
22649
22650</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22634</span>

static VALUE
sf_s_psi_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_int-class_method">
  
    .<strong>psi_1_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(n) for
positive integer n.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22513
22514
22515
22516
22517
22518
22519
22520
22521</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22513</span>

static VALUE
sf_s_psi_1_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_int_e-class_method">
  
    .<strong>psi_1_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(n) for
positive integer n.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22535
22536
22537
22538
22539
22540
22541
22542
22543
22544
22545
22546
22547
22548
22549
22550
22551
22552
22553
22554
22555
22556
22557
22558</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22535</span>

static VALUE
sf_s_psi_1_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_psi_1_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1piy-class_method">
  
    .<strong>psi_1piy</strong>(y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
exceptions: none
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22420
22421
22422
22423
22424
22425
22426
22427
22428</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22420</span>

static VALUE
sf_s_psi_1piy(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1piy, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1piy_e-class_method">
  
    .<strong>psi_1piy_e</strong>(y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
exceptions: none
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22464
22465
22466
22467
22468
22469
22470
22471
22472
22473
22474
22475
22476
22477
22478
22479
22480</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22464</span>

static VALUE
sf_s_psi_1piy_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1piy_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_e-class_method">
  
    .<strong>psi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(x) for general
x, x \ne 0.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22372
22373
22374
22375
22376
22377
22378
22379
22380
22381
22382
22383
22384
22385
22386
22387
22388</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22372</span>

static VALUE
sf_s_psi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_int-class_method">
  
    .<strong>psi_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(n) for positive
integer n.  The digamma function is also called the Psi function.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22251
22252
22253
22254
22255
22256
22257
22258
22259</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22251</span>

static VALUE
sf_s_psi_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_int_e-class_method">
  
    .<strong>psi_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(n) for positive
integer n.  The digamma function is also called the Psi function.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22273
22274
22275
22276
22277
22278
22279
22280
22281
22282
22283
22284
22285
22286
22287
22288
22289
22290
22291
22292
22293
22294
22295
22296</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22273</span>

static VALUE
sf_s_psi_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_psi_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_n-class_method">
  
    .<strong>psi_n</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the polygamma function $\psi^(n)(x)$
\psi^@(n)@(x) for
$n \ge 0$
n &gt;= 0, x &gt; 0.
Domain: n &gt;= 0, x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22687
22688
22689
22690
22691
22692
22693
22694
22695
22696
22697
22698</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22687</span>

static VALUE
sf_s_psi_n(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_n, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_n_e-class_method">
  
    .<strong>psi_n_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the polygamma function $\psi^(n)(x)$
\psi^@(n)@(x) for
$n \ge 0$
n &gt;= 0, x &gt; 0.
Domain: n &gt;= 0, x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22741
22742
22743
22744
22745
22746
22747
22748
22749
22750
22751
22752
22753
22754
22755
22756
22757
22758
22759
22760</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22741</span>

static VALUE
sf_s_psi_n_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="rect_to_polar-class_method">
  
    .<strong>rect_to_polar</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function converts the rectilinear coordinates (x,y) to
polar coordinates (r,theta), such that x =
r\cos(\theta), y = r\sin(\theta).  The argument theta
lies in the range [-\pi, \pi].
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [r.val, r.err, theta.val, theta.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24117
24118
24119
24120
24121
24122
24123
24124
24125
24126
24127
24128
24129
24130
24131
24132
24133</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24117</span>

static VALUE
sf_s_rect_to_polar(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_rect_to_polar,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Shi-class_method">
  
    .<strong>Shi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$
Shi(x) = \int_0^x dt \sinh(t)/t.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11939
11940
11941
11942
11943
11944
11945
11946
11947</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11939</span>

static VALUE
sf_s_Shi(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Shi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Shi_e-class_method">
  
    .<strong>Shi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$
Shi(x) = \int_0^x dt \sinh(t)/t.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11982
11983
11984
11985
11986
11987
11988
11989
11990
11991
11992
11993
11994
11995
11996
11997
11998</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11982</span>

static VALUE
sf_s_Shi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Shi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Si-class_method">
  
    .<strong>Si</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Si</a></span>(x) = \int_0^x dt \sin(t)/t$
Si(x) = \int_0^x dt \sin(t)/t.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12215
12216
12217
12218
12219
12220
12221
12222
12223</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12215</span>

static VALUE
sf_s_Si(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Si, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Si_e-class_method">
  
    .<strong>Si_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Si</a></span>(x) = \int_0^x dt \sin(t)/t$
Si(x) = \int_0^x dt \sin(t)/t.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12258
12259
12260
12261
12262
12263
12264
12265
12266
12267
12268
12269
12270
12271
12272
12273
12274</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12258</span>

static VALUE
sf_s_Si_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Si_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin-class_method">
  
    .<strong>sin</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sine function \sin(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23334
23335
23336
23337
23338
23339
23340
23341
23342</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23334</span>

static VALUE
sf_s_sin(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_sin, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin_e-class_method">
  
    .<strong>sin_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sine function \sin(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23376
23377
23378
23379
23380
23381
23382
23383
23384
23385
23386
23387
23388
23389
23390
23391
23392</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23376</span>

static VALUE
sf_s_sin_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin_err_e-class_method">
  
    .<strong>sin_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the sine of an angle x with an associated
absolute error dx,
$\sin(x \pm dx)$
\sin(x \pm dx).  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24260
24261
24262
24263
24264
24265
24266
24267
24268
24269
24270
24271
24272
24273
24274
24275
24276</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24260</span>

static VALUE
sf_s_sin_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sin_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sinc-class_method">
  
    .<strong>sinc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23607
23608
23609
23610
23611
23612
23613
23614
23615</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23607</span>

static VALUE
sf_s_sinc(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_sinc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sinc_e-class_method">
  
    .<strong>sinc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23650
23651
23652
23653
23654
23655
23656
23657
23658
23659
23660
23661
23662
23663
23664
23665
23666</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23650</span>

static VALUE
sf_s_sinc_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sinc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_1-class_method">
  
    .<strong>synchrotron_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first synchrotron function
$x \int_x^\infty dt K_5/3(t)$
x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22794
22795
22796
22797
22798
22799
22800
22801
22802</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22794</span>

static VALUE
sf_s_synchrotron_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_1_e-class_method">
  
    .<strong>synchrotron_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first synchrotron function
$x \int_x^\infty dt K_5/3(t)$
x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22840
22841
22842
22843
22844
22845
22846
22847
22848
22849
22850
22851
22852
22853
22854
22855
22856</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22840</span>

static VALUE
sf_s_synchrotron_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_2-class_method">
  
    .<strong>synchrotron_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second synchrotron function
$x K_2/3(x)$
x K_@2/3@(x) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22890
22891
22892
22893
22894
22895
22896
22897
22898</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22890</span>

static VALUE
sf_s_synchrotron_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_2_e-class_method">
  
    .<strong>synchrotron_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second synchrotron function
$x K_2/3(x)$
x K_@2/3@(x) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22936
22937
22938
22939
22940
22941
22942
22943
22944
22945
22946
22947
22948
22949
22950
22951
22952</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22936</span>

static VALUE
sf_s_synchrotron_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="taylorcoeff-class_method">
  
    .<strong>taylorcoeff</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Taylor coefficient x^n / n! for
$x \ge 0$
x &gt;= 0,
$n \ge 0$
n &gt;= 0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14432
14433
14434
14435
14436
14437
14438
14439
14440
14441
14442
14443</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14432</span>

static VALUE
sf_s_taylorcoeff(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_taylorcoeff, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="taylorcoeff_e-class_method">
  
    .<strong>taylorcoeff_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Taylor coefficient x^n / n! for
$x \ge 0$
x &gt;= 0,
$n \ge 0$
n &gt;= 0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14486
14487
14488
14489
14490
14491
14492
14493
14494
14495
14496
14497
14498
14499
14500
14501
14502
14503
14504
14505</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14486</span>

static VALUE
sf_s_taylorcoeff_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_taylorcoeff_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_2-class_method">
  
    .<strong>transport_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(2,x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22982
22983
22984
22985
22986
22987
22988
22989
22990</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22982</span>

static VALUE
sf_s_transport_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_2_e-class_method">
  
    .<strong>transport_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(2,x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23024
23025
23026
23027
23028
23029
23030
23031
23032
23033
23034
23035
23036
23037
23038
23039
23040</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23024</span>

static VALUE
sf_s_transport_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_3-class_method">
  
    .<strong>transport_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(3,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23070
23071
23072
23073
23074
23075
23076
23077
23078</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23070</span>

static VALUE
sf_s_transport_3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_3_e-class_method">
  
    .<strong>transport_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(3,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23112
23113
23114
23115
23116
23117
23118
23119
23120
23121
23122
23123
23124
23125
23126
23127
23128</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23112</span>

static VALUE
sf_s_transport_3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_4-class_method">
  
    .<strong>transport_4</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(4,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23158
23159
23160
23161
23162
23163
23164
23165
23166</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23158</span>

static VALUE
sf_s_transport_4(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_4, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_4_e-class_method">
  
    .<strong>transport_4_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(4,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23200
23201
23202
23203
23204
23205
23206
23207
23208
23209
23210
23211
23212
23213
23214
23215
23216</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23200</span>

static VALUE
sf_s_transport_4_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_4_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_5-class_method">
  
    .<strong>transport_5</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(5,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23246
23247
23248
23249
23250
23251
23252
23253
23254</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23246</span>

static VALUE
sf_s_transport_5(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_5, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_5_e-class_method">
  
    .<strong>transport_5_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(5,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23288
23289
23290
23291
23292
23293
23294
23295
23296
23297
23298
23299
23300
23301
23302
23303
23304</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23288</span>

static VALUE
sf_s_transport_5_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_5_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta-class_method">
  
    .<strong>zeta</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(s)
for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24445
24446
24447
24448
24449
24450
24451
24452
24453</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24445</span>

static VALUE
sf_s_zeta(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zeta, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_e-class_method">
  
    .<strong>zeta_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(s)
for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24490
24491
24492
24493
24494
24495
24496
24497
24498
24499
24500
24501
24502
24503
24504
24505
24506</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24490</span>

static VALUE
sf_s_zeta_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_zeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_int-class_method">
  
    .<strong>zeta_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(n)
for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24366
24367
24368
24369
24370
24371
24372
24373
24374</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24366</span>

static VALUE
sf_s_zeta_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zeta_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_int_e-class_method">
  
    .<strong>zeta_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(n)
for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24389
24390
24391
24392
24393
24394
24395
24396
24397
24398
24399
24400
24401
24402
24403
24404
24405
24406
24407
24408
24409
24410
24411
24412</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24389</span>

static VALUE
sf_s_zeta_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_zeta_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1-class_method">
  
    .<strong>zetam1</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(s) - 1 for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24616
24617
24618
24619
24620
24621
24622
24623
24624</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24616</span>

static VALUE
sf_s_zetam1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_e-class_method">
  
    .<strong>zetam1_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(s) - 1 for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24660
24661
24662
24663
24664
24665
24666
24667
24668
24669
24670
24671
24672
24673
24674
24675
24676</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24660</span>

static VALUE
sf_s_zetam1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_int-class_method">
  
    .<strong>zetam1_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(n) - 1 for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24539
24540
24541
24542
24543
24544
24545
24546
24547</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24539</span>

static VALUE
sf_s_zetam1_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_int_e-class_method">
  
    .<strong>zetam1_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(n) - 1 for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24561
24562
24563
24564
24565
24566
24567
24568
24569
24570
24571
24572
24573
24574
24575
24576
24577
24578
24579
24580
24581
24582
24583
24584</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24561</span>

static VALUE
sf_s_zetam1_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_zetam1_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Sun Mar 19 00:56:56 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.8 (ruby-2.4.0).
</div>

    </div>
  </body>
</html>