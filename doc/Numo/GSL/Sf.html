<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Numo::GSL::Sf
  
    &mdash; Documentation by YARD 0.9.8
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Numo::GSL::Sf";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../x_index.html">Index (S)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Numo.html" title="Numo (module)">Numo</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../GSL.html" title="Numo::GSL (module)">GSL</a></span></span>
     &raquo; 
    <span class="title">Sf</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Numo::GSL::Sf
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>ext/numo/gsl/sf/gsl_sf.c</dd>
  </dl>
  
</div>

<h2>Defined Under Namespace</h2>
<p class="children">
  
    
  
    
      <strong class="classes">Classes:</strong> <span class='object_link'><a href="Sf/Mathieu.html" title="Numo::GSL::Sf::Mathieu (class)">Mathieu</a></span>
    
  
</p>







  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai-class_method" title="airy_Ai (class method)">.<strong>airy_Ai</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Ai(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv-class_method" title="airy_Ai_deriv (class method)">.<strong>airy_Ai_deriv</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Ai’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_e-class_method" title="airy_Ai_deriv_e (class method)">.<strong>airy_Ai_deriv_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Ai’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_scaled-class_method" title="airy_Ai_deriv_scaled (class method)">.<strong>airy_Ai_deriv_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_A(x) Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_deriv_scaled_e-class_method" title="airy_Ai_deriv_scaled_e (class method)">.<strong>airy_Ai_deriv_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_A(x) Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_e-class_method" title="airy_Ai_e (class method)">.<strong>airy_Ai_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Ai(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_scaled-class_method" title="airy_Ai_scaled (class method)">.<strong>airy_Ai_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_A(x) Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Ai_scaled_e-class_method" title="airy_Ai_scaled_e (class method)">.<strong>airy_Ai_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_A(x) Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi-class_method" title="airy_Bi (class method)">.<strong>airy_Bi</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Bi(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv-class_method" title="airy_Bi_deriv (class method)">.<strong>airy_Bi_deriv</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Bi’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_e-class_method" title="airy_Bi_deriv_e (class method)">.<strong>airy_Bi_deriv_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function derivative Bi’(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_scaled-class_method" title="airy_Bi_deriv_scaled (class method)">.<strong>airy_Bi_deriv_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_B(x) Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_deriv_scaled_e-class_method" title="airy_Bi_deriv_scaled_e (class method)">.<strong>airy_Bi_deriv_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled Airy function derivative S_B(x) Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_e-class_method" title="airy_Bi_e (class method)">.<strong>airy_Bi_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Airy function Bi(x) with an accuracy specified by mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_scaled-class_method" title="airy_Bi_scaled (class method)">.<strong>airy_Bi_scaled</strong>(x[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_B(x) Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_Bi_scaled_e-class_method" title="airy_Bi_scaled_e (class method)">.<strong>airy_Bi_scaled_e</strong>(x, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute a scaled version of the Airy function S_B(x) Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai-class_method" title="airy_zero_Ai (class method)">.<strong>airy_zero_Ai</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_deriv-class_method" title="airy_zero_Ai_deriv (class method)">.<strong>airy_zero_Ai_deriv</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_deriv_e-class_method" title="airy_zero_Ai_deriv_e (class method)">.<strong>airy_zero_Ai_deriv_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Ai’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Ai_e-class_method" title="airy_zero_Ai_e (class method)">.<strong>airy_zero_Ai_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Ai(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi-class_method" title="airy_zero_Bi (class method)">.<strong>airy_zero_Bi</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_deriv-class_method" title="airy_zero_Bi_deriv (class method)">.<strong>airy_zero_Bi_deriv</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_deriv_e-class_method" title="airy_zero_Bi_deriv_e (class method)">.<strong>airy_zero_Bi_deriv_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function derivative Bi’(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#airy_zero_Bi_e-class_method" title="airy_zero_Bi_e (class method)">.<strong>airy_zero_Bi_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th zero of the Airy function Bi(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#angle_restrict_pos-class_method" title="angle_restrict_pos (class method)">.<strong>angle_restrict_pos</strong>(theta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines force the angle theta to lie in the range [0, 2\pi).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#angle_restrict_symm-class_method" title="angle_restrict_symm (class method)">.<strong>angle_restrict_symm</strong>(theta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines force the angle theta to lie in the range (-\pi,\pi].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#atanint-class_method" title="atanint (class method)">.<strong>atanint</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$ AtanInt(x) = \int_0^x dt \arctan(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#atanint_e-class_method" title="atanint_e (class method)">.<strong>atanint_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$ AtanInt(x) = \int_0^x dt \arctan(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0-class_method" title="bessel_I0 (class method)">.<strong>bessel_I0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_e-class_method" title="bessel_I0_e (class method)">.<strong>bessel_I0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_scaled-class_method" title="bessel_I0_scaled (class method)">.<strong>bessel_I0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \exp(-</td>
      <td>x</td>
      <td>) I_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i0_scaled-class_method" title="bessel_i0_scaled (class method)">.<strong>bessel_i0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of zeroth order, \exp(-</td>
      <td>x</td>
      <td>) i_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I0_scaled_e-class_method" title="bessel_I0_scaled_e (class method)">.<strong>bessel_I0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \exp(-</td>
      <td>x</td>
      <td>) I_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i0_scaled_e-class_method" title="bessel_i0_scaled_e (class method)">.<strong>bessel_i0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of zeroth order, \exp(-</td>
      <td>x</td>
      <td>) i_0(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1-class_method" title="bessel_I1 (class method)">.<strong>bessel_I1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_e-class_method" title="bessel_I1_e (class method)">.<strong>bessel_I1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_scaled-class_method" title="bessel_I1_scaled (class method)">.<strong>bessel_I1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of first order \exp(-</td>
      <td>x</td>
      <td>) I_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i1_scaled-class_method" title="bessel_i1_scaled (class method)">.<strong>bessel_i1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of first order, \exp(-</td>
      <td>x</td>
      <td>) i_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_I1_scaled_e-class_method" title="bessel_I1_scaled_e (class method)">.<strong>bessel_I1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of first order \exp(-</td>
      <td>x</td>
      <td>) I_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i1_scaled_e-class_method" title="bessel_i1_scaled_e (class method)">.<strong>bessel_i1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of first order, \exp(-</td>
      <td>x</td>
      <td>) i_1(x).</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i2_scaled-class_method" title="bessel_i2_scaled (class method)">.<strong>bessel_i2_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of second order,  \exp(-</td>
      <td>x</td>
      <td>) i_2(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_i2_scaled_e-class_method" title="bessel_i2_scaled_e (class method)">.<strong>bessel_i2_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of second order,  \exp(-</td>
      <td>x</td>
      <td>) i_2(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled-class_method" title="bessel_il_scaled (class method)">.<strong>bessel_il_scaled</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of order l,  \exp(-</td>
      <td>x</td>
      <td>) i_l(x) Domain: l &gt;= 0 Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled_array-class_method" title="bessel_il_scaled_array (class method)">.<strong>bessel_il_scaled_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This routine computes the values of the scaled regular modified spherical Bessel functions \exp(-</td>
      <td>x</td>
      <td>) i_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0, storing the results in the array result_array.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_il_scaled_e-class_method" title="bessel_il_scaled_e (class method)">.<strong>bessel_il_scaled_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified spherical Bessel function of order l,  \exp(-</td>
      <td>x</td>
      <td>) i_l(x) Domain: l &gt;= 0 Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In-class_method" title="bessel_In (class method)">.<strong>bessel_In</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of order n, I_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_array-class_method" title="bessel_In_array (class method)">.<strong>bessel_In_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular modified cylindrical Bessel functions I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_e-class_method" title="bessel_In_e (class method)">.<strong>bessel_In_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified cylindrical Bessel function of order n, I_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled-class_method" title="bessel_In_scaled (class method)">.<strong>bessel_In_scaled</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of order n, \exp(-</td>
      <td>x</td>
      <td>) I_n(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled_array-class_method" title="bessel_In_scaled_array (class method)">.<strong>bessel_In_scaled_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This routine computes the values of the scaled regular cylindrical Bessel functions \exp(-</td>
      <td>x</td>
      <td>) I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_In_scaled_e-class_method" title="bessel_In_scaled_e (class method)">.<strong>bessel_In_scaled_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified cylindrical Bessel function of order n, \exp(-</td>
      <td>x</td>
      <td>) I_n(x) Exceptional Return Values: GSL_EUNDRFLW.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu-class_method" title="bessel_Inu (class method)">.<strong>bessel_Inu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified Bessel function of fractional order \nu, I_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_e-class_method" title="bessel_Inu_e (class method)">.<strong>bessel_Inu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular modified Bessel function of fractional order \nu, I_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_scaled-class_method" title="bessel_Inu_scaled (class method)">.<strong>bessel_Inu_scaled</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified Bessel function of fractional order \nu, \exp(-</td>
      <td>x</td>
      <td>)I_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Inu_scaled_e-class_method" title="bessel_Inu_scaled_e (class method)">.<strong>bessel_Inu_scaled_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled regular modified Bessel function of fractional order \nu, \exp(-</td>
      <td>x</td>
      <td>)I_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J0-class_method" title="bessel_J0 (class method)">.<strong>bessel_J0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j0-class_method" title="bessel_j0 (class method)">.<strong>bessel_j0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of zeroth order, j_0(x) = \sin(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J0_e-class_method" title="bessel_J0_e (class method)">.<strong>bessel_J0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of zeroth order, J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j0_e-class_method" title="bessel_j0_e (class method)">.<strong>bessel_j0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of zeroth order, j_0(x) = \sin(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J1-class_method" title="bessel_J1 (class method)">.<strong>bessel_J1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of first order, J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j1-class_method" title="bessel_j1 (class method)">.<strong>bessel_j1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of first order, j_1(x) = (\sin(x)/x - \cos(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_J1_e-class_method" title="bessel_J1_e (class method)">.<strong>bessel_J1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of first order, J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j1_e-class_method" title="bessel_j1_e (class method)">.<strong>bessel_j1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of first order, j_1(x) = (\sin(x)/x - \cos(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j2-class_method" title="bessel_j2 (class method)">.<strong>bessel_j2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_j2_e-class_method" title="bessel_j2_e (class method)">.<strong>bessel_j2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl-class_method" title="bessel_jl (class method)">.<strong>bessel_jl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of order l, j_l(x), for $l \geq 0$ l &gt;= 0 and $x \geq 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_array-class_method" title="bessel_jl_array (class method)">.<strong>bessel_jl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive  for $lmax \geq 0$ lmax &gt;= 0 and $x \geq 0$ x &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_e-class_method" title="bessel_jl_e (class method)">.<strong>bessel_jl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular spherical Bessel function of order l, j_l(x), for $l \geq 0$ l &gt;= 0 and $x \geq 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_jl_steed_array-class_method" title="bessel_jl_steed_array (class method)">.<strong>bessel_jl_steed_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine uses Steed’s method to compute the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0 and $x \geq 0$ x &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn-class_method" title="bessel_Jn (class method)">.<strong>bessel_Jn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of order n, J_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn_array-class_method" title="bessel_Jn_array (class method)">.<strong>bessel_Jn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the regular cylindrical Bessel functions J_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jn_e-class_method" title="bessel_Jn_e (class method)">.<strong>bessel_Jn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of order n, J_n(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jnu-class_method" title="bessel_Jnu (class method)">.<strong>bessel_Jnu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of fractional order \nu, J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Jnu_e-class_method" title="bessel_Jnu_e (class method)">.<strong>bessel_Jnu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular cylindrical Bessel function of fractional order \nu, J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0-class_method" title="bessel_K0 (class method)">.<strong>bessel_K0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_e-class_method" title="bessel_K0_e (class method)">.<strong>bessel_K0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_scaled-class_method" title="bessel_K0_scaled (class method)">.<strong>bessel_K0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \exp(x) K_0(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k0_scaled-class_method" title="bessel_k0_scaled (class method)">.<strong>bessel_k0_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of zeroth order, \exp(x) k_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K0_scaled_e-class_method" title="bessel_K0_scaled_e (class method)">.<strong>bessel_K0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \exp(x) K_0(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k0_scaled_e-class_method" title="bessel_k0_scaled_e (class method)">.<strong>bessel_k0_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of zeroth order, \exp(x) k_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1-class_method" title="bessel_K1 (class method)">.<strong>bessel_K1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_e-class_method" title="bessel_K1_e (class method)">.<strong>bessel_K1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_scaled-class_method" title="bessel_K1_scaled (class method)">.<strong>bessel_K1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of first order \exp(x) K_1(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k1_scaled-class_method" title="bessel_k1_scaled (class method)">.<strong>bessel_k1_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of first order, \exp(x) k_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_K1_scaled_e-class_method" title="bessel_K1_scaled_e (class method)">.<strong>bessel_K1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of first order \exp(x) K_1(x) for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k1_scaled_e-class_method" title="bessel_k1_scaled_e (class method)">.<strong>bessel_k1_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of first order, \exp(x) k_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k2_scaled-class_method" title="bessel_k2_scaled (class method)">.<strong>bessel_k2_scaled</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of second order, \exp(x) k_2(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_k2_scaled_e-class_method" title="bessel_k2_scaled_e (class method)">.<strong>bessel_k2_scaled_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of second order, \exp(x) k_2(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled-class_method" title="bessel_kl_scaled (class method)">.<strong>bessel_kl_scaled</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of order l, \exp(x) k_l(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled_array-class_method" title="bessel_kl_scaled_array (class method)">.<strong>bessel_kl_scaled_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the scaled irregular modified spherical Bessel functions \exp(x) k_l(x) for l from 0 to lmax inclusive for $lmax \geq 0$ lmax &gt;= 0 and x&gt;0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_kl_scaled_e-class_method" title="bessel_kl_scaled_e (class method)">.<strong>bessel_kl_scaled_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified spherical Bessel function of order l, \exp(x) k_l(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn-class_method" title="bessel_Kn (class method)">.<strong>bessel_Kn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_array-class_method" title="bessel_Kn_array (class method)">.<strong>bessel_Kn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular modified cylindrical Bessel functions K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_e-class_method" title="bessel_Kn_e (class method)">.<strong>bessel_Kn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled-class_method" title="bessel_Kn_scaled (class method)">.<strong>bessel_Kn_scaled</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of order n, \exp(x) K_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled_array-class_method" title="bessel_Kn_scaled_array (class method)">.<strong>bessel_Kn_scaled_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the scaled irregular cylindrical Bessel functions \exp(x) K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Kn_scaled_e-class_method" title="bessel_Kn_scaled_e (class method)">.<strong>bessel_Kn_scaled_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the scaled irregular modified cylindrical Bessel function of order n, \exp(x) K_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu-class_method" title="bessel_Knu (class method)">.<strong>bessel_Knu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified Bessel function of fractional order \nu, K_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_e-class_method" title="bessel_Knu_e (class method)">.<strong>bessel_Knu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular modified Bessel function of fractional order \nu, K_\nu(x) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_scaled-class_method" title="bessel_Knu_scaled (class method)">.<strong>bessel_Knu_scaled</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled irregular modified Bessel function of fractional order \nu, \exp(+</td>
      <td>x</td>
      <td>) K_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Knu_scaled_e-class_method" title="bessel_Knu_scaled_e (class method)">.<strong>bessel_Knu_scaled_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the scaled irregular modified Bessel function of fractional order \nu, \exp(+</td>
      <td>x</td>
      <td>) K_\nu(x) for x&gt;0, \nu&gt;0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_lnKnu-class_method" title="bessel_lnKnu (class method)">.<strong>bessel_lnKnu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the irregular modified Bessel function of fractional order \nu, \ln(K_\nu(x)) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_lnKnu_e-class_method" title="bessel_lnKnu_e (class method)">.<strong>bessel_lnKnu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the irregular modified Bessel function of fractional order \nu, \ln(K_\nu(x)) for x&gt;0, \nu&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y0-class_method" title="bessel_Y0 (class method)">.<strong>bessel_Y0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y0-class_method" title="bessel_y0 (class method)">.<strong>bessel_y0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = -\cos(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y0_e-class_method" title="bessel_Y0_e (class method)">.<strong>bessel_Y0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y0_e-class_method" title="bessel_y0_e (class method)">.<strong>bessel_y0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = -\cos(x)/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y1-class_method" title="bessel_Y1 (class method)">.<strong>bessel_Y1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y1-class_method" title="bessel_y1 (class method)">.<strong>bessel_y1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of first order, y_1(x) = -(\cos(x)/x + \sin(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Y1_e-class_method" title="bessel_Y1_e (class method)">.<strong>bessel_Y1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y1_e-class_method" title="bessel_y1_e (class method)">.<strong>bessel_y1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of first order, y_1(x) = -(\cos(x)/x + \sin(x))/x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y2-class_method" title="bessel_y2 (class method)">.<strong>bessel_y2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_y2_e-class_method" title="bessel_y2_e (class method)">.<strong>bessel_y2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl-class_method" title="bessel_yl (class method)">.<strong>bessel_yl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of order l, y_l(x), for $l \geq 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl_array-class_method" title="bessel_yl_array (class method)">.<strong>bessel_yl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular spherical Bessel functions y_l(x) for l from 0 to lmax inclusive  for $lmax \geq 0$ lmax &gt;= 0, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_yl_e-class_method" title="bessel_yl_e (class method)">.<strong>bessel_yl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular spherical Bessel function of order l, y_l(x), for $l \geq 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn-class_method" title="bessel_Yn (class method)">.<strong>bessel_Yn</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn_array-class_method" title="bessel_Yn_array (class method)">.<strong>bessel_Yn_array</strong>(nmin, nmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the values of the irregular cylindrical Bessel functions Y_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Yn_e-class_method" title="bessel_Yn_e (class method)">.<strong>bessel_Yn_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Ynu-class_method" title="bessel_Ynu (class method)">.<strong>bessel_Ynu</strong>(nu, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of fractional order \nu, Y_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_Ynu_e-class_method" title="bessel_Ynu_e (class method)">.<strong>bessel_Ynu_e</strong>(nu, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular cylindrical Bessel function of fractional order \nu, Y_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J0-class_method" title="bessel_zero_J0 (class method)">.<strong>bessel_zero_J0</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J0_e-class_method" title="bessel_zero_J0_e (class method)">.<strong>bessel_zero_J0_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J1-class_method" title="bessel_zero_J1 (class method)">.<strong>bessel_zero_J1</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_J1_e-class_method" title="bessel_zero_J1_e (class method)">.<strong>bessel_zero_J1_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_1(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_Jnu-class_method" title="bessel_zero_Jnu (class method)">.<strong>bessel_zero_Jnu</strong>(nu, s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bessel_zero_Jnu_e-class_method" title="bessel_zero_Jnu_e (class method)">.<strong>bessel_zero_Jnu_e</strong>(nu, s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the location of the s-th positive zero of the Bessel function J_\nu(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta-class_method" title="beta (class method)">.<strong>beta</strong>(a, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Beta Function, B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_e-class_method" title="beta_e (class method)">.<strong>beta_e</strong>(a, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Beta Function, B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_inc-class_method" title="beta_inc (class method)">.<strong>beta_inc</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$ B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt for $0 \le x \le 1$ 0 &lt;= x &lt;= 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#beta_inc_e-class_method" title="beta_inc_e (class method)">.<strong>beta_inc_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$ B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt for $0 \le x \le 1$ 0 &lt;= x &lt;= 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Chi-class_method" title="Chi (class method)">.<strong>Chi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Sf.Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$ Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] , where \gamma_E is the Euler constant (available as the macro M_EULER).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Chi_e-class_method" title="Chi_e (class method)">.<strong>Chi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Sf.Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$ Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] , where \gamma_E is the Euler constant (available as the macro M_EULER).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#choose-class_method" title="choose (class method)">.<strong>choose</strong>(n, m)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the combinatorial factor n choose m = n!/(m!(n-m)!) exceptions: GSL_EDOM, GSL_EOVRFLW.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#choose_e-class_method" title="choose_e (class method)">.<strong>choose_e</strong>(n, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the combinatorial factor n choose m = n!/(m!(n-m)!) exceptions: GSL_EDOM, GSL_EOVRFLW.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Ci-class_method" title="Ci (class method)">.<strong>Ci</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Sf.Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$ Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Ci_e-class_method" title="Ci_e (class method)">.<strong>Ci_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Sf.Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$ Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clausen-class_method" title="clausen (class method)">.<strong>clausen</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Clausen integral Cl_2(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clausen_e-class_method" title="clausen_e (class method)">.<strong>clausen_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Clausen integral Cl_2(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_cos_e-class_method" title="complex_cos_e (class method)">.<strong>complex_cos_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the complex cosine, \cos(z_r + i z_i) storing the real and imaginary parts in czr, czi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_dilog_e-class_method" title="complex_dilog_e (class method)">.<strong>complex_dilog_e</strong>(r, theta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the full complex-valued dilogarithm for the complex argument z = r \exp(i \theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_log_e-class_method" title="complex_log_e (class method)">.<strong>complex_log_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the complex logarithm of z = z_r + i z_i.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_logsin_e-class_method" title="complex_logsin_e (class method)">.<strong>complex_logsin_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the logarithm of the complex sine, \log(\sin(z_r + i z_i)) storing the real and imaginary parts in lszr, lszi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#complex_sin_e-class_method" title="complex_sin_e (class method)">.<strong>complex_sin_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the complex sine, \sin(z_r + i z_i) storing the real and imaginary parts in szr, szi.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_0-class_method" title="conicalP_0 (class method)">.<strong>conicalP_0</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^0<em>+ i \lambda(x)$ P^0</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_0_e-class_method" title="conicalP_0_e (class method)">.<strong>conicalP_0_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^0<em>+ i \lambda(x)$ P^0</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_1-class_method" title="conicalP_1 (class method)">.<strong>conicalP_1</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^1<em>+ i \lambda(x)$ P^1</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_1_e-class_method" title="conicalP_1_e (class method)">.<strong>conicalP_1_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the conical function $P^1<em>+ i \lambda(x)$ P^1</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_cyl_reg-class_method" title="conicalP_cyl_reg (class method)">.<strong>conicalP_cyl_reg</strong>(m, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Cylindrical Conical Function $P^-m<em>+ i \lambda(x)$ P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$ m &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_cyl_reg_e-class_method" title="conicalP_cyl_reg_e (class method)">.<strong>conicalP_cyl_reg_e</strong>(m, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Cylindrical Conical Function $P^-m<em>+ i \lambda(x)$ P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$ m &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_half-class_method" title="conicalP_half (class method)">.<strong>conicalP_half</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular Spherical Conical Function $P^1/2<em>+ i \lambda(x)$ P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_half_e-class_method" title="conicalP_half_e (class method)">.<strong>conicalP_half_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the irregular Spherical Conical Function $P^1/2<em>+ i \lambda(x)$ P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_mhalf-class_method" title="conicalP_mhalf (class method)">.<strong>conicalP_mhalf</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular Spherical Conical Function $P^-1/2<em>+ i \lambda(x)$ P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_mhalf_e-class_method" title="conicalP_mhalf_e (class method)">.<strong>conicalP_mhalf_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regular Spherical Conical Function $P^-1/2<em>+ i \lambda(x)$ P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_sph_reg-class_method" title="conicalP_sph_reg (class method)">.<strong>conicalP_sph_reg</strong>(l, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Spherical Conical Function $P^-1/2-l<em>+ i \lambda(x)$ P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$ l &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#conicalP_sph_reg_e-class_method" title="conicalP_sph_reg_e (class method)">.<strong>conicalP_sph_reg_e</strong>(l, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Regular Spherical Conical Function $P^-1/2-l<em>+ i \lambda(x)$ P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$ l &gt;= -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos-class_method" title="cos (class method)">.<strong>cos</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the cosine function \cos(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos_e-class_method" title="cos_e (class method)">.<strong>cos_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the cosine function \cos(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cos_err_e-class_method" title="cos_err_e (class method)">.<strong>cos_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the cosine of an angle x with an associated absolute error dx, $\cos(x \pm dx)$ \cos(x \pm dx).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_CL_array-class_method" title="coulomb_CL_array (class method)">.<strong>coulomb_CL_array</strong>(Lmin, kmax, eta)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function normalization constant C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_CL_e-class_method" title="coulomb_CL_e (class method)">.<strong>coulomb_CL_e</strong>(L, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function normalization constant C_L(\eta) for L &gt; -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_F_array-class_method" title="coulomb_wave_F_array (class method)">.<strong>coulomb_wave_F_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function F_L(\eta,x) for L = Lmin \dots Lmin + kmax, storing the results in fc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FG_array-class_method" title="coulomb_wave_FG_array (class method)">.<strong>coulomb_wave_FG_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the functions F_L(\eta,x), G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the results in fc_array and gc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FG_e-class_method" title="coulomb_wave_FG_e (class method)">.<strong>coulomb_wave_FG_e</strong>(eta, x, L_F, k)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave functions F_L(\eta,x), $G_L-k(\eta,x)$ G_@L-k@(\eta,x) and their derivatives F’<em>L(\eta,x), $G’</em>L-k(\eta,x)$ G’_@L-k@(\eta,x) with respect to x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_FGp_array-class_method" title="coulomb_wave_FGp_array (class method)">.<strong>coulomb_wave_FGp_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the functions F_L(\eta,x), G_L(\eta,x) and their derivatives F’_L(\eta,x), G’_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the results in fc_array, gc_array, fcp_array and gcp_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coulomb_wave_sphF_array-class_method" title="coulomb_wave_sphF_array (class method)">.<strong>coulomb_wave_sphF_array</strong>(L_min, kmax, eta, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Coulomb wave function divided by the argument F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the results in fc_array.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_3j-class_method" title="coupling_3j (class method)">.<strong>coupling_3j</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 3-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_3j_e-class_method" title="coupling_3j_e (class method)">.<strong>coupling_3j_e</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 3-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_6j-class_method" title="coupling_6j (class method)">.<strong>coupling_6j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 6-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_6j_e-class_method" title="coupling_6j_e (class method)">.<strong>coupling_6j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 6-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_9j-class_method" title="coupling_9j (class method)">.<strong>coupling_9j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; Float </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 9-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#coupling_9j_e-class_method" title="coupling_9j_e (class method)">.<strong>coupling_9j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Wigner 9-j coefficient,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dawson-class_method" title="dawson (class method)">.<strong>dawson</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the value of Dawson’s integral for x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dawson_e-class_method" title="dawson_e (class method)">.<strong>dawson_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the value of Dawson’s integral for x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_1-class_method" title="debye_1 (class method)">.<strong>debye_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first-order Debye function D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_1_e-class_method" title="debye_1_e (class method)">.<strong>debye_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first-order Debye function D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_2-class_method" title="debye_2 (class method)">.<strong>debye_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order Debye function D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_2_e-class_method" title="debye_2_e (class method)">.<strong>debye_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order Debye function D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_3-class_method" title="debye_3 (class method)">.<strong>debye_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order Debye function D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_3_e-class_method" title="debye_3_e (class method)">.<strong>debye_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order Debye function D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_4-class_method" title="debye_4 (class method)">.<strong>debye_4</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_4_e-class_method" title="debye_4_e (class method)">.<strong>debye_4_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_5-class_method" title="debye_5 (class method)">.<strong>debye_5</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_5_e-class_method" title="debye_5_e (class method)">.<strong>debye_5_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_6-class_method" title="debye_6 (class method)">.<strong>debye_6</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#debye_6_e-class_method" title="debye_6_e (class method)">.<strong>debye_6_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dilog-class_method" title="dilog (class method)">.<strong>dilog</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the dilogarithm for a real argument.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dilog_e-class_method" title="dilog_e (class method)">.<strong>dilog_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the dilogarithm for a real argument.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#doublefact-class_method" title="doublefact (class method)">.<strong>doublefact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#doublefact_e-class_method" title="doublefact_e (class method)">.<strong>doublefact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_D-class_method" title="ellint_D (class method)">.<strong>ellint_D</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the incomplete elliptic integral D(\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_D_e-class_method" title="ellint_D_e (class method)">.<strong>ellint_D_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the incomplete elliptic integral D(\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_E-class_method" title="ellint_E (class method)">.<strong>ellint_E</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral E(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_E_e-class_method" title="ellint_E_e (class method)">.<strong>ellint_E_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral E(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Ecomp-class_method" title="ellint_Ecomp (class method)">.<strong>ellint_Ecomp</strong>(k[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Ecomp_e-class_method" title="ellint_Ecomp_e (class method)">.<strong>ellint_Ecomp_e</strong>(k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_F-class_method" title="ellint_F (class method)">.<strong>ellint_F</strong>(phi, k, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral F(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_F_e-class_method" title="ellint_F_e (class method)">.<strong>ellint_F_e</strong>(phi, k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral F(\phi,k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Kcomp-class_method" title="ellint_Kcomp (class method)">.<strong>ellint_Kcomp</strong>(k[,mode])  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Kcomp_e-class_method" title="ellint_Kcomp_e (class method)">.<strong>ellint_Kcomp_e</strong>(k, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_P-class_method" title="ellint_P (class method)">.<strong>ellint_P</strong>(phi, k, n, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_P_e-class_method" title="ellint_P_e (class method)">.<strong>ellint_P_e</strong>(phi, k, n, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Pcomp-class_method" title="ellint_Pcomp (class method)">.<strong>ellint_Pcomp</strong>(k, n, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral \Pi(k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_Pcomp_e-class_method" title="ellint_Pcomp_e (class method)">.<strong>ellint_Pcomp_e</strong>(k, n, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete elliptic integral \Pi(k,n) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RC-class_method" title="ellint_RC (class method)">.<strong>ellint_RC</strong>(x, y, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RC_e-class_method" title="ellint_RC_e (class method)">.<strong>ellint_RC_e</strong>(x, y, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RD-class_method" title="ellint_RD (class method)">.<strong>ellint_RD</strong>(x, y, z, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RD_e-class_method" title="ellint_RD_e (class method)">.<strong>ellint_RD_e</strong>(x, y, z, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RF-class_method" title="ellint_RF (class method)">.<strong>ellint_RF</strong>(x, y, z, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RF_e-class_method" title="ellint_RF_e (class method)">.<strong>ellint_RF_e</strong>(x, y, z, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RJ-class_method" title="ellint_RJ (class method)">.<strong>ellint_RJ</strong>(x, y, z, p, [mode])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ellint_RJ_e-class_method" title="ellint_RJ_e (class method)">.<strong>ellint_RJ_e</strong>(x, y, z, p, [mode])  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#elljac_e-class_method" title="elljac_e (class method)">.<strong>elljac_e</strong>(u, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>This function computes the Jacobian elliptic functions sn(u</td>
      <td>m), cn(u</td>
      <td>m), dn(u</td>
      <td>m) by descending Landen transformations.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf-class_method" title="erf (class method)">.<strong>erf</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the error function $\erf(x)$ erf(x), where $\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$ erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_e-class_method" title="erf_e (class method)">.<strong>erf_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the error function $\erf(x)$ erf(x), where $\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$ erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Q-class_method" title="erf_Q (class method)">.<strong>erf_Q</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the upper tail of the Gaussian probability function $Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$ Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Q_e-class_method" title="erf_Q_e (class method)">.<strong>erf_Q_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the upper tail of the Gaussian probability function $Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$ Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Z-class_method" title="erf_Z (class method)">.<strong>erf_Z</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gaussian probability density function $Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$ Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erf_Z_e-class_method" title="erf_Z_e (class method)">.<strong>erf_Z_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gaussian probability density function $Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$ Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erfc-class_method" title="erfc (class method)">.<strong>erfc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary error function $\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$ erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#erfc_e-class_method" title="erfc_e (class method)">.<strong>erfc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary error function $\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$ erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta-class_method" title="eta (class method)">.<strong>eta</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(s) for arbitrary s.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_e-class_method" title="eta_e (class method)">.<strong>eta_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(s) for arbitrary s.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_int-class_method" title="eta_int (class method)">.<strong>eta_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(n) for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eta_int_e-class_method" title="eta_int_e (class method)">.<strong>eta_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the eta function \eta(n) for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp-class_method" title="exp (class method)">.<strong>exp</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines provide an exponential function \exp(x) using GSL semantics and error checking.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_e-class_method" title="exp_e (class method)">.<strong>exp_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines provide an exponential function \exp(x) using GSL semantics and error checking.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_e10_e-class_method" title="exp_e10_e (class method)">.<strong>exp_e10_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the exponential \exp(x) using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_err_e-class_method" title="exp_err_e (class method)">.<strong>exp_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function exponentiates x with an associated absolute error dx.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_err_e10_e-class_method" title="exp_err_e10_e (class method)">.<strong>exp_err_e10_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function exponentiates a quantity x with an associated absolute error dx using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult-class_method" title="exp_mult (class method)">.<strong>exp_mult</strong>(x, y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines exponentiate x and multiply by the factor y to return the product y \exp(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_e-class_method" title="exp_mult_e (class method)">.<strong>exp_mult_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines exponentiate x and multiply by the factor y to return the product y \exp(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_e10_e-class_method" title="exp_mult_e10_e (class method)">.<strong>exp_mult_e10_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the product y \exp(x) using the gsl_sf_result_e10 type to return a result with extended numeric range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_err_e-class_method" title="exp_mult_err_e (class method)">.<strong>exp_mult_err_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the product y \exp(x) for the quantities x, y with associated absolute errors dx, dy.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exp_mult_err_e10_e-class_method" title="exp_mult_err_e10_e (class method)">.<strong>exp_mult_err_e10_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the product y \exp(x) for the quantities x, y with associated absolute errors dx, dy using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_3-class_method" title="expint_3 (class method)">.<strong>expint_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$ Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_3_e-class_method" title="expint_3_e (class method)">.<strong>expint_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$ Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E1-class_method" title="expint_E1 (class method)">.<strong>expint_E1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_1(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E1_e-class_method" title="expint_E1_e (class method)">.<strong>expint_E1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_1(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E2-class_method" title="expint_E2 (class method)">.<strong>expint_E2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order exponential integral E_2(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_E2_e-class_method" title="expint_E2_e (class method)">.<strong>expint_E2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second-order exponential integral E_2(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_Ei-class_method" title="expint_Ei (class method)">.<strong>expint_Ei</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral $\hboxEi(x)$ Ei(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_Ei_e-class_method" title="expint_Ei_e (class method)">.<strong>expint_Ei_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral $\hboxEi(x)$ Ei(x),.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_En-class_method" title="expint_En (class method)">.<strong>expint_En</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_n(x) of order n,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expint_En_e-class_method" title="expint_En_e (class method)">.<strong>expint_En_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the exponential integral E_n(x) of order n,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expm1-class_method" title="expm1 (class method)">.<strong>expm1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity \exp(x)-1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#expm1_e-class_method" title="expm1_e (class method)">.<strong>expm1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity \exp(x)-1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel-class_method" title="exprel (class method)">.<strong>exprel</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity (\exp(x)-1)/x using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_2-class_method" title="exprel_2 (class method)">.<strong>exprel_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_2_e-class_method" title="exprel_2_e (class method)">.<strong>exprel_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_e-class_method" title="exprel_e (class method)">.<strong>exprel_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the quantity (\exp(x)-1)/x using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_n-class_method" title="exprel_n (class method)">.<strong>exprel_n</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#exprel_n_e-class_method" title="exprel_n_e (class method)">.<strong>exprel_n_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fact-class_method" title="fact (class method)">.<strong>fact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the factorial n!.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fact_e-class_method" title="fact_e (class method)">.<strong>fact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the factorial n!.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_0-class_method" title="fermi_dirac_0 (class method)">.<strong>fermi_dirac_0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_0_e-class_method" title="fermi_dirac_0_e (class method)">.<strong>fermi_dirac_0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_1-class_method" title="fermi_dirac_1 (class method)">.<strong>fermi_dirac_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_1_e-class_method" title="fermi_dirac_1_e (class method)">.<strong>fermi_dirac_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_2-class_method" title="fermi_dirac_2 (class method)">.<strong>fermi_dirac_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_2_e-class_method" title="fermi_dirac_2_e (class method)">.<strong>fermi_dirac_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_3half-class_method" title="fermi_dirac_3half (class method)">.<strong>fermi_dirac_3half</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_3/2(x)$ F_@3/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_3half_e-class_method" title="fermi_dirac_3half_e (class method)">.<strong>fermi_dirac_3half_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_3/2(x)$ F_@3/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_half-class_method" title="fermi_dirac_half (class method)">.<strong>fermi_dirac_half</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_1/2(x)$ F_@1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_half_e-class_method" title="fermi_dirac_half_e (class method)">.<strong>fermi_dirac_half_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_1/2(x)$ F_@1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_inc_0-class_method" title="fermi_dirac_inc_0 (class method)">.<strong>fermi_dirac_inc_0</strong>(x, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, $F_0(x,b) = \ln(1 + e^b-x) - (b-x)$ F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_inc_0_e-class_method" title="fermi_dirac_inc_0_e (class method)">.<strong>fermi_dirac_inc_0_e</strong>(x, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the incomplete Fermi-Dirac integral with an index of zero, $F_0(x,b) = \ln(1 + e^b-x) - (b-x)$ F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_int-class_method" title="fermi_dirac_int (class method)">.<strong>fermi_dirac_int</strong>(j, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_int_e-class_method" title="fermi_dirac_int_e (class method)">.<strong>fermi_dirac_int_e</strong>(j, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_m1-class_method" title="fermi_dirac_m1 (class method)">.<strong>fermi_dirac_m1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_m1_e-class_method" title="fermi_dirac_m1_e (class method)">.<strong>fermi_dirac_m1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral with an index of -1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_mhalf-class_method" title="fermi_dirac_mhalf (class method)">.<strong>fermi_dirac_mhalf</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_-1/2(x)$ F_@-1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fermi_dirac_mhalf_e-class_method" title="fermi_dirac_mhalf_e (class method)">.<strong>fermi_dirac_mhalf_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complete Fermi-Dirac integral $F_-1/2(x)$ F_@-1/2@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma-class_method" title="gamma (class method)">.<strong>gamma</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gamma function \Gamma(x), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_e-class_method" title="gamma_e (class method)">.<strong>gamma_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Gamma function \Gamma(x), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc-class_method" title="gamma_inc (class method)">.<strong>gamma_inc</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the unnormalized incomplete Gamma Function $\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$ \Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t) for a real and $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_e-class_method" title="gamma_inc_e (class method)">.<strong>gamma_inc_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions compute the unnormalized incomplete Gamma Function $\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$ \Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t) for a real and $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_P-class_method" title="gamma_inc_P (class method)">.<strong>gamma_inc_P</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary normalized incomplete Gamma Function $P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$ P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_P_e-class_method" title="gamma_inc_P_e (class method)">.<strong>gamma_inc_P_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the complementary normalized incomplete Gamma Function $P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$ P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_Q-class_method" title="gamma_inc_Q (class method)">.<strong>gamma_inc_Q</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Gamma Function $Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$ Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gamma_inc_Q_e-class_method" title="gamma_inc_Q_e (class method)">.<strong>gamma_inc_Q_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized incomplete Gamma Function $Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$ Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t) for a &gt; 0, $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammainv-class_method" title="gammainv (class method)">.<strong>gammainv</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the reciprocal of the gamma function, 1/\Gamma(x) using the real Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammainv_e-class_method" title="gammainv_e (class method)">.<strong>gammainv_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the reciprocal of the gamma function, 1/\Gamma(x) using the real Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammastar-class_method" title="gammastar (class method)">.<strong>gammastar</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regulated Gamma Function \Gamma^*(x) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gammastar_e-class_method" title="gammastar_e (class method)">.<strong>gammastar_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the regulated Gamma Function \Gamma^*(x) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_1-class_method" title="gegenpoly_1 (class method)">.<strong>gegenpoly_1</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_1_e-class_method" title="gegenpoly_1_e (class method)">.<strong>gegenpoly_1_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_2-class_method" title="gegenpoly_2 (class method)">.<strong>gegenpoly_2</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_2_e-class_method" title="gegenpoly_2_e (class method)">.<strong>gegenpoly_2_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_3-class_method" title="gegenpoly_3 (class method)">.<strong>gegenpoly_3</strong>(lambda, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_3_e-class_method" title="gegenpoly_3_e (class method)">.<strong>gegenpoly_3_e</strong>(lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) using explicit representations for n =1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_array-class_method" title="gegenpoly_array (class method)">.<strong>gegenpoly_array</strong>(nmax, lambda, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an array of Gegenbauer polynomials $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) for n = 0, 1, 2, \dots, nmax, subject to \lambda &gt; -1/2, $nmax \ge 0$ nmax &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_n-class_method" title="gegenpoly_n (class method)">.<strong>gegenpoly_n</strong>(n, lambda, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) for a specific value of n, lambda, x subject to \lambda &gt; -1/2, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gegenpoly_n_e-class_method" title="gegenpoly_n_e (class method)">.<strong>gegenpoly_n_e</strong>(n, lambda, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$ C^@(\lambda)@_n(x) for a specific value of n, lambda, x subject to \lambda &gt; -1/2, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hazard-class_method" title="hazard (class method)">.<strong>hazard</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hazard function for the normal distribution.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hazard_e-class_method" title="hazard_e (class method)">.<strong>hazard_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hazard function for the normal distribution.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR-class_method" title="hydrogenicR (class method)">.<strong>hydrogenicR</strong>(n, l, Z, r)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the n-th normalized hydrogenic bound state radial wavefunction,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_1-class_method" title="hydrogenicR_1 (class method)">.<strong>hydrogenicR_1</strong>(Z, r)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$ R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_1_e-class_method" title="hydrogenicR_1_e (class method)">.<strong>hydrogenicR_1_e</strong>(Z, r)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the lowest-order normalized hydrogenic bound state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$ R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hydrogenicR_e-class_method" title="hydrogenicR_e (class method)">.<strong>hydrogenicR_e</strong>(n, l, Z, r)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the n-th normalized hydrogenic bound state radial wavefunction,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_0F1-class_method" title="hyperg_0F1 (class method)">.<strong>hyperg_0F1</strong>(c, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_0F_1(c,x)$ 0F1(c,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_0F1_e-class_method" title="hyperg_0F1_e (class method)">.<strong>hyperg_0F1_e</strong>(c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_0F_1(c,x)$ 0F1(c,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1-class_method" title="hyperg_1F1 (class method)">.<strong>hyperg_1F1</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(a,b,x) = M(a,b,x)$ 1F1(a,b,x) = M(a,b,x) for general parameters a, b.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_e-class_method" title="hyperg_1F1_e (class method)">.<strong>hyperg_1F1_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(a,b,x) = M(a,b,x)$ 1F1(a,b,x) = M(a,b,x) for general parameters a, b.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_int-class_method" title="hyperg_1F1_int (class method)">.<strong>hyperg_1F1_int</strong>(m, n, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(m,n,x) = M(m,n,x)$ 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_1F1_int_e-class_method" title="hyperg_1F1_int_e (class method)">.<strong>hyperg_1F1_int_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function ${}_1F_1(m,n,x) = M(m,n,x)$ 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F0-class_method" title="hyperg_2F0 (class method)">.<strong>hyperg_2F0</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$ 2F0(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F0_e-class_method" title="hyperg_2F0_e (class method)">.<strong>hyperg_2F0_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$ 2F0(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1-class_method" title="hyperg_2F1 (class method)">.<strong>hyperg_2F1</strong>(a, b, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a,b,c,x) = F(a,b,c,x)$ 2F1(a,b,c,x) = F(a,b,c,x) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj-class_method" title="hyperg_2F1_conj (class method)">.<strong>hyperg_2F1_conj</strong>(aR, aI, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a_R + i a_I, aR - i aI, c, x)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_e-class_method" title="hyperg_2F1_conj_e (class method)">.<strong>hyperg_2F1_conj_e</strong>(aR, aI, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a_R + i a_I, aR - i aI, c, x)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_renorm-class_method" title="hyperg_2F1_conj_renorm (class method)">.<strong>hyperg_2F1_conj_renorm</strong>(aR, aI, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_conj_renorm_e-class_method" title="hyperg_2F1_conj_renorm_e (class method)">.<strong>hyperg_2F1_conj_renorm_e</strong>(aR, aI, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$ 2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_e-class_method" title="hyperg_2F1_e (class method)">.<strong>hyperg_2F1_e</strong>(a, b, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the Gauss hypergeometric function ${}_2F_1(a,b,c,x) = F(a,b,c,x)$ 2F1(a,b,c,x) = F(a,b,c,x) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_renorm-class_method" title="hyperg_2F1_renorm (class method)">.<strong>hyperg_2F1_renorm</strong>(a, b, c, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a,b,c,x) / \Gamma(c)$ 2F1(a,b,c,x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_2F1_renorm_e-class_method" title="hyperg_2F1_renorm_e (class method)">.<strong>hyperg_2F1_renorm_e</strong>(a, b, c, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the renormalized Gauss hypergeometric function ${}_2F_1(a,b,c,x) / \Gamma(c)$ 2F1(a,b,c,x) / \Gamma(c) for</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U-class_method" title="hyperg_U (class method)">.<strong>hyperg_U</strong>(a, b, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_e-class_method" title="hyperg_U_e (class method)">.<strong>hyperg_U_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(a,b,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_e10_e-class_method" title="hyperg_U_e10_e (class method)">.<strong>hyperg_U_e10_e</strong>(a, b, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the confluent hypergeometric function U(a,b,x) using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int-class_method" title="hyperg_U_int (class method)">.<strong>hyperg_U_int</strong>(m, n, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int_e-class_method" title="hyperg_U_int_e (class method)">.<strong>hyperg_U_int_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the confluent hypergeometric function U(m,n,x) for integer parameters m, n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hyperg_U_int_e10_e-class_method" title="hyperg_U_int_e10_e (class method)">.<strong>hyperg_U_int_e10_e</strong>(m, n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n using the gsl_sf_result_e10 type to return a result with extended range.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hypot-class_method" title="hypot (class method)">.<strong>hypot</strong>(x, y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypotenuse function $\sqrt+ y^2$ \sqrt@+ y^2@ avoiding overflow and underflow.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hypot_e-class_method" title="hypot_e (class method)">.<strong>hypot_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the hypotenuse function $\sqrt+ y^2$ \sqrt@+ y^2@ avoiding overflow and underflow.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hzeta-class_method" title="hzeta (class method)">.<strong>hzeta</strong>(s, q)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Hurwitz zeta function \zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hzeta_e-class_method" title="hzeta_e (class method)">.<strong>hzeta_e</strong>(s, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Hurwitz zeta function \zeta(s,q) for s &gt; 1, q &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_1-class_method" title="laguerre_1 (class method)">.<strong>laguerre_1</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_1_e-class_method" title="laguerre_1_e (class method)">.<strong>laguerre_1_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_2-class_method" title="laguerre_2 (class method)">.<strong>laguerre_2</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_2_e-class_method" title="laguerre_2_e (class method)">.<strong>laguerre_2_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_3-class_method" title="laguerre_3 (class method)">.<strong>laguerre_3</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_3_e-class_method" title="laguerre_3_e (class method)">.<strong>laguerre_3_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_n-class_method" title="laguerre_n (class method)">.<strong>laguerre_n</strong>(n, a, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#laguerre_n_e-class_method" title="laguerre_n_e (class method)">.<strong>laguerre_n_e</strong>(n, a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines evaluate the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_W0-class_method" title="lambert_W0 (class method)">.<strong>lambert_W0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the principal branch of the Lambert W function, W_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_W0_e-class_method" title="lambert_W0_e (class method)">.<strong>lambert_W0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the principal branch of the Lambert W function, W_0(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_Wm1-class_method" title="lambert_Wm1 (class method)">.<strong>lambert_Wm1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the secondary real-valued branch of the Lambert W function, $W_-1(x)$ W_@-1@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambert_Wm1_e-class_method" title="lambert_Wm1_e (class method)">.<strong>lambert_Wm1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These compute the secondary real-valued branch of the Lambert W function, $W_-1(x)$ W_@-1@(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array-class_method" title="legendre_array (class method)">.<strong>legendre_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre polynomials for 0 \le l \le lmax and 0 \le m \le l for $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_e-class_method" title="legendre_array_e (class method)">.<strong>legendre_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre polynomials for 0 \le l \le lmax and 0 \le m \le l for $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_index-class_method" title="legendre_array_index (class method)">.<strong>legendre_array_index</strong>(l, m)  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index into result_array, result_deriv_array, or result_deriv2_array corresponding to P_l^m(x), P_l^‘m(x), or P_l^‘‘m(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_array_n-class_method" title="legendre_array_n (class method)">.<strong>legendre_array_n</strong>(lmax)  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the minimum array size for maximum degree lmax needed for the array versions of the associated Legendre functions.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_alt_array-class_method" title="legendre_deriv2_alt_array (class method)">.<strong>legendre_deriv2_alt_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_alt_array_e-class_method" title="legendre_deriv2_alt_array_e (class method)">.<strong>legendre_deriv2_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_array-class_method" title="legendre_deriv2_array (class method)">.<strong>legendre_deriv2_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv2_array_e-class_method" title="legendre_deriv2_array_e (class method)">.<strong>legendre_deriv2_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first and second derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_alt_array-class_method" title="legendre_deriv_alt_array (class method)">.<strong>legendre_deriv_alt_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_alt_array_e-class_method" title="legendre_deriv_alt_array_e (class method)">.<strong>legendre_deriv_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their (alternate) first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_array-class_method" title="legendre_deriv_array (class method)">.<strong>legendre_deriv_array</strong>(norm, lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_deriv_array_e-class_method" title="legendre_deriv_array_e (class method)">.<strong>legendre_deriv_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions calculate all normalized associated Legendre functions and their first derivatives up to degree lmax for $</td>
      <td>x</td>
      <td>&lt; 1$</td>
      <td>x</td>
      <td>&lt; 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d-class_method" title="legendre_H3d (class method)">.<strong>legendre_H3d</strong>(l, lambda, eta)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$ \eta &gt;= 0, $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_0-class_method" title="legendre_H3d_0 (class method)">.<strong>legendre_H3d_0</strong>(lambda, eta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script> L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_0_e-class_method" title="legendre_H3d_0_e (class method)">.<strong>legendre_H3d_0_e</strong>(lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script> L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_1-class_method" title="legendre_H3d_1 (class method)">.<strong>legendre_H3d_1</strong>(lambda, eta)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script> L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_1_e-class_method" title="legendre_H3d_1_e (class method)">.<strong>legendre_H3d_1_e</strong>(lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, <script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script> L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta)) for $\eta \ge 0$ \eta &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_array-class_method" title="legendre_H3d_array (class method)">.<strong>legendre_H3d_array</strong>(lmax, lambda, eta)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an array of radial eigenfunctions $L^H3d_l( \lambda, \eta)$ L^@H3d@_l(\lambda, \eta) for $0 \le l \le lmax$ 0 &lt;= l &lt;= lmax.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_H3d_e-class_method" title="legendre_H3d_e (class method)">.<strong>legendre_H3d_e</strong>(l, lambda, eta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$ \eta &gt;= 0, $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P1-class_method" title="legendre_P1 (class method)">.<strong>legendre_P1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P1_e-class_method" title="legendre_P1_e (class method)">.<strong>legendre_P1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P2-class_method" title="legendre_P2 (class method)">.<strong>legendre_P2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P2_e-class_method" title="legendre_P2_e (class method)">.<strong>legendre_P2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P3-class_method" title="legendre_P3 (class method)">.<strong>legendre_P3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_P3_e-class_method" title="legendre_P3_e (class method)">.<strong>legendre_P3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions evaluate the Legendre polynomials $P_l(x)$ P_l(x) using explicit representations for l=1, 2, 3.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl-class_method" title="legendre_Pl (class method)">.<strong>legendre_Pl</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions evaluate the Legendre polynomial $P_l(x)$ P_l(x) for a specific value of l, x subject to $l \ge 0$ l &gt;= 0, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_array-class_method" title="legendre_Pl_array (class method)">.<strong>legendre_Pl_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions compute arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \dots, lmax, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_deriv_array-class_method" title="legendre_Pl_deriv_array (class method)">.<strong>legendre_Pl_deriv_array</strong>(lmax, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions compute arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \dots, lmax, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Pl_e-class_method" title="legendre_Pl_e (class method)">.<strong>legendre_Pl_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These functions evaluate the Legendre polynomial $P_l(x)$ P_l(x) for a specific value of l, x subject to $l \ge 0$ l &gt;= 0, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1 Exceptional Return Values: GSL_EDOM.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Plm-class_method" title="legendre_Plm (class method)">.<strong>legendre_Plm</strong>(l, m, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the associated Legendre polynomial P_l^m(x) for $m \ge 0$ m &gt;= 0, $l \ge m$ l &gt;= m, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Plm_e-class_method" title="legendre_Plm_e (class method)">.<strong>legendre_Plm_e</strong>(l, m, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the associated Legendre polynomial P_l^m(x) for $m \ge 0$ m &gt;= 0, $l \ge m$ l &gt;= m, $</td>
      <td>x</td>
      <td>\le 1$</td>
      <td>x</td>
      <td>&lt;= 1.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q0-class_method" title="legendre_Q0 (class method)">.<strong>legendre_Q0</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_0(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q0_e-class_method" title="legendre_Q0_e (class method)">.<strong>legendre_Q0_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_0(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q1-class_method" title="legendre_Q1 (class method)">.<strong>legendre_Q1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_1(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Q1_e-class_method" title="legendre_Q1_e (class method)">.<strong>legendre_Q1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_1(x) for x &gt; -1, $x \ne 1$ x != 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Ql-class_method" title="legendre_Ql (class method)">.<strong>legendre_Ql</strong>(l, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_l(x) for x &gt; -1, $x \ne 1$ x != 1 and $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_Ql_e-class_method" title="legendre_Ql_e (class method)">.<strong>legendre_Ql_e</strong>(l, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Legendre function Q_l(x) for x &gt; -1, $x \ne 1$ x != 1 and $l \ge 0$ l &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_sphPlm-class_method" title="legendre_sphPlm (class method)">.<strong>legendre_sphPlm</strong>(l, m, x)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized associated Legendre polynomial $\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$ \sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable for use in spherical harmonics.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre_sphPlm_e-class_method" title="legendre_sphPlm_e (class method)">.<strong>legendre_sphPlm_e</strong>(l, m, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the normalized associated Legendre polynomial $\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$ \sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable for use in spherical harmonics.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnbeta-class_method" title="lnbeta (class method)">.<strong>lnbeta</strong>(a, b)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Beta Function, \log(B(a,b)) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnbeta_e-class_method" title="lnbeta_e (class method)">.<strong>lnbeta_e</strong>(a, b)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Beta Function, \log(B(a,b)) subject to a and b not being negative integers.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnchoose-class_method" title="lnchoose (class method)">.<strong>lnchoose</strong>(n, m)  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of n choose m.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnchoose_e-class_method" title="lnchoose_e (class method)">.<strong>lnchoose_e</strong>(n, m)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of n choose m.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lncosh-class_method" title="lncosh (class method)">.<strong>lncosh</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\cosh(x)) for any x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lncosh_e-class_method" title="lncosh_e (class method)">.<strong>lncosh_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\cosh(x)) for any x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lndoublefact-class_method" title="lndoublefact (class method)">.<strong>lndoublefact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the double factorial of n, \log(n!!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lndoublefact_e-class_method" title="lndoublefact_e (class method)">.<strong>lndoublefact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the double factorial of n, \log(n!!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnfact-class_method" title="lnfact (class method)">.<strong>lnfact</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the factorial of n, \log(n!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnfact_e-class_method" title="lnfact_e (class method)">.<strong>lnfact_e</strong>(n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the factorial of n, \log(n!).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma-class_method" title="lngamma (class method)">.<strong>lngamma</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Gamma function, \log(\Gamma(x)), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_complex_e-class_method" title="lngamma_complex_e (class method)">.<strong>lngamma_complex_e</strong>(zr, zi)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes \log(\Gamma(z)) for complex z=z_r+i z_i and z not a negative integer or zero, using the complex Lanczos method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_e-class_method" title="lngamma_e (class method)">.<strong>lngamma_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Gamma function, \log(\Gamma(x)), subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lngamma_sgn_e-class_method" title="lngamma_sgn_e (class method)">.<strong>lngamma_sgn_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the sign of the gamma function and the logarithm of its magnitude, subject to x not being a negative integer or zero.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch-class_method" title="lnpoch (class method)">.<strong>lnpoch</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Pochhammer symbol, \log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch_e-class_method" title="lnpoch_e (class method)">.<strong>lnpoch_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the Pochhammer symbol, \log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnpoch_sgn_e-class_method" title="lnpoch_sgn_e (class method)">.<strong>lnpoch_sgn_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sign of the Pochhammer symbol and the logarithm of its magnitude.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnsinh-class_method" title="lnsinh (class method)">.<strong>lnsinh</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\sinh(x)) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lnsinh_e-class_method" title="lnsinh_e (class method)">.<strong>lnsinh_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(\sinh(x)) for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log-class_method" title="log (class method)">.<strong>log</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of x, \log(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx-class_method" title="log_1plusx (class method)">.<strong>log_1plusx</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_e-class_method" title="log_1plusx_e (class method)">.<strong>log_1plusx_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_mx-class_method" title="log_1plusx_mx (class method)">.<strong>log_1plusx_mx</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_1plusx_mx_e-class_method" title="log_1plusx_mx_e (class method)">.<strong>log_1plusx_mx_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_abs-class_method" title="log_abs (class method)">.<strong>log_abs</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the logarithm of the magnitude of x, \log(</td>
      <td>x</td>
      <td>), for x \ne 0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_abs_e-class_method" title="log_abs_e (class method)">.<strong>log_abs_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><table>
  <tbody>
    <tr>
      <td>These routines compute the logarithm of the magnitude of x, \log(</td>
      <td>x</td>
      <td>), for x \ne 0.</td>
    </tr>
  </tbody>
</table>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_e-class_method" title="log_e (class method)">.<strong>log_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of x, \log(x), for x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_erfc-class_method" title="log_erfc (class method)">.<strong>log_erfc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the complementary error function \log(\erfc(x)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#log_erfc_e-class_method" title="log_erfc_e (class method)">.<strong>log_erfc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the logarithm of the complementary error function \log(\erfc(x)).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_a-class_method" title="mathieu_a (class method)">.<strong>mathieu_a</strong>(n, q)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_a_e-class_method" title="mathieu_a_e (class method)">.<strong>mathieu_a_e</strong>(n, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_b-class_method" title="mathieu_b (class method)">.<strong>mathieu_b</strong>(n, q)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_b_e-class_method" title="mathieu_b_e (class method)">.<strong>mathieu_b_e</strong>(n, q)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_ce-class_method" title="mathieu_ce (class method)">.<strong>mathieu_ce</strong>(n, q, x)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_ce_e-class_method" title="mathieu_ce_e (class method)">.<strong>mathieu_ce_e</strong>(n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Mc-class_method" title="mathieu_Mc (class method)">.<strong>mathieu_Mc</strong>(j, n, q, x)  &#x21d2; Numo::Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Mc_e-class_method" title="mathieu_Mc_e (class method)">.<strong>mathieu_Mc_e</strong>(j, n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Ms-class_method" title="mathieu_Ms (class method)">.<strong>mathieu_Ms</strong>(j, n, q, x)  &#x21d2; Numo::Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_Ms_e-class_method" title="mathieu_Ms_e (class method)">.<strong>mathieu_Ms_e</strong>(j, n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the radial j-th kind Mathieu functions $Mc_n^(j)(q,x)$ Mc_n^@(j)@(q,x) and $Ms_n^(j)(q,x)$ Ms_n^@(j)@(q,x) of order n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_se-class_method" title="mathieu_se (class method)">.<strong>mathieu_se</strong>(n, q, x)  &#x21d2; Int </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mathieu_se_e-class_method" title="mathieu_se_e (class method)">.<strong>mathieu_se_e</strong>(n, q, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#multiply_e-class_method" title="multiply_e (class method)">.<strong>multiply_e</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function multiplies x and y storing the product and its associated error in result.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#multiply_err_e-class_method" title="multiply_err_e (class method)">.<strong>multiply_err_e</strong>(x, dx, y, dy)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function multiplies x and y with associated absolute errors dx and dy.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#poch-class_method" title="poch (class method)">.<strong>poch</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#poch_e-class_method" title="poch_e (class method)">.<strong>poch_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pochrel-class_method" title="pochrel (class method)">.<strong>pochrel</strong>(a, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pochrel_e-class_method" title="pochrel_e (class method)">.<strong>pochrel_e</strong>(a, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#polar_to_rect-class_method" title="polar_to_rect (class method)">.<strong>polar_to_rect</strong>(r, theta)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function converts the polar coordinates (r,theta) to rectilinear coordinates (x,y), x = r\cos(\theta), y = r\sin(\theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow_int-class_method" title="pow_int (class method)">.<strong>pow_int</strong>(x, n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the power x^n for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow_int_e-class_method" title="pow_int_e (class method)">.<strong>pow_int_e</strong>(x, n)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the power x^n for integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi-class_method" title="psi (class method)">.<strong>psi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(x) for general x, x \ne 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1-class_method" title="psi_1 (class method)">.<strong>psi_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(x) for general x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_e-class_method" title="psi_1_e (class method)">.<strong>psi_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(x) for general x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_int-class_method" title="psi_1_int (class method)">.<strong>psi_1_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1_int_e-class_method" title="psi_1_int_e (class method)">.<strong>psi_1_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Trigamma function \psi’(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1piy-class_method" title="psi_1piy (class method)">.<strong>psi_1piy</strong>(y)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the real part of the digamma function on the line 1+i y, \Re[\psi(1 + i y)].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_1piy_e-class_method" title="psi_1piy_e (class method)">.<strong>psi_1piy_e</strong>(y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the real part of the digamma function on the line 1+i y, \Re[\psi(1 + i y)].</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_e-class_method" title="psi_e (class method)">.<strong>psi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(x) for general x, x \ne 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_int-class_method" title="psi_int (class method)">.<strong>psi_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_int_e-class_method" title="psi_int_e (class method)">.<strong>psi_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the digamma function \psi(n) for positive integer n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_n-class_method" title="psi_n (class method)">.<strong>psi_n</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the polygamma function $\psi^(n)(x)$ \psi^@(n)@(x) for $n \ge 0$ n &gt;= 0, x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#psi_n_e-class_method" title="psi_n_e (class method)">.<strong>psi_n_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the polygamma function $\psi^(n)(x)$ \psi^@(n)@(x) for $n \ge 0$ n &gt;= 0, x &gt; 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rect_to_polar-class_method" title="rect_to_polar (class method)">.<strong>rect_to_polar</strong>(x, y)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function converts the rectilinear coordinates (x,y) to polar coordinates (r,theta), such that x = r\cos(\theta), y = r\sin(\theta).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Shi-class_method" title="Shi (class method)">.<strong>Shi</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Sf.Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$ Shi(x) = \int_0^x dt \sinh(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Shi_e-class_method" title="Shi_e (class method)">.<strong>Shi_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Sf.Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$ Shi(x) = \int_0^x dt \sinh(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Si-class_method" title="Si (class method)">.<strong>Si</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Sf.Si</a></span>(x) = \int_0^x dt \sin(t)/t$ Si(x) = \int_0^x dt \sin(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#Si_e-class_method" title="Si_e (class method)">.<strong>Si_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Sf.Si</a></span>(x) = \int_0^x dt \sin(t)/t$ Si(x) = \int_0^x dt \sin(t)/t.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin-class_method" title="sin (class method)">.<strong>sin</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sine function \sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin_e-class_method" title="sin_e (class method)">.<strong>sin_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the sine function \sin(x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sin_err_e-class_method" title="sin_err_e (class method)">.<strong>sin_err_e</strong>(x, dx)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This routine computes the sine of an angle x with an associated absolute error dx, $\sin(x \pm dx)$ \sin(x \pm dx).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sinc-class_method" title="sinc (class method)">.<strong>sinc</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any value of x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sinc_e-class_method" title="sinc_e (class method)">.<strong>sinc_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any value of x.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_1-class_method" title="synchrotron_1 (class method)">.<strong>synchrotron_1</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first synchrotron function $x \int_x^\infty dt K_5/3(t)$ x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_1_e-class_method" title="synchrotron_1_e (class method)">.<strong>synchrotron_1_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the first synchrotron function $x \int_x^\infty dt K_5/3(t)$ x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_2-class_method" title="synchrotron_2 (class method)">.<strong>synchrotron_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second synchrotron function $x K_2/3(x)$ x K_@2/3@(x) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchrotron_2_e-class_method" title="synchrotron_2_e (class method)">.<strong>synchrotron_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the second synchrotron function $x K_2/3(x)$ x K_@2/3@(x) for $x \ge 0$ x &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#taylorcoeff-class_method" title="taylorcoeff (class method)">.<strong>taylorcoeff</strong>(n, x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Taylor coefficient x^n / n! for $x \ge 0$ x &gt;= 0, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#taylorcoeff_e-class_method" title="taylorcoeff_e (class method)">.<strong>taylorcoeff_e</strong>(n, x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Taylor coefficient x^n / n! for $x \ge 0$ x &gt;= 0, $n \ge 0$ n &gt;= 0.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_2-class_method" title="transport_2 (class method)">.<strong>transport_2</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(2,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_2_e-class_method" title="transport_2_e (class method)">.<strong>transport_2_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(2,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_3-class_method" title="transport_3 (class method)">.<strong>transport_3</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(3,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_3_e-class_method" title="transport_3_e (class method)">.<strong>transport_3_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(3,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_4-class_method" title="transport_4 (class method)">.<strong>transport_4</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(4,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_4_e-class_method" title="transport_4_e (class method)">.<strong>transport_4_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(4,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_5-class_method" title="transport_5 (class method)">.<strong>transport_5</strong>(x)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(5,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transport_5_e-class_method" title="transport_5_e (class method)">.<strong>transport_5_e</strong>(x)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the transport function J(5,x).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta-class_method" title="zeta (class method)">.<strong>zeta</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(s) for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_e-class_method" title="zeta_e (class method)">.<strong>zeta_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(s) for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_int-class_method" title="zeta_int (class method)">.<strong>zeta_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(n) for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zeta_int_e-class_method" title="zeta_int_e (class method)">.<strong>zeta_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute the Riemann zeta function \zeta(n) for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1-class_method" title="zetam1 (class method)">.<strong>zetam1</strong>(s)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(s) - 1 for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_e-class_method" title="zetam1_e (class method)">.<strong>zetam1_e</strong>(s)  &#x21d2; [Numo::DFloat, Numo::DFloat, Numo::Int] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(s) - 1 for arbitrary s, s \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_int-class_method" title="zetam1_int (class method)">.<strong>zetam1_int</strong>(n)  &#x21d2; DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(n) - 1 for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zetam1_int_e-class_method" title="zetam1_int_e (class method)">.<strong>zetam1_int_e</strong>(n)  &#x21d2; [Float, Float, Integer] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These routines compute \zeta(n) - 1 for integer n, n \ne 1.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="airy_Ai-class_method">
  
    .<strong>airy_Ai</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Ai(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 82</span>

static VALUE
sf_s_airy_Ai(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv-class_method">
  
    .<strong>airy_Ai_deriv</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Ai’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 554</span>

static VALUE
sf_s_airy_Ai_deriv(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_e-class_method">
  
    .<strong>airy_Ai_deriv_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Ai’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 609</span>

static VALUE
sf_s_airy_Ai_deriv_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_scaled-class_method">
  
    .<strong>airy_Ai_deriv_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_A(x) Ai’(x).
For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 788</span>

static VALUE
sf_s_airy_Ai_deriv_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_deriv_scaled_e-class_method">
  
    .<strong>airy_Ai_deriv_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_A(x) Ai’(x).
For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 845</span>

static VALUE
sf_s_airy_Ai_deriv_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_deriv_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_e-class_method">
  
    .<strong>airy_Ai_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Ai(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 137</span>

static VALUE
sf_s_airy_Ai_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_scaled-class_method">
  
    .<strong>airy_Ai_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)),
and is 1
for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 317</span>

static VALUE
sf_s_airy_Ai_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Ai_scaled_e-class_method">
  
    .<strong>airy_Ai_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_A(x) Ai(x).  For x&gt;0 the scaling factor S_A(x) is $\exp(+(2/3) x^3/2)$
\exp(+(2/3) x^(3/2)),
and is 1
for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 375</span>

static VALUE
sf_s_airy_Ai_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Ai_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi-class_method">
  
    .<strong>airy_Bi</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Bi(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 198</span>

static VALUE
sf_s_airy_Bi(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv-class_method">
  
    .<strong>airy_Bi_deriv</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Bi’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 670</span>

static VALUE
sf_s_airy_Bi_deriv(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_e-class_method">
  
    .<strong>airy_Bi_deriv_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function derivative Bi’(x) with
an accuracy specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 725</span>

static VALUE
sf_s_airy_Bi_deriv_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_scaled-class_method">
  
    .<strong>airy_Bi_deriv_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_B(x) Bi’(x).
For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 908</span>

static VALUE
sf_s_airy_Bi_deriv_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_deriv_scaled_e-class_method">
  
    .<strong>airy_Bi_deriv_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled Airy function derivative
S_B(x) Bi’(x).
For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 965</span>

static VALUE
sf_s_airy_Bi_deriv_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_deriv_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_e-class_method">
  
    .<strong>airy_Bi_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Airy function Bi(x) with an accuracy
specified by mode.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 253</span>

static VALUE
sf_s_airy_Bi_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_scaled-class_method">
  
    .<strong>airy_Bi_scaled</strong>(x[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 437</span>

static VALUE
sf_s_airy_Bi_scaled(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_Bi_scaled_e-class_method">
  
    .<strong>airy_Bi_scaled_e</strong>(x, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute a scaled version of the Airy function
S_B(x) Bi(x).  For x&gt;0 the scaling factor S_B(x) is $\exp(-(2/3) x^3/2)$
exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 493</span>

static VALUE
sf_s_airy_Bi_scaled_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_Bi_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai-class_method">
  
    .<strong>airy_zero_Ai</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Ai(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1023
1024
1025
1026
1027
1028
1029
1030
1031</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1023</span>

static VALUE
sf_s_airy_zero_Ai(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_deriv-class_method">
  
    .<strong>airy_zero_Ai_deriv</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Ai’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1201
1202
1203
1204
1205
1206
1207
1208
1209</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1201</span>

static VALUE
sf_s_airy_zero_Ai_deriv(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_deriv_e-class_method">
  
    .<strong>airy_zero_Ai_deriv_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Ai’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1243</span>

static VALUE
sf_s_airy_zero_Ai_deriv_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Ai_e-class_method">
  
    .<strong>airy_zero_Ai_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Ai(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1065</span>

static VALUE
sf_s_airy_zero_Ai_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Ai_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi-class_method">
  
    .<strong>airy_zero_Bi</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Bi(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1112
1113
1114
1115
1116
1117
1118
1119
1120</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1112</span>

static VALUE
sf_s_airy_zero_Bi(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_deriv-class_method">
  
    .<strong>airy_zero_Bi_deriv</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Bi’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1290
1291
1292
1293
1294
1295
1296
1297
1298</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1290</span>

static VALUE
sf_s_airy_zero_Bi_deriv(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_deriv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_deriv_e-class_method">
  
    .<strong>airy_zero_Bi_deriv_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function derivative Bi’(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1332</span>

static VALUE
sf_s_airy_zero_Bi_deriv_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_deriv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="airy_zero_Bi_e-class_method">
  
    .<strong>airy_zero_Bi_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th zero of the Airy
function Bi(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1154
1155
1156
1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1154</span>

static VALUE
sf_s_airy_zero_Bi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_airy_zero_Bi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="angle_restrict_pos-class_method">
  
    .<strong>angle_restrict_pos</strong>(theta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines force the angle theta to lie in the range [0,
2\pi).</p>

<p>Note that the mathematical value of 2\pi is slightly greater
than 2<em>M_PI, so the machine number 2</em>M_PI is included in
the range.</p>

<p>Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24204
24205
24206
24207
24208
24209
24210
24211
24212</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24204</span>

static VALUE
sf_s_angle_restrict_pos(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_angle_restrict_pos, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="angle_restrict_symm-class_method">
  
    .<strong>angle_restrict_symm</strong>(theta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines force the angle theta to lie in the range
(-\pi,\pi].</p>

<p>Note that the mathematical value of \pi is slightly greater
than M_PI, so the machine numbers M_PI and -M_PI
are included in the range.
Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24160
24161
24162
24163
24164
24165
24166
24167
24168</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24160</span>

static VALUE
sf_s_angle_restrict_symm(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_angle_restrict_symm, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="atanint-class_method">
  
    .<strong>atanint</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$
AtanInt(x) = \int_0^x dt \arctan(t)/t.
Domain:
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12390
12391
12392
12393
12394
12395
12396
12397
12398</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12390</span>

static VALUE
sf_s_atanint(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_atanint, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="atanint_e-class_method">
  
    .<strong>atanint_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Arctangent integral, which is defined as $\hboxAtanInt(x) = \int_0^x dt \arctan(t)/t$
AtanInt(x) = \int_0^x dt \arctan(t)/t.
Domain:
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12434
12435
12436
12437
12438
12439
12440
12441
12442
12443
12444
12445
12446
12447
12448
12449
12450</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12434</span>

static VALUE
sf_s_atanint_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_atanint_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0-class_method">
  
    .<strong>bessel_I0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2100
2101
2102
2103
2104
2105
2106
2107
2108</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2100</span>

static VALUE
sf_s_bessel_I0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_e-class_method">
  
    .<strong>bessel_I0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, I_0(x).
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2143</span>

static VALUE
sf_s_bessel_I0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_scaled-class_method">
  
    .<strong>bessel_I0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2463
2464
2465
2466
2467
2468
2469
2470
2471</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2463</span>

static VALUE
sf_s_bessel_I0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i0_scaled-class_method">
  
    .<strong>bessel_i0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4533
4534
4535
4536
4537
4538
4539
4540
4541</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4533</span>

static VALUE
sf_s_bessel_i0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I0_scaled_e-class_method">
  
    .<strong>bessel_I0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order \exp(-|x|) I_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2506
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2506</span>

static VALUE
sf_s_bessel_I0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i0_scaled_e-class_method">
  
    .<strong>bessel_i0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, \exp(-|x|) i_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4576
4577
4578
4579
4580
4581
4582
4583
4584
4585
4586
4587
4588
4589
4590
4591
4592</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4576</span>

static VALUE
sf_s_bessel_i0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1-class_method">
  
    .<strong>bessel_I1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2190
2191
2192
2193
2194
2195
2196
2197
2198</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2190</span>

static VALUE
sf_s_bessel_I1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_e-class_method">
  
    .<strong>bessel_I1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of first order, I_1(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2233</span>

static VALUE
sf_s_bessel_I1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_scaled-class_method">
  
    .<strong>bessel_I1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2553
2554
2555
2556
2557
2558
2559
2560
2561</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2553</span>

static VALUE
sf_s_bessel_I1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i1_scaled-class_method">
  
    .<strong>bessel_i1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4623
4624
4625
4626
4627
4628
4629
4630
4631</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4623</span>

static VALUE
sf_s_bessel_i1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_I1_scaled_e-class_method">
  
    .<strong>bessel_I1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of first order \exp(-|x|) I_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2596
2597
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2596</span>

static VALUE
sf_s_bessel_I1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_I1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i1_scaled_e-class_method">
  
    .<strong>bessel_i1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of first order, \exp(-|x|) i_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4666
4667
4668
4669
4670
4671
4672
4673
4674
4675
4676
4677
4678
4679
4680
4681
4682</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4666</span>

static VALUE
sf_s_bessel_i1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i2_scaled-class_method">
  
    .<strong>bessel_i2_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4713
4714
4715
4716
4717
4718
4719
4720
4721</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4713</span>

static VALUE
sf_s_bessel_i2_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i2_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_i2_scaled_e-class_method">
  
    .<strong>bessel_i2_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of second order,  \exp(-|x|) i_2(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4756
4757
4758
4759
4760
4761
4762
4763
4764
4765
4766
4767
4768
4769
4770
4771
4772</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4756</span>

static VALUE
sf_s_bessel_i2_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_i2_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled-class_method">
  
    .<strong>bessel_il_scaled</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of order l,  \exp(-|x|) i_l(x)
Domain: l &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4807
4808
4809
4810
4811
4812
4813
4814
4815
4816
4817
4818</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4807</span>

static VALUE
sf_s_bessel_il_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled_array-class_method">
  
    .<strong>bessel_il_scaled_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled regular modified
spherical Bessel functions \exp(-|x|) i_l(x) for l from
0 to lmax inclusive for $lmax \geq 0$
lmax &gt;= 0, storing the results in
the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4925
4926
4927
4928
4929
4930
4931
4932
4933
4934
4935
4936
4937
4938
4939
4940
4941
4942
4943
4944
4945
4946
4947
4948</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4925</span>

static VALUE
sf_s_bessel_il_scaled_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_il_scaled_e-class_method">
  
    .<strong>bessel_il_scaled_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified spherical Bessel
function of order l,  \exp(-|x|) i_l(x)
Domain: l &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4859
4860
4861
4862
4863
4864
4865
4866
4867
4868
4869
4870
4871
4872
4873
4874
4875
4876
4877
4878</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4859</span>

static VALUE
sf_s_bessel_il_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_il_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In-class_method">
  
    .<strong>bessel_In</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of order n, I_n(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2283</span>

static VALUE
sf_s_bessel_In(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_array-class_method">
  
    .<strong>bessel_In_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular modified cylindrical
Bessel functions I_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array.  The start of the range nmin must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: nmin &gt;=0, nmax &gt;= nmin
Conditions: n=nmin,…,nmax, nmin &gt;=0, nmax &gt;= nmin
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2404
2405
2406
2407
2408
2409
2410
2411
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2404</span>

static VALUE
sf_s_bessel_In_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_e-class_method">
  
    .<strong>bessel_In_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified cylindrical Bessel function
of order n, I_n(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2334</span>

static VALUE
sf_s_bessel_In_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled-class_method">
  
    .<strong>bessel_In_scaled</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of order n, \exp(-|x|) I_n(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2646
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2646</span>

static VALUE
sf_s_bessel_In_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled_array-class_method">
  
    .<strong>bessel_In_scaled_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled regular cylindrical
Bessel functions \exp(-|x|) I_n(x) for n from
nmin to nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: nmin &gt;=0, nmax &gt;= nmin
Conditions:  n=nmin,…,nmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2767</span>

static VALUE
sf_s_bessel_In_scaled_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_In_scaled_e-class_method">
  
    .<strong>bessel_In_scaled_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified cylindrical Bessel
function of order n, \exp(-|x|) I_n(x)
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2697</span>

static VALUE
sf_s_bessel_In_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_In_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu-class_method">
  
    .<strong>bessel_Inu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5628
5629
5630
5631
5632
5633
5634
5635
5636</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5628</span>

static VALUE
sf_s_bessel_Inu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_e-class_method">
  
    .<strong>bessel_Inu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular modified Bessel function of
fractional order \nu, I_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5676
5677
5678
5679
5680
5681
5682
5683
5684
5685
5686
5687
5688
5689
5690
5691
5692</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5676</span>

static VALUE
sf_s_bessel_Inu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_scaled-class_method">
  
    .<strong>bessel_Inu_scaled</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&gt;0,
\nu&gt;0.
\exp(-|x|) I_@\nu@(x)
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5729
5730
5731
5732
5733
5734
5735
5736
5737</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5729</span>

static VALUE
sf_s_bessel_Inu_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_scaled, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Inu_scaled_e-class_method">
  
    .<strong>bessel_Inu_scaled_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled regular modified Bessel function of
fractional order \nu, \exp(-|x|)I_\nu(x) for x&gt;0,
\nu&gt;0.
\exp(-|x|) I_@\nu@(x)
Domain: x &gt;= 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5778
5779
5780
5781
5782
5783
5784
5785
5786
5787
5788
5789
5790
5791
5792
5793
5794</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5778</span>

static VALUE
sf_s_bessel_Inu_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Inu_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J0-class_method">
  
    .<strong>bessel_J0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1379
1380
1381
1382
1383
1384
1385
1386
1387</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1379</span>

static VALUE
sf_s_bessel_J0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j0-class_method">
  
    .<strong>bessel_j0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3566
3567
3568
3569
3570
3571
3572
3573
3574</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3566</span>

static VALUE
sf_s_bessel_j0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J0_e-class_method">
  
    .<strong>bessel_J0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of zeroth
order, J_0(x).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1422</span>

static VALUE
sf_s_bessel_J0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j0_e-class_method">
  
    .<strong>bessel_j0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of zeroth
order, j_0(x) = \sin(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3609</span>

static VALUE
sf_s_bessel_j0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J1-class_method">
  
    .<strong>bessel_J1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1469
1470
1471
1472
1473
1474
1475
1476
1477</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1469</span>

static VALUE
sf_s_bessel_J1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j1-class_method">
  
    .<strong>bessel_j1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3656
3657
3658
3659
3660
3661
3662
3663
3664</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3656</span>

static VALUE
sf_s_bessel_j1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_J1_e-class_method">
  
    .<strong>bessel_J1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of first
order, J_1(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1512</span>

static VALUE
sf_s_bessel_J1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_J1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j1_e-class_method">
  
    .<strong>bessel_j1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of first
order, j_1(x) = (\sin(x)/x - \cos(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3699
3700
3701
3702
3703
3704
3705
3706
3707
3708
3709
3710
3711
3712
3713
3714
3715</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3699</span>

static VALUE
sf_s_bessel_j1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j2-class_method">
  
    .<strong>bessel_j2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3746
3747
3748
3749
3750
3751
3752
3753
3754</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3746</span>

static VALUE
sf_s_bessel_j2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_j2_e-class_method">
  
    .<strong>bessel_j2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of second
order, j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3789
3790
3791
3792
3793
3794
3795
3796
3797
3798
3799
3800
3801
3802
3803
3804
3805</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3789</span>

static VALUE
sf_s_bessel_j2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_j2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl-class_method">
  
    .<strong>bessel_jl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of
order l, j_l(x), for $l \geq 0$
l &gt;= 0 and $x \geq 0$
x &gt;= 0.
Domain: l &gt;= 0, x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3842
3843
3844
3845
3846
3847
3848
3849
3850
3851
3852
3853</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3842</span>

static VALUE
sf_s_bessel_jl(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_array-class_method">
  
    .<strong>bessel_jl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular spherical Bessel
functions j_l(x) for l from 0 to lmax
inclusive  for $lmax \geq 0$
lmax &gt;= 0 and $x \geq 0$
x &gt;= 0, storing the results in the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3962
3963
3964
3965
3966
3967
3968
3969
3970
3971
3972
3973
3974
3975
3976
3977
3978
3979
3980
3981
3982
3983
3984
3985</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3962</span>

static VALUE
sf_s_bessel_jl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_e-class_method">
  
    .<strong>bessel_jl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular spherical Bessel function of
order l, j_l(x), for $l \geq 0$
l &gt;= 0 and $x \geq 0$
x &gt;= 0.
Domain: l &gt;= 0, x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3896
3897
3898
3899
3900
3901
3902
3903
3904
3905
3906
3907
3908
3909
3910
3911
3912
3913
3914
3915</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3896</span>

static VALUE
sf_s_bessel_jl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_jl_steed_array-class_method">
  
    .<strong>bessel_jl_steed_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine uses Steed’s method to compute the values of the regular
spherical Bessel functions j_l(x) for l from 0 to
lmax inclusive for $lmax \geq 0$
lmax &gt;= 0 and $x \geq 0$
x &gt;= 0, storing the results in the array
result_array.
The Steed/Barnett algorithm is described in Comp. Phys. Comm. 21,
297 (1981).  Steed’s method is more stable than the
recurrence used in the other functions but is also slower.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4034
4035
4036
4037
4038
4039
4040
4041
4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4034</span>

static VALUE
sf_s_bessel_jl_steed_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_jl_steed_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn-class_method">
  
    .<strong>bessel_Jn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
order n, J_n(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1562</span>

static VALUE
sf_s_bessel_Jn(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn_array-class_method">
  
    .<strong>bessel_Jn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the regular cylindrical Bessel
functions J_n(x) for n from nmin to nmax
inclusive, storing the results in the array result_array.  The
values are computed using recurrence relations for efficiency, and
therefore may differ slightly from the exact values.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1680</span>

static VALUE
sf_s_bessel_Jn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jn_e-class_method">
  
    .<strong>bessel_Jn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
order n, J_n(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1613</span>

static VALUE
sf_s_bessel_Jn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jnu-class_method">
  
    .<strong>bessel_Jnu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5434
5435
5436
5437
5438
5439
5440
5441
5442</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5434</span>

static VALUE
sf_s_bessel_Jnu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Jnu_e-class_method">
  
    .<strong>bessel_Jnu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular cylindrical Bessel function of
fractional order \nu, J_\nu(x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5480
5481
5482
5483
5484
5485
5486
5487
5488
5489
5490
5491
5492
5493
5494
5495
5496</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5480</span>

static VALUE
sf_s_bessel_Jnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Jnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0-class_method">
  
    .<strong>bessel_K0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2827
2828
2829
2830
2831
2832
2833
2834
2835</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2827</span>

static VALUE
sf_s_bessel_K0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_e-class_method">
  
    .<strong>bessel_K0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, K_0(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2871
2872
2873
2874
2875
2876
2877
2878
2879
2880
2881
2882
2883
2884
2885
2886
2887</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2871</span>

static VALUE
sf_s_bessel_K0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_scaled-class_method">
  
    .<strong>bessel_K0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3197
3198
3199
3200
3201
3202
3203
3204
3205</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3197</span>

static VALUE
sf_s_bessel_K0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k0_scaled-class_method">
  
    .<strong>bessel_k0_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4980
4981
4982
4983
4984
4985
4986
4987
4988</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4980</span>

static VALUE
sf_s_bessel_k0_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k0_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K0_scaled_e-class_method">
  
    .<strong>bessel_K0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order \exp(x) K_0(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3241</span>

static VALUE
sf_s_bessel_K0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k0_scaled_e-class_method">
  
    .<strong>bessel_k0_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, \exp(x) k_0(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5024
5025
5026
5027
5028
5029
5030
5031
5032
5033
5034
5035
5036
5037
5038
5039
5040</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5024</span>

static VALUE
sf_s_bessel_k0_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k0_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1-class_method">
  
    .<strong>bessel_K1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2919
2920
2921
2922
2923
2924
2925
2926
2927</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2919</span>

static VALUE
sf_s_bessel_K1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_e-class_method">
  
    .<strong>bessel_K1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of first order, K_1(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2963
2964
2965
2966
2967
2968
2969
2970
2971
2972
2973
2974
2975
2976
2977
2978
2979</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2963</span>

static VALUE
sf_s_bessel_K1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_scaled-class_method">
  
    .<strong>bessel_K1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3289
3290
3291
3292
3293
3294
3295
3296
3297</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3289</span>

static VALUE
sf_s_bessel_K1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k1_scaled-class_method">
  
    .<strong>bessel_k1_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5072
5073
5074
5075
5076
5077
5078
5079
5080</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5072</span>

static VALUE
sf_s_bessel_k1_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k1_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_K1_scaled_e-class_method">
  
    .<strong>bessel_K1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order \exp(x) K_1(x) for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3333
3334
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3333</span>

static VALUE
sf_s_bessel_K1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_K1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k1_scaled_e-class_method">
  
    .<strong>bessel_k1_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of first order, \exp(x) k_1(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5116
5117
5118
5119
5120
5121
5122
5123
5124
5125
5126
5127
5128
5129
5130
5131
5132</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5116</span>

static VALUE
sf_s_bessel_k1_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k1_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k2_scaled-class_method">
  
    .<strong>bessel_k2_scaled</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5164
5165
5166
5167
5168
5169
5170
5171
5172</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5164</span>

static VALUE
sf_s_bessel_k2_scaled(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k2_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_k2_scaled_e-class_method">
  
    .<strong>bessel_k2_scaled_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of second order, \exp(x) k_2(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5208
5209
5210
5211
5212
5213
5214
5215
5216
5217
5218
5219
5220
5221
5222
5223
5224</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5208</span>

static VALUE
sf_s_bessel_k2_scaled_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_k2_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled-class_method">
  
    .<strong>bessel_kl_scaled</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of order l, \exp(x) k_l(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5259
5260
5261
5262
5263
5264
5265
5266
5267
5268
5269
5270</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5259</span>

static VALUE
sf_s_bessel_kl_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled_array-class_method">
  
    .<strong>bessel_kl_scaled_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled irregular modified
spherical Bessel functions \exp(x) k_l(x) for l from
0 to lmax inclusive for $lmax \geq 0$
lmax &gt;= 0 and x&gt;0, storing the results in
the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5377
5378
5379
5380
5381
5382
5383
5384
5385
5386
5387
5388
5389
5390
5391
5392
5393
5394
5395
5396
5397
5398
5399
5400</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5377</span>

static VALUE
sf_s_bessel_kl_scaled_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_kl_scaled_e-class_method">
  
    .<strong>bessel_kl_scaled_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified spherical Bessel
function of order l, \exp(x) k_l(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5311
5312
5313
5314
5315
5316
5317
5318
5319
5320
5321
5322
5323
5324
5325
5326
5327
5328
5329
5330</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5311</span>

static VALUE
sf_s_bessel_kl_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_kl_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn-class_method">
  
    .<strong>bessel_Kn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of order n, K_n(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3014
3015
3016
3017
3018
3019
3020
3021
3022
3023
3024
3025</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3014</span>

static VALUE
sf_s_bessel_Kn(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_array-class_method">
  
    .<strong>bessel_Kn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular modified cylindrical
Bessel functions K_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero. The domain of the function is x&gt;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
Conditions: n=nmin,…,nmax
Domain: x &gt; 0.0, nmin&gt;=0, nmax &gt;= nmin
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3137
3138
3139
3140
3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3137</span>

static VALUE
sf_s_bessel_Kn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_e-class_method">
  
    .<strong>bessel_Kn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified cylindrical Bessel
function of order n, K_n(x), for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3066
3067
3068
3069
3070
3071
3072
3073
3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3066</span>

static VALUE
sf_s_bessel_Kn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled-class_method">
  
    .<strong>bessel_Kn_scaled</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of order n, \exp(x) K_n(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3384</span>

static VALUE
sf_s_bessel_Kn_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled_array-class_method">
  
    .<strong>bessel_Kn_scaled_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the scaled irregular cylindrical
Bessel functions \exp(x) K_n(x) for n from nmin to
nmax inclusive, storing the results in the array
result_array. The start of the range nmin must be positive
or zero.  The domain of the function is x&gt;0. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.
Domain: x &gt; 0.0, nmin &gt;=0, nmax &gt;= nmin
Conditions: n=nmin,…,nmax
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3507
3508
3509
3510
3511
3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530
3531
3532
3533
3534
3535</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3507</span>

static VALUE
sf_s_bessel_Kn_scaled_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Kn_scaled_e-class_method">
  
    .<strong>bessel_Kn_scaled_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified cylindrical Bessel
function of order n, \exp(x) K_n(x), for x&gt;0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 3436</span>

static VALUE
sf_s_bessel_Kn_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Kn_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu-class_method">
  
    .<strong>bessel_Knu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5830
5831
5832
5833
5834
5835
5836
5837
5838</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5830</span>

static VALUE
sf_s_bessel_Knu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_e-class_method">
  
    .<strong>bessel_Knu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular modified Bessel function of
fractional order \nu, K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5878
5879
5880
5881
5882
5883
5884
5885
5886
5887
5888
5889
5890
5891
5892
5893
5894</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5878</span>

static VALUE
sf_s_bessel_Knu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_scaled-class_method">
  
    .<strong>bessel_Knu_scaled</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6030
6031
6032
6033
6034
6035
6036
6037
6038</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6030</span>

static VALUE
sf_s_bessel_Knu_scaled(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_scaled, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Knu_scaled_e-class_method">
  
    .<strong>bessel_Knu_scaled_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the scaled irregular modified Bessel function of
fractional order \nu, \exp(+|x|) K_\nu(x) for x&gt;0,
\nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6078
6079
6080
6081
6082
6083
6084
6085
6086
6087
6088
6089
6090
6091
6092
6093
6094</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6078</span>

static VALUE
sf_s_bessel_Knu_scaled_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Knu_scaled_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_lnKnu-class_method">
  
    .<strong>bessel_lnKnu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&gt;0, \nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5930
5931
5932
5933
5934
5935
5936
5937
5938</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5930</span>

static VALUE
sf_s_bessel_lnKnu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_lnKnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_lnKnu_e-class_method">
  
    .<strong>bessel_lnKnu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order \nu, \ln(K_\nu(x)) for
x&gt;0, \nu&gt;0.
Domain: x &gt; 0, nu &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5978
5979
5980
5981
5982
5983
5984
5985
5986
5987
5988
5989
5990
5991
5992
5993
5994</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5978</span>

static VALUE
sf_s_bessel_lnKnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_lnKnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y0-class_method">
  
    .<strong>bessel_Y0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1739
1740
1741
1742
1743
1744
1745
1746
1747</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1739</span>

static VALUE
sf_s_bessel_Y0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y0-class_method">
  
    .<strong>bessel_y0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4088
4089
4090
4091
4092
4093
4094
4095
4096</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4088</span>

static VALUE
sf_s_bessel_y0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y0_e-class_method">
  
    .<strong>bessel_Y0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of zeroth
order, Y_0(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1782</span>

static VALUE
sf_s_bessel_Y0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y0_e-class_method">
  
    .<strong>bessel_y0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of zeroth
order, y_0(x) = -\cos(x)/x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4131
4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142
4143
4144
4145
4146
4147</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4131</span>

static VALUE
sf_s_bessel_y0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y1-class_method">
  
    .<strong>bessel_Y1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1829
1830
1831
1832
1833
1834
1835
1836
1837</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1829</span>

static VALUE
sf_s_bessel_Y1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y1-class_method">
  
    .<strong>bessel_y1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4178
4179
4180
4181
4182
4183
4184
4185
4186</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4178</span>

static VALUE
sf_s_bessel_y1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Y1_e-class_method">
  
    .<strong>bessel_Y1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of first
order, Y_1(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1872</span>

static VALUE
sf_s_bessel_Y1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Y1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y1_e-class_method">
  
    .<strong>bessel_y1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of first
order, y_1(x) = -(\cos(x)/x + \sin(x))/x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4221
4222
4223
4224
4225
4226
4227
4228
4229
4230
4231
4232
4233
4234
4235
4236
4237</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4221</span>

static VALUE
sf_s_bessel_y1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y2-class_method">
  
    .<strong>bessel_y2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4268
4269
4270
4271
4272
4273
4274
4275
4276</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4268</span>

static VALUE
sf_s_bessel_y2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_y2_e-class_method">
  
    .<strong>bessel_y2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of second
order, y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4311
4312
4313
4314
4315
4316
4317
4318
4319
4320
4321
4322
4323
4324
4325
4326
4327</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4311</span>

static VALUE
sf_s_bessel_y2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_y2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl-class_method">
  
    .<strong>bessel_yl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of
order l, y_l(x), for $l \geq 0$
l &gt;= 0.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4362
4363
4364
4365
4366
4367
4368
4369
4370
4371
4372
4373</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4362</span>

static VALUE
sf_s_bessel_yl(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl_array-class_method">
  
    .<strong>bessel_yl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular spherical Bessel
functions y_l(x) for l from 0 to lmax
inclusive  for $lmax \geq 0$
lmax &gt;= 0, storing the results in the array result_array.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
Domain: lmax &gt;= 0
Conditions: l=0,1,…,lmax
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4479
4480
4481
4482
4483
4484
4485
4486
4487
4488
4489
4490
4491
4492
4493
4494
4495
4496
4497
4498
4499
4500
4501
4502</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4479</span>

static VALUE
sf_s_bessel_yl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be lmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_yl_e-class_method">
  
    .<strong>bessel_yl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular spherical Bessel function of
order l, y_l(x), for $l \geq 0$
l &gt;= 0.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4414
4415
4416
4417
4418
4419
4420
4421
4422
4423
4424
4425
4426
4427
4428
4429
4430
4431
4432
4433</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 4414</span>

static VALUE
sf_s_bessel_yl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_yl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn-class_method">
  
    .<strong>bessel_Yn</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
order n, Y_n(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1922</span>

static VALUE
sf_s_bessel_Yn(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn_array-class_method">
  
    .<strong>bessel_Yn_array</strong>(nmin, nmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the values of the irregular cylindrical Bessel
functions Y_n(x) for n from nmin to nmax
inclusive, storing the results in the array result_array.  The
domain of the function is x&gt;0.  The values are computed using
recurrence relations for efficiency, and therefore may differ slightly
from the exact values.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmin</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 2041</span>

static VALUE
sf_s_bessel_Yn_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //nmin
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //nmax
    
    if (c0&lt;0 || c1&lt;0 || c0&gt;c1) {
        rb_raise(rb_eArgError,&quot;should be nmin&gt;=0 &amp;&amp; nmax&gt;=0 &amp;&amp; nmin&lt;=nmax&quot;);
    }
    shape[0] = c1-c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Yn_e-class_method">
  
    .<strong>bessel_Yn_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
order n, Y_n(x), for x&gt;0.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 1973</span>

static VALUE
sf_s_bessel_Yn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Yn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Ynu-class_method">
  
    .<strong>bessel_Ynu</strong>(nu, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5530
5531
5532
5533
5534
5535
5536
5537
5538</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5530</span>

static VALUE
sf_s_bessel_Ynu(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Ynu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_Ynu_e-class_method">
  
    .<strong>bessel_Ynu_e</strong>(nu, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular cylindrical Bessel function of
fractional order \nu, Y_\nu(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


5576
5577
5578
5579
5580
5581
5582
5583
5584
5585
5586
5587
5588
5589
5590
5591
5592</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 5576</span>

static VALUE
sf_s_bessel_Ynu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_Ynu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J0-class_method">
  
    .<strong>bessel_zero_J0</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_0(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6126
6127
6128
6129
6130
6131
6132
6133
6134</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6126</span>

static VALUE
sf_s_bessel_zero_J0(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J0_e-class_method">
  
    .<strong>bessel_zero_J0_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_0(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6169
6170
6171
6172
6173
6174
6175
6176
6177
6178
6179
6180
6181
6182
6183
6184
6185</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6169</span>

static VALUE
sf_s_bessel_zero_J0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J1-class_method">
  
    .<strong>bessel_zero_J1</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_1(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6217
6218
6219
6220
6221
6222
6223
6224
6225</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6217</span>

static VALUE
sf_s_bessel_zero_J1(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_J1_e-class_method">
  
    .<strong>bessel_zero_J1_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_1(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6260
6261
6262
6263
6264
6265
6266
6267
6268
6269
6270
6271
6272
6273
6274
6275
6276</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6260</span>

static VALUE
sf_s_bessel_zero_J1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_J1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_Jnu-class_method">
  
    .<strong>bessel_zero_Jnu</strong>(nu, s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of nu.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6312
6313
6314
6315
6316
6317
6318
6319
6320</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6312</span>

static VALUE
sf_s_bessel_zero_Jnu(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_DFloat_f_DFloat_UInt.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cUInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_Jnu, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bessel_zero_Jnu_e-class_method">
  
    .<strong>bessel_zero_Jnu_e</strong>(nu, s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the location of the s-th positive zero of
the Bessel function J_\nu(x).  The current implementation does not
support negative values of nu.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nu</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6359
6360
6361
6362
6363
6364
6365
6366
6367
6368
6369
6370
6371
6372
6373
6374
6375</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6359</span>

static VALUE
sf_s_bessel_zero_Jnu_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_bessel_zero_Jnu_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta-class_method">
  
    .<strong>beta</strong>(a, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not
being negative integers.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15196
15197
15198
15199
15200
15201
15202
15203
15204</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15196</span>

static VALUE
sf_s_beta(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_beta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_e-class_method">
  
    .<strong>beta_e</strong>(a, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Beta Function, B(a,b) =
\Gamma(a)\Gamma(b)/\Gamma(a+b) subject to a and b not
being negative integers.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15243
15244
15245
15246
15247
15248
15249
15250
15251
15252
15253
15254
15255
15256
15257
15258
15259</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15243</span>

static VALUE
sf_s_beta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_beta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_inc-class_method">
  
    .<strong>beta_inc</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Beta function
I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$
B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt
for $0 \le x \le 1$
0 &lt;= x &lt;= 1.   For a &gt; 0, b &gt; 0 the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation $I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)$
I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15399
15400
15401
15402
15403
15404
15405
15406
15407</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15399</span>

static VALUE
sf_s_beta_inc(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_beta_inc, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="beta_inc_e-class_method">
  
    .<strong>beta_inc_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Beta function
I_x(a,b)=B_x(a,b)/B(a,b) where $B_x(a,b) = \int_0^x t^a-1 (1-t)^b-1 dt$
B_x(a,b) = \int_0^x t^@a-1@ (1-t)^@b-1@ dt
for $0 \le x \le 1$
0 &lt;= x &lt;= 1.   For a &gt; 0, b &gt; 0 the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation $I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)$
I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15453
15454
15455
15456
15457
15458
15459
15460
15461
15462
15463
15464
15465
15466
15467
15468
15469</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15453</span>

static VALUE
sf_s_beta_inc_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_beta_inc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Chi-class_method">
  
    .<strong>Chi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$
Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] ,
where \gamma_E is the Euler constant (available as the macro M_EULER).
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12023
12024
12025
12026
12027
12028
12029
12030
12031</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12023</span>

static VALUE
sf_s_Chi(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Chi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Chi_e-class_method">
  
    .<strong>Chi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Chi-class_method" title="Numo::GSL::Sf.Chi (method)">Chi</a></span>(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t]$
Chi(x) := \Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t] ,
where \gamma_E is the Euler constant (available as the macro M_EULER).
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12068
12069
12070
12071
12072
12073
12074
12075
12076
12077
12078
12079
12080
12081
12082
12083
12084</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12068</span>

static VALUE
sf_s_Chi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Chi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="choose-class_method">
  
    .<strong>choose</strong>(n, m)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the combinatorial factor n choose m
= n!/(m!(n-m)!)
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14213
14214
14215
14216
14217
14218
14219
14220
14221
14222
14223
14224
14225
14226
14227
14228
14229</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14213</span>

static VALUE
sf_s_choose(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_choose,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="choose_e-class_method">
  
    .<strong>choose_e</strong>(n, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the combinatorial factor n choose m
= n!/(m!(n-m)!)
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14267
14268
14269
14270
14271
14272
14273
14274
14275
14276
14277
14278
14279
14280
14281
14282
14283</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14267</span>

static VALUE
sf_s_choose_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_choose_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Ci-class_method">
  
    .<strong>Ci</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$
Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12298
12299
12300
12301
12302
12303
12304
12305
12306</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12298</span>

static VALUE
sf_s_Ci(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Ci, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Ci_e-class_method">
  
    .<strong>Ci_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Cosine integral $\hbox<span class='object_link'><a href="#Ci-class_method" title="Numo::GSL::Sf.Ci (method)">Ci</a></span>(x) = -\int_x^\infty dt \cos(t)/t$
Ci(x) = -\int_x^\infty dt \cos(t)/t for x &gt; 0.
Domain: x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12342
12343
12344
12345
12346
12347
12348
12349
12350
12351
12352
12353
12354
12355
12356
12357
12358</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12342</span>

static VALUE
sf_s_Ci_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Ci_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="clausen-class_method">
  
    .<strong>clausen</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Clausen integral Cl_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6404
6405
6406
6407
6408
6409
6410
6411
6412</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6404</span>

static VALUE
sf_s_clausen(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_clausen, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="clausen_e-class_method">
  
    .<strong>clausen_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Clausen integral Cl_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6445
6446
6447
6448
6449
6450
6451
6452
6453
6454
6455
6456
6457
6458
6459
6460
6461</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6445</span>

static VALUE
sf_s_clausen_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_clausen_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_cos_e-class_method">
  
    .<strong>complex_cos_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the complex cosine, \cos(z_r + i z_i) storing
the real and imaginary parts in czr, czi.
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [czr.val, czr.err, czi.val, czi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23756
23757
23758
23759
23760
23761
23762
23763
23764
23765
23766
23767
23768
23769
23770
23771
23772</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23756</span>

static VALUE
sf_s_complex_cos_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_cos_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_dilog_e-class_method">
  
    .<strong>complex_dilog_e</strong>(r, theta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the full complex-valued dilogarithm for the
complex argument z = r \exp(i \theta). The real and imaginary
parts of the result are returned in result_re, result_im.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_re.val, result_re.err, result_im.val, result_im.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8314
8315
8316
8317
8318
8319
8320
8321
8322
8323
8324
8325
8326
8327
8328
8329
8330</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8314</span>

static VALUE
sf_s_complex_dilog_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_dilog_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_log_e-class_method">
  
    .<strong>complex_log_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the complex logarithm of z = z_r + i
z_i. The results are returned as lnr, theta such that
\exp(lnr + i \theta) = z_r + i z_i, where \theta lies in
the range [-\pi,\pi].
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lnr.val, lnr.err, theta.val, theta.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21144
21145
21146
21147
21148
21149
21150
21151
21152
21153
21154
21155
21156
21157
21158
21159
21160</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21144</span>

static VALUE
sf_s_complex_log_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_log_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_logsin_e-class_method">
  
    .<strong>complex_logsin_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the logarithm of the complex sine,
\log(\sin(z_r + i z_i)) storing the real and imaginary parts in
lszr, lszi.
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lszr.val, lszr.err, lszi.val, lszi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23814
23815
23816
23817
23818
23819
23820
23821
23822
23823
23824
23825
23826
23827
23828
23829
23830</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23814</span>

static VALUE
sf_s_complex_logsin_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_logsin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="complex_sin_e-class_method">
  
    .<strong>complex_sin_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the complex sine, \sin(z_r + i z_i) storing
the real and imaginary parts in szr, szi.
Exceptional Return Values: GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [szr.val, szr.err, szi.val, szi.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23699
23700
23701
23702
23703
23704
23705
23706
23707
23708
23709
23710
23711
23712
23713
23714
23715</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23699</span>

static VALUE
sf_s_complex_sin_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_complex_sin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_0-class_method">
  
    .<strong>conicalP_0</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^0<em>+ i \lambda(x)$
P^0</em>@+ i \lambda@(x)
for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20098
20099
20100
20101
20102
20103
20104
20105
20106</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20098</span>

static VALUE
sf_s_conicalP_0(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_0_e-class_method">
  
    .<strong>conicalP_0_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^0<em>+ i \lambda(x)$
P^0</em>@+ i \lambda@(x)
for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20146
20147
20148
20149
20150
20151
20152
20153
20154
20155
20156
20157
20158
20159
20160
20161
20162</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20146</span>

static VALUE
sf_s_conicalP_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_1-class_method">
  
    .<strong>conicalP_1</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^1<em>+ i \lambda(x)$
P^1</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20197
20198
20199
20200
20201
20202
20203
20204
20205</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20197</span>

static VALUE
sf_s_conicalP_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_1_e-class_method">
  
    .<strong>conicalP_1_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the conical function
$P^1<em>+ i \lambda(x)$
P^1</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20244
20245
20246
20247
20248
20249
20250
20251
20252
20253
20254
20255
20256
20257
20258
20259
20260</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20244</span>

static VALUE
sf_s_conicalP_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_cyl_reg-class_method">
  
    .<strong>conicalP_cyl_reg</strong>(m, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Cylindrical Conical Function
$P^-m<em>+ i \lambda(x)$
P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$
m &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20425
20426
20427
20428
20429
20430
20431
20432
20433
20434
20435
20436
20437
20438
20439
20440
20441
20442
20443
20444</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20425</span>

static VALUE
sf_s_conicalP_cyl_reg(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_cyl_reg,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_cyl_reg_e-class_method">
  
    .<strong>conicalP_cyl_reg_e</strong>(m, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Cylindrical Conical Function
$P^-m<em>+ i \lambda(x)$
P^@-m@</em>@+ i \lambda@(x) for x &gt; -1, $m \ge -1$
m &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20489
20490
20491
20492
20493
20494
20495
20496
20497
20498
20499
20500
20501
20502
20503
20504
20505
20506
20507
20508</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20489</span>

static VALUE
sf_s_conicalP_cyl_reg_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_cyl_reg_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_half-class_method">
  
    .<strong>conicalP_half</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular Spherical Conical Function
$P^1/2<em>+ i \lambda(x)$
P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19901
19902
19903
19904
19905
19906
19907
19908
19909</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19901</span>

static VALUE
sf_s_conicalP_half(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_half, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_half_e-class_method">
  
    .<strong>conicalP_half_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the irregular Spherical Conical Function
$P^1/2<em>+ i \lambda(x)$
P^@1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19948
19949
19950
19951
19952
19953
19954
19955
19956
19957
19958
19959
19960
19961
19962
19963
19964</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19948</span>

static VALUE
sf_s_conicalP_half_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_mhalf-class_method">
  
    .<strong>conicalP_mhalf</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular Spherical Conical Function
$P^-1/2<em>+ i \lambda(x)$
P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19999
20000
20001
20002
20003
20004
20005
20006
20007</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19999</span>

static VALUE
sf_s_conicalP_mhalf(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_mhalf, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_mhalf_e-class_method">
  
    .<strong>conicalP_mhalf_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regular Spherical Conical Function
$P^-1/2<em>+ i \lambda(x)$
P^@-1/2@</em>@+ i \lambda@(x) for x &gt; -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20046
20047
20048
20049
20050
20051
20052
20053
20054
20055
20056
20057
20058
20059
20060
20061
20062</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20046</span>

static VALUE
sf_s_conicalP_mhalf_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_mhalf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_sph_reg-class_method">
  
    .<strong>conicalP_sph_reg</strong>(l, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Spherical Conical Function
$P^-1/2-l<em>+ i \lambda(x)$
P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$
l &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20301
20302
20303
20304
20305
20306
20307
20308
20309
20310
20311
20312
20313
20314
20315
20316
20317
20318
20319
20320</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20301</span>

static VALUE
sf_s_conicalP_sph_reg(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_sph_reg,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="conicalP_sph_reg_e-class_method">
  
    .<strong>conicalP_sph_reg_e</strong>(l, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Regular Spherical Conical Function
$P^-1/2-l<em>+ i \lambda(x)$
P^@-1/2-l@</em>@+ i \lambda@(x) for x &gt; -1, $l \ge -1$
l &gt;= -1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20365
20366
20367
20368
20369
20370
20371
20372
20373
20374
20375
20376
20377
20378
20379
20380
20381
20382
20383
20384</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20365</span>

static VALUE
sf_s_conicalP_sph_reg_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_conicalP_sph_reg_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos-class_method">
  
    .<strong>cos</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the cosine function \cos(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23414
23415
23416
23417
23418
23419
23420
23421
23422</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23414</span>

static VALUE
sf_s_cos(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_cos, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos_e-class_method">
  
    .<strong>cos_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the cosine function \cos(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23456
23457
23458
23459
23460
23461
23462
23463
23464
23465
23466
23467
23468
23469
23470
23471
23472</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23456</span>

static VALUE
sf_s_cos_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_cos_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="cos_err_e-class_method">
  
    .<strong>cos_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the cosine of an angle x with an associated
absolute error dx,
$\cos(x \pm dx)$
\cos(x \pm dx).  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24308
24309
24310
24311
24312
24313
24314
24315
24316
24317
24318
24319
24320
24321
24322
24323
24324</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24308</span>

static VALUE
sf_s_cos_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_cos_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_CL_array-class_method">
  
    .<strong>coulomb_CL_array</strong>(Lmin, kmax, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function normalization constant
C_L(\eta) for L = Lmin \dots Lmin + kmax, Lmin &gt; -1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Lmin</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [cl[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7191
7192
7193
7194
7195
7196
7197
7198
7199
7200
7201
7202
7203
7204
7205
7206
7207
7208
7209
7210
7211
7212
7213
7214</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7191</span>

static VALUE
sf_s_coulomb_CL_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_CL_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v0,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_CL_e-class_method">
  
    .<strong>coulomb_CL_e</strong>(L, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function normalization constant
C_L(\eta) for L &gt; -1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7133
7134
7135
7136
7137
7138
7139
7140
7141
7142
7143
7144
7145
7146
7147
7148
7149</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7133</span>

static VALUE
sf_s_coulomb_CL_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_CL_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_F_array-class_method">
  
    .<strong>coulomb_wave_F_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function F_L(\eta,x) for
L = Lmin \dots Lmin + kmax, storing the results in fc_array.
In the case of overflow the exponent is stored in F_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], F_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6833
6834
6835
6836
6837
6838
6839
6840
6841
6842
6843
6844
6845
6846
6847
6848
6849
6850
6851
6852
6853
6854
6855
6856</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6833</span>

static VALUE
sf_s_coulomb_wave_F_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_F_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FG_array-class_method">
  
    .<strong>coulomb_wave_FG_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the functions F_L(\eta,x),
G_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in fc_array and gc_array.  In the case of overflow the
exponents are stored in F_exponent and G_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], gc_array[], F_exponent, G_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6912
6913
6914
6915
6916
6917
6918
6919
6920
6921
6922
6923
6924
6925
6926
6927
6928
6929
6930
6931
6932
6933
6934
6935</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6912</span>

static VALUE
sf_s_coulomb_wave_FG_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,1,shape},{cDF,1,shape},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FG_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,5,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FG_e-class_method">
  
    .<strong>coulomb_wave_FG_e</strong>(eta, x, L_F, k)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave functions F_L(\eta,x),
$G_L-k(\eta,x)$
G_@L-k@(\eta,x) and their derivatives
F’<em>L(\eta,x),
$G’</em>L-k(\eta,x)$
G’_@L-k@(\eta,x)
with respect to x.  The parameters are restricted to L,
L-k &gt; -1/2, x &gt; 0 and integer k.  Note that L
itself is not restricted to being an integer. The results are stored in
the parameters F, G for the function values and Fp,
Gp for the derivative values.  If an overflow occurs,
GSL_EOVRFLW is returned and scaling exponents are stored in
the modifiable parameters exp_F, exp_G.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>L_F</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [F.val, F.err, Fp.val, Fp.err, G.val, G.err, Gp.val, Gp.err, exp_F, exp_G, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6765
6766
6767
6768
6769
6770
6771
6772
6773
6774
6775
6776
6777
6778
6779
6780
6781
6782
6783
6784</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6765</span>

static VALUE
sf_s_coulomb_wave_FG_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[11] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FG_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,11,ain,aout};
    
    void *opt;
    c3 = NUM2INT(v3); opt = &amp;c3; //k
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_FGp_array-class_method">
  
    .<strong>coulomb_wave_FGp_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the functions F_L(\eta,x),
G_L(\eta,x) and their derivatives F’_L(\eta,x),
G’_L(\eta,x) for L = Lmin \dots Lmin + kmax storing the
results in fc_array, gc_array, fcp_array and gcp_array.
In the case of overflow the exponents are stored in F_exponent
and G_exponent.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], fcp_array[], gc_array[], gcp_array[], F_exponent, G_exponent, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6999
7000
7001
7002
7003
7004
7005
7006
7007
7008
7009
7010
7011
7012
7013
7014
7015
7016
7017
7018
7019
7020
7021
7022</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6999</span>

static VALUE
sf_s_coulomb_wave_FGp_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[7] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_FGp_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,7,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coulomb_wave_sphF_array-class_method">
  
    .<strong>coulomb_wave_sphF_array</strong>(L_min, kmax, eta, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Coulomb wave function divided by the argument
F_L(\eta, x)/x for L = Lmin \dots Lmin + kmax, storing the
results in fc_array.  In the case of overflow the exponent is
stored in F_exponent. This function reduces to spherical Bessel
functions in the limit \eta \to 0.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>L_min</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>kmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [fc_array[], F_exponent[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7073
7074
7075
7076
7077
7078
7079
7080
7081
7082
7083
7084
7085
7086
7087
7088
7089
7090
7091
7092
7093
7094
7095
7096</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7073</span>

static VALUE
sf_s_coulomb_wave_sphF_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c1;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_coulomb_wave_sphF_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //kmax
    
    if (c1&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c1+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v0,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_3j-class_method">
  
    .<strong>coupling_3j</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 3-j coefficient,</p>

<p>(ja jb jc
ma mb mc)</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ma</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7237
7238
7239
7240
7241
7242
7243
7244
7245
7246
7247
7248
7249
7250
7251
7252
7253
7254
7255
7256
7257
7258
7259
7260
7261</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7237</span>

static VALUE
sf_s_coupling_3j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    double c6;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c6 = gsl_sf_coupling_3j(c0,c1,c2,c3,c4,c5);
    
    return DBL2NUM(c6);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_3j_e-class_method">
  
    .<strong>coupling_3j_e</strong>(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 3-j coefficient,</p>

<p>(ja jb jc
ma mb mc)</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ma</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_mc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7284
7285
7286
7287
7288
7289
7290
7291
7292
7293
7294
7295
7296
7297
7298
7299
7300
7301
7302
7303
7304
7305
7306
7307
7308
7309
7310
7311
7312
7313
7314
7315
7316
7317</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7284</span>

static VALUE
sf_s_coupling_3j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    gsl_sf_result c6;
    int c7;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c7 = gsl_sf_coupling_3j_e(c0,c1,c2,c3,c4,c5,&amp;c6);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c6.val));
        rb_ary_push(va,DBL2NUM(c6.err));
        rb_ary_push(va,INT2NUM(c7));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_6j-class_method">
  
    .<strong>coupling_6j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 6-j coefficient,</p>

<p>@jb jc
jd je jf@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7340
7341
7342
7343
7344
7345
7346
7347
7348
7349
7350
7351
7352
7353
7354
7355
7356
7357
7358
7359
7360
7361
7362
7363
7364</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7340</span>

static VALUE
sf_s_coupling_6j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    double c6;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c6 = gsl_sf_coupling_6j(c0,c1,c2,c3,c4,c5);
    
    return DBL2NUM(c6);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_6j_e-class_method">
  
    .<strong>coupling_6j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 6-j coefficient,</p>

<p>@jb jc
jd je jf@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7387
7388
7389
7390
7391
7392
7393
7394
7395
7396
7397
7398
7399
7400
7401
7402
7403
7404
7405
7406
7407
7408
7409
7410
7411
7412
7413
7414
7415
7416
7417
7418
7419
7420</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7387</span>

static VALUE
sf_s_coupling_6j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    gsl_sf_result c6;
    int c7;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c7 = gsl_sf_coupling_6j_e(c0,c1,c2,c3,c4,c5,&amp;c6);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c6.val));
        rb_ary_push(va,DBL2NUM(c6.err));
        rb_ary_push(va,INT2NUM(c7));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_9j-class_method">
  
    .<strong>coupling_9j</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; <tt>Float</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 9-j coefficient,</p>

<p>@jb jc
jd je jf
jg jh ji@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jg</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jh</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ji</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7447
7448
7449
7450
7451
7452
7453
7454
7455
7456
7457
7458
7459
7460
7461
7462
7463
7464
7465
7466
7467
7468
7469
7470
7471
7472
7473
7474
7475
7476
7477</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7447</span>

static VALUE
sf_s_coupling_9j(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5,VALUE v6,VALUE v7,VALUE v8)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    int c6;
    int c7;
    int c8;
    double c9;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = NUM2INT(v6);
    c7 = NUM2INT(v7);
    c8 = NUM2INT(v8);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c9 = gsl_sf_coupling_9j(c0,c1,c2,c3,c4,c5,c6,c7,c8);
    
    return DBL2NUM(c9);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="coupling_9j_e-class_method">
  
    .<strong>coupling_9j_e</strong>(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, two_jg, two_jh, two_ji)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Wigner 9-j coefficient,</p>

<p>@jb jc
jd je jf
jg jh ji@</p>

<p>where the arguments are given in half-integer units, ja =
two_ja/2, ma = two_ma/2, etc.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>two_ja</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jb</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jc</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jd</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_je</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jf</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jg</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_jh</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>two_ji</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7504
7505
7506
7507
7508
7509
7510
7511
7512
7513
7514
7515
7516
7517
7518
7519
7520
7521
7522
7523
7524
7525
7526
7527
7528
7529
7530
7531
7532
7533
7534
7535
7536
7537
7538
7539
7540
7541
7542
7543</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7504</span>

static VALUE
sf_s_coupling_9j_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3,VALUE v4,VALUE v5,VALUE v6,VALUE v7,VALUE v8)
{
    
    int c0;
    int c1;
    int c2;
    int c3;
    int c4;
    int c5;
    int c6;
    int c7;
    int c8;
    gsl_sf_result c9;
    int c10;
    
    c0 = NUM2INT(v0);
    c1 = NUM2INT(v1);
    c2 = NUM2INT(v2);
    c3 = NUM2INT(v3);
    c4 = NUM2INT(v4);
    c5 = NUM2INT(v5);
    c6 = NUM2INT(v6);
    c7 = NUM2INT(v7);
    c8 = NUM2INT(v8);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c10 = gsl_sf_coupling_9j_e(c0,c1,c2,c3,c4,c5,c6,c7,c8,&amp;c9);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c9.val));
        rb_ary_push(va,DBL2NUM(c9.err));
        rb_ary_push(va,INT2NUM(c10));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dawson-class_method">
  
    .<strong>dawson</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the value of Dawson’s integral for x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7573
7574
7575
7576
7577
7578
7579
7580
7581</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7573</span>

static VALUE
sf_s_dawson(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_dawson, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dawson_e-class_method">
  
    .<strong>dawson_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the value of Dawson’s integral for x.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7615
7616
7617
7618
7619
7620
7621
7622
7623
7624
7625
7626
7627
7628
7629
7630
7631</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7615</span>

static VALUE
sf_s_dawson_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_dawson_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_1-class_method">
  
    .<strong>debye_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first-order Debye function
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7662
7663
7664
7665
7666
7667
7668
7669
7670</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7662</span>

static VALUE
sf_s_debye_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_1_e-class_method">
  
    .<strong>debye_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first-order Debye function
D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1)).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7705
7706
7707
7708
7709
7710
7711
7712
7713
7714
7715
7716
7717
7718
7719
7720
7721</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7705</span>

static VALUE
sf_s_debye_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_2-class_method">
  
    .<strong>debye_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order Debye function
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7752
7753
7754
7755
7756
7757
7758
7759
7760</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7752</span>

static VALUE
sf_s_debye_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_2_e-class_method">
  
    .<strong>debye_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order Debye function
D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7795
7796
7797
7798
7799
7800
7801
7802
7803
7804
7805
7806
7807
7808
7809
7810
7811</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7795</span>

static VALUE
sf_s_debye_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_3-class_method">
  
    .<strong>debye_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order Debye function
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7842
7843
7844
7845
7846
7847
7848
7849
7850</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7842</span>

static VALUE
sf_s_debye_3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_3_e-class_method">
  
    .<strong>debye_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order Debye function
D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7885
7886
7887
7888
7889
7890
7891
7892
7893
7894
7895
7896
7897
7898
7899
7900
7901</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7885</span>

static VALUE
sf_s_debye_3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_4-class_method">
  
    .<strong>debye_4</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fourth-order Debye function
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7932
7933
7934
7935
7936
7937
7938
7939
7940</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7932</span>

static VALUE
sf_s_debye_4(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_4, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_4_e-class_method">
  
    .<strong>debye_4_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fourth-order Debye function
D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


7975
7976
7977
7978
7979
7980
7981
7982
7983
7984
7985
7986
7987
7988
7989
7990
7991</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 7975</span>

static VALUE
sf_s_debye_4_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_4_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_5-class_method">
  
    .<strong>debye_5</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fifth-order Debye function
D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8022
8023
8024
8025
8026
8027
8028
8029
8030</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8022</span>

static VALUE
sf_s_debye_5(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_5, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_5_e-class_method">
  
    .<strong>debye_5_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the fifth-order Debye function
D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8065
8066
8067
8068
8069
8070
8071
8072
8073
8074
8075
8076
8077
8078
8079
8080
8081</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8065</span>

static VALUE
sf_s_debye_5_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_5_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_6-class_method">
  
    .<strong>debye_6</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sixth-order Debye function
D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8112
8113
8114
8115
8116
8117
8118
8119
8120</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8112</span>

static VALUE
sf_s_debye_6(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_debye_6, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="debye_6_e-class_method">
  
    .<strong>debye_6_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sixth-order Debye function
D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1)).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8155
8156
8157
8158
8159
8160
8161
8162
8163
8164
8165
8166
8167
8168
8169
8170
8171</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8155</span>

static VALUE
sf_s_debye_6_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_debye_6_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dilog-class_method">
  
    .<strong>dilog</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.
Note that \Im(Li_2(x)) = 0 for $x \le 1$
x &lt;= 1, and -\pi\log(x) for x &gt; 1.</p>

<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8208
8209
8210
8211
8212
8213
8214
8215
8216</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8208</span>

static VALUE
sf_s_dilog(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_dilog, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dilog_e-class_method">
  
    .<strong>dilog_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is Li_2(x), the real part of the dilogarithm of a
real x.  It is defined by the integral representation
Li_2(x) = - \Re \int_0^x ds \log(1-s) / s.
Note that \Im(Li_2(x)) = 0 for $x \le 1$
x &lt;= 1, and -\pi\log(x) for x &gt; 1.</p>

<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8257
8258
8259
8260
8261
8262
8263
8264
8265
8266
8267
8268
8269
8270
8271
8272
8273</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8257</span>

static VALUE
sf_s_dilog_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_dilog_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="doublefact-class_method">
  
    .<strong>doublefact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.
The maximum value of n such that n!! is not
considered an overflow is given by the macro GSL_SF_DOUBLEFACT_NMAX
and is 297.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13932
13933
13934
13935
13936
13937
13938
13939
13940</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13932</span>

static VALUE
sf_s_doublefact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_doublefact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="doublefact_e-class_method">
  
    .<strong>doublefact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the double factorial n!! = n(n-2)(n-4) \dots.
The maximum value of n such that n!! is not
considered an overflow is given by the macro GSL_SF_DOUBLEFACT_NMAX
and is 297.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13977
13978
13979
13980
13981
13982
13983
13984
13985
13986
13987
13988
13989
13990
13991
13992
13993</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13977</span>

static VALUE
sf_s_doublefact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_doublefact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_D-class_method">
  
    .<strong>ellint_D</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the incomplete elliptic integral
D(\phi,k) which is defined through the Carlson form RD(x,y,z)
by the following relation,</p>

<p>D(\phi,k) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).</p>

<p>Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9304
9305
9306
9307
9308
9309
9310
9311
9312
9313
9314
9315
9316
9317
9318
9319
9320
9321
9322
9323
9324
9325
9326
9327
9328
9329
9330
9331</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9304</span>

static VALUE
sf_s_ellint_D(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_D,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_D_e-class_method">
  
    .<strong>ellint_D_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the incomplete elliptic integral
D(\phi,k) which is defined through the Carlson form RD(x,y,z)
by the following relation,</p>

<p>D(\phi,k) = (1/3)(\sin(\phi))^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1).</p>

<p>Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9378
9379
9380
9381
9382
9383
9384
9385
9386
9387
9388
9389
9390
9391
9392
9393
9394
9395
9396
9397
9398
9399
9400
9401
9402
9403
9404
9405</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9378</span>

static VALUE
sf_s_ellint_D_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_D_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_E-class_method">
  
    .<strong>ellint_E</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9014
9015
9016
9017
9018
9019
9020
9021
9022
9023
9024
9025
9026
9027
9028
9029
9030
9031
9032
9033
9034
9035
9036
9037
9038
9039
9040
9041</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9014</span>

static VALUE
sf_s_ellint_E(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_E,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_E_e-class_method">
  
    .<strong>ellint_E_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral E(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9086
9087
9088
9089
9090
9091
9092
9093
9094
9095
9096
9097
9098
9099
9100
9101
9102
9103
9104
9105
9106
9107
9108
9109
9110
9111
9112
9113</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9086</span>

static VALUE
sf_s_ellint_E_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_E_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Ecomp-class_method">
  
    .<strong>ellint_Ecomp</strong>(k[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8606
8607
8608
8609
8610
8611
8612
8613
8614
8615
8616
8617
8618
8619
8620
8621
8622</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8606</span>

static VALUE
sf_s_ellint_Ecomp(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Ecomp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Ecomp_e-class_method">
  
    .<strong>ellint_Ecomp_e</strong>(k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral E(k) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8664
8665
8666
8667
8668
8669
8670
8671
8672
8673
8674
8675
8676
8677
8678
8679
8680
8681
8682
8683
8684
8685
8686
8687
8688
8689
8690
8691</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8664</span>

static VALUE
sf_s_ellint_Ecomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Ecomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_F-class_method">
  
    .<strong>ellint_F</strong>(phi, k, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8874
8875
8876
8877
8878
8879
8880
8881
8882
8883
8884
8885
8886
8887
8888
8889
8890
8891
8892
8893
8894
8895
8896
8897
8898
8899
8900
8901</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8874</span>

static VALUE
sf_s_ellint_F(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_F,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_F_e-class_method">
  
    .<strong>ellint_F_e</strong>(phi, k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral F(\phi,k)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8946
8947
8948
8949
8950
8951
8952
8953
8954
8955
8956
8957
8958
8959
8960
8961
8962
8963
8964
8965
8966
8967
8968
8969
8970
8971
8972
8973</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8946</span>

static VALUE
sf_s_ellint_F_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_F_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Kcomp-class_method">
  
    .<strong>ellint_Kcomp</strong>(k[,mode])  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral K(k) to
the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8484
8485
8486
8487
8488
8489
8490
8491
8492
8493
8494
8495
8496
8497
8498
8499
8500</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8484</span>

static VALUE
sf_s_ellint_Kcomp(int argc, VALUE *v, VALUE mod){
#line 34 &quot;gen/tmpl/m_DFloat_f_DFloat_mode.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Kcomp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    gsl_mode_t c1;

    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1..2&quot;,argc);
    }
    return na_ndloop3(&amp;ndf, &amp;c1, 1, v[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Kcomp_e-class_method">
  
    .<strong>ellint_Kcomp_e</strong>(k, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral K(k) to
the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter m = k^2.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8542
8543
8544
8545
8546
8547
8548
8549
8550
8551
8552
8553
8554
8555
8556
8557
8558
8559
8560
8561
8562
8563
8564
8565
8566
8567
8568
8569</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8542</span>

static VALUE
sf_s_ellint_Kcomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Kcomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    if (argc==1) {
        c1 = GSL_MODE_DEFAULT;
    } else if (argc==2) {
        c1 = NUM2INT(v[1]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 1 or 2&quot;,argc);
    }
    opt = &amp;c1; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v[0]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_P-class_method">
  
    .<strong>ellint_P</strong>(phi, k, n, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9158
9159
9160
9161
9162
9163
9164
9165
9166
9167
9168
9169
9170
9171
9172
9173
9174
9175
9176
9177
9178
9179
9180
9181
9182
9183
9184
9185</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9158</span>

static VALUE
sf_s_ellint_P(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_P,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_P_e-class_method">
  
    .<strong>ellint_P_e</strong>(phi, k, n, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral \Pi(\phi,k,n)
to the accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>phi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9234
9235
9236
9237
9238
9239
9240
9241
9242
9243
9244
9245
9246
9247
9248
9249
9250
9251
9252
9253
9254
9255
9256
9257
9258
9259
9260
9261</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9234</span>

static VALUE
sf_s_ellint_P_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_P_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Pcomp-class_method">
  
    .<strong>ellint_Pcomp</strong>(k, n, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral \Pi(k,n) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8733
8734
8735
8736
8737
8738
8739
8740
8741
8742
8743
8744
8745
8746
8747
8748
8749
8750
8751
8752
8753
8754
8755
8756
8757
8758
8759
8760</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8733</span>

static VALUE
sf_s_ellint_Pcomp(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Pcomp,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_Pcomp_e-class_method">
  
    .<strong>ellint_Pcomp_e</strong>(k, n, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete elliptic integral \Pi(k,n) to the
accuracy specified by the mode variable mode.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters m = k^2 and \sin^2(\alpha) = k^2, with the
change of sign n \to -n.
Exceptional Return Values:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>k</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8806
8807
8808
8809
8810
8811
8812
8813
8814
8815
8816
8817
8818
8819
8820
8821
8822
8823
8824
8825
8826
8827
8828
8829
8830
8831
8832
8833</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8806</span>

static VALUE
sf_s_ellint_Pcomp_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_Pcomp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RC-class_method">
  
    .<strong>ellint_RC</strong>(x, y, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9444
9445
9446
9447
9448
9449
9450
9451
9452
9453
9454
9455
9456
9457
9458
9459
9460
9461
9462
9463
9464
9465
9466
9467
9468
9469
9470
9471</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9444</span>

static VALUE
sf_s_ellint_RC(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RC,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RC_e-class_method">
  
    .<strong>ellint_RC_e</strong>(x, y, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RC(x,y)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9514
9515
9516
9517
9518
9519
9520
9521
9522
9523
9524
9525
9526
9527
9528
9529
9530
9531
9532
9533
9534
9535
9536
9537
9538
9539
9540
9541</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9514</span>

static VALUE
sf_s_ellint_RC_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c2;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RC_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    if (argc==2) {
        c2 = GSL_MODE_DEFAULT;
    } else if (argc==3) {
        c2 = NUM2INT(v[2]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 2 or 3&quot;,argc);
    }
    opt = &amp;c2; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v[0],v[1]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RD-class_method">
  
    .<strong>ellint_RD</strong>(x, y, z, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9583
9584
9585
9586
9587
9588
9589
9590
9591
9592
9593
9594
9595
9596
9597
9598
9599
9600
9601
9602
9603
9604
9605
9606
9607
9608
9609
9610</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9583</span>

static VALUE
sf_s_ellint_RD(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RD,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RD_e-class_method">
  
    .<strong>ellint_RD_e</strong>(x, y, z, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RD(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9656
9657
9658
9659
9660
9661
9662
9663
9664
9665
9666
9667
9668
9669
9670
9671
9672
9673
9674
9675
9676
9677
9678
9679
9680
9681
9682
9683</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9656</span>

static VALUE
sf_s_ellint_RD_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RD_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RF-class_method">
  
    .<strong>ellint_RF</strong>(x, y, z, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9725
9726
9727
9728
9729
9730
9731
9732
9733
9734
9735
9736
9737
9738
9739
9740
9741
9742
9743
9744
9745
9746
9747
9748
9749
9750
9751
9752</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9725</span>

static VALUE
sf_s_ellint_RF(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RF,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,1,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RF_e-class_method">
  
    .<strong>ellint_RF_e</strong>(x, y, z, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RF(x,y,z)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9798
9799
9800
9801
9802
9803
9804
9805
9806
9807
9808
9809
9810
9811
9812
9813
9814
9815
9816
9817
9818
9819
9820
9821
9822
9823
9824
9825</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9798</span>

static VALUE
sf_s_ellint_RF_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c3;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RF_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    void *opt;
    if (argc==3) {
        c3 = GSL_MODE_DEFAULT;
    } else if (argc==4) {
        c3 = NUM2INT(v[3]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 3 or 4&quot;,argc);
    }
    opt = &amp;c3; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,3,v[0],v[1],v[2]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RJ-class_method">
  
    .<strong>ellint_RJ</strong>(x, y, z, p, [mode])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>p</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9870
9871
9872
9873
9874
9875
9876
9877
9878
9879
9880
9881
9882
9883
9884
9885
9886
9887
9888
9889
9890
9891
9892
9893
9894
9895
9896
9897</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9870</span>

static VALUE
sf_s_ellint_RJ(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c4;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RJ,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    void *opt;
    if (argc==4) {
        c4 = GSL_MODE_DEFAULT;
    } else if (argc==5) {
        c4 = NUM2INT(v[4]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 4 or 5&quot;,argc);
    }
    opt = &amp;c4; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,4,v[0],v[1],v[2],v[3]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ellint_RJ_e-class_method">
  
    .<strong>ellint_RJ_e</strong>(x, y, z, p, [mode])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete elliptic integral RJ(x,y,z,p)
to the accuracy specified by the mode variable mode.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>p</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mode</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The following precision levels are available: Numo::GSL::PREC_DOUBLE, Numo::GSL::PREC_SINGLE, Numo::GSL::PREC_APPROX.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


9946
9947
9948
9949
9950
9951
9952
9953
9954
9955
9956
9957
9958
9959
9960
9961
9962
9963
9964
9965
9966
9967
9968
9969
9970
9971
9972
9973</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 9946</span>

static VALUE
sf_s_ellint_RJ_e(int argc, VALUE *v, VALUE mod)
{
    
    gsl_mode_t c4;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_ellint_RJ_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    void *opt;
    if (argc==4) {
        c4 = GSL_MODE_DEFAULT;
    } else if (argc==5) {
        c4 = NUM2INT(v[4]);
    } else {
        rb_raise(rb_eArgError,&quot;invalid number of argument: %d for 4 or 5&quot;,argc);
    }
    opt = &amp;c4; //mode

    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,4,v[0],v[1],v[2],v[3]); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="elljac_e-class_method">
  
    .<strong>elljac_e</strong>(u, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Jacobian elliptic functions sn(u|m),
cn(u|m), dn(u|m) by descending Landen
transformations.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>u</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [sn, cn, dn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10018
10019
10020
10021
10022
10023
10024
10025
10026
10027
10028
10029
10030
10031
10032
10033
10034</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10018</span>

static VALUE
sf_s_elljac_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_elljac_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf-class_method">
  
    .<strong>erf</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the error function $\erf(x)$
erf(x), where
$\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10067
10068
10069
10070
10071
10072
10073
10074
10075</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10067</span>

static VALUE
sf_s_erf(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_e-class_method">
  
    .<strong>erf_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the error function $\erf(x)$
erf(x), where
$\erf(x) = (2/\sqrt\pi) \int_0^x dt \exp(-t^2)$
erf(x) = (2/\sqrt(\pi)) \int_0^x dt \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10112
10113
10114
10115
10116
10117
10118
10119
10120
10121
10122
10123
10124
10125
10126
10127
10128</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10112</span>

static VALUE
sf_s_erf_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Q-class_method">
  
    .<strong>erf_Q</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the upper tail of the Gaussian probability
function
$Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$
Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10433
10434
10435
10436
10437
10438
10439
10440
10441</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10433</span>

static VALUE
sf_s_erf_Q(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Q, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Q_e-class_method">
  
    .<strong>erf_Q_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the upper tail of the Gaussian probability
function
$Q(x) = (1/\sqrt2\pi) \int_x^\infty dt \exp(-t^2/2)$
Q(x) = (1/\sqrt@2\pi@) \int_x^\infty dt \exp(-t^2/2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10478
10479
10480
10481
10482
10483
10484
10485
10486
10487
10488
10489
10490
10491
10492
10493
10494</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10478</span>

static VALUE
sf_s_erf_Q_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Q_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Z-class_method">
  
    .<strong>erf_Z</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gaussian probability density function
$Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$
Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10341
10342
10343
10344
10345
10346
10347
10348
10349</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10341</span>

static VALUE
sf_s_erf_Z(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Z, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erf_Z_e-class_method">
  
    .<strong>erf_Z_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gaussian probability density function
$Z(x) = (1/\sqrt2\pi) \exp(-x^2/2)$
Z(x) = (1/\sqrt@2\pi@) \exp(-x^2/2).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10384
10385
10386
10387
10388
10389
10390
10391
10392
10393
10394
10395
10396
10397
10398
10399
10400</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10384</span>

static VALUE
sf_s_erf_Z_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erf_Z_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erfc-class_method">
  
    .<strong>erfc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary error function
$\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10160
10161
10162
10163
10164
10165
10166
10167
10168</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10160</span>

static VALUE
sf_s_erfc(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_erfc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="erfc_e-class_method">
  
    .<strong>erfc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary error function
$\erfc(x) = 1 - \erf(x) = (2/\sqrt\pi) \int_x^\infty \exp(-t^2)$
erfc(x) = 1 - erf(x) = (2/\sqrt(\pi)) \int_x^\infty \exp(-t^2).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10204
10205
10206
10207
10208
10209
10210
10211
10212
10213
10214
10215
10216
10217
10218
10219
10220</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10204</span>

static VALUE
sf_s_erfc_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_erfc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta-class_method">
  
    .<strong>eta</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(s) for arbitrary s.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24870
24871
24872
24873
24874
24875
24876
24877
24878</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24870</span>

static VALUE
sf_s_eta(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_eta, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_e-class_method">
  
    .<strong>eta_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(s) for arbitrary s.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24912
24913
24914
24915
24916
24917
24918
24919
24920
24921
24922
24923
24924
24925
24926
24927
24928</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24912</span>

static VALUE
sf_s_eta_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_eta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_int-class_method">
  
    .<strong>eta_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(n) for integer n.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24797
24798
24799
24800
24801
24802
24803
24804
24805</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24797</span>

static VALUE
sf_s_eta_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_eta_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eta_int_e-class_method">
  
    .<strong>eta_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the eta function \eta(n) for integer n.
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24817
24818
24819
24820
24821
24822
24823
24824
24825
24826
24827
24828
24829
24830
24831
24832
24833
24834
24835
24836
24837
24838
24839
24840</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24817</span>

static VALUE
sf_s_eta_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_eta_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp-class_method">
  
    .<strong>exp</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10613
10614
10615
10616
10617
10618
10619
10620
10621</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10613</span>

static VALUE
sf_s_exp(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exp, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_e-class_method">
  
    .<strong>exp_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines provide an exponential function \exp(x) using GSL
semantics and error checking.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10656
10657
10658
10659
10660
10661
10662
10663
10664
10665
10666
10667
10668
10669
10670
10671
10672</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10656</span>

static VALUE
sf_s_exp_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_e10_e-class_method">
  
    .<strong>exp_e10_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the exponential \exp(x) using the
gsl_sf_result_e10 type to return a result with extended range.
This function may be useful if the value of \exp(x) would
overflow the  numeric range of double.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10709
10710
10711
10712
10713
10714
10715
10716
10717
10718
10719
10720
10721
10722
10723
10724
10725</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10709</span>

static VALUE
sf_s_exp_e10_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_err_e-class_method">
  
    .<strong>exp_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function exponentiates x with an associated absolute error
dx.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11306
11307
11308
11309
11310
11311
11312
11313
11314
11315
11316
11317
11318
11319
11320
11321
11322</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11306</span>

static VALUE
sf_s_exp_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_err_e10_e-class_method">
  
    .<strong>exp_err_e10_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function exponentiates a quantity x with an associated absolute
error dx using the gsl_sf_result_e10 type to return a result with
extended range.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11361
11362
11363
11364
11365
11366
11367
11368
11369
11370
11371
11372
11373
11374
11375
11376
11377</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11361</span>

static VALUE
sf_s_exp_err_e10_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_err_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult-class_method">
  
    .<strong>exp_mult</strong>(x, y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines exponentiate x and multiply by the factor y
to return the product y \exp(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10759
10760
10761
10762
10763
10764
10765
10766
10767</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10759</span>

static VALUE
sf_s_exp_mult(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_e-class_method">
  
    .<strong>exp_mult_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines exponentiate x and multiply by the factor y
to return the product y \exp(x).
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10805
10806
10807
10808
10809
10810
10811
10812
10813
10814
10815
10816
10817
10818
10819
10820
10821</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10805</span>

static VALUE
sf_s_exp_mult_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_e10_e-class_method">
  
    .<strong>exp_mult_e10_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the product y \exp(x) using the
gsl_sf_result_e10 type to return a result with extended numeric
range.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10860
10861
10862
10863
10864
10865
10866
10867
10868
10869
10870
10871
10872
10873
10874
10875
10876</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10860</span>

static VALUE
sf_s_exp_mult_e10_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_err_e-class_method">
  
    .<strong>exp_mult_err_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the product y \exp(x) for the quantities
x, y with associated absolute errors dx, dy.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11421
11422
11423
11424
11425
11426
11427
11428
11429
11430
11431
11432
11433
11434
11435
11436
11437</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11421</span>

static VALUE
sf_s_exp_mult_err_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exp_mult_err_e10_e-class_method">
  
    .<strong>exp_mult_err_e10_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the product y \exp(x) for the quantities
x, y with associated absolute errors dx, dy using the
gsl_sf_result_e10 type to return a result with extended range.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11482
11483
11484
11485
11486
11487
11488
11489
11490
11491
11492
11493
11494
11495
11496
11497
11498</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11482</span>

static VALUE
sf_s_exp_mult_err_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exp_mult_err_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_3-class_method">
  
    .<strong>expint_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$
Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$
x &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12116
12117
12118
12119
12120
12121
12122
12123
12124</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12116</span>

static VALUE
sf_s_expint_3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_3_e-class_method">
  
    .<strong>expint_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the third-order exponential integral $Ei_3(x) = \int_0^xdt \exp(-t^3)$
Ei_3(x) = \int_0^xdt \exp(-t^3) for $x \ge 0$
x &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12160
12161
12162
12163
12164
12165
12166
12167
12168
12169
12170
12171
12172
12173
12174
12175
12176</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12160</span>

static VALUE
sf_s_expint_3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E1-class_method">
  
    .<strong>expint_E1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_1(x),</p>

<p>E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11532
11533
11534
11535
11536
11537
11538
11539
11540</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11532</span>

static VALUE
sf_s_expint_E1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E1_e-class_method">
  
    .<strong>expint_E1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_1(x),</p>

<p>E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11578
11579
11580
11581
11582
11583
11584
11585
11586
11587
11588
11589
11590
11591
11592
11593
11594</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11578</span>

static VALUE
sf_s_expint_E1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E2-class_method">
  
    .<strong>expint_E2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order exponential integral E_2(x),</p>

<p>E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11628
11629
11630
11631
11632
11633
11634
11635
11636</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11628</span>

static VALUE
sf_s_expint_E2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_E2_e-class_method">
  
    .<strong>expint_E2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second-order exponential integral E_2(x),</p>

<p>E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11674
11675
11676
11677
11678
11679
11680
11681
11682
11683
11684
11685
11686
11687
11688
11689
11690</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11674</span>

static VALUE
sf_s_expint_E2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_E2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_Ei-class_method">
  
    .<strong>expint_Ei</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral $\hboxEi(x)$
Ei(x),</p>

<p>Ei(x) := - PV(\int_@-x@^\infty dt \exp(-t)/t)</p>

<p>where PV denotes the principal value of the integral.
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11836
11837
11838
11839
11840
11841
11842
11843
11844</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11836</span>

static VALUE
sf_s_expint_Ei(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_Ei, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_Ei_e-class_method">
  
    .<strong>expint_Ei_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral $\hboxEi(x)$
Ei(x),</p>

<p>Ei(x) := - PV(\int_@-x@^\infty dt \exp(-t)/t)</p>

<p>where PV denotes the principal value of the integral.
Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11884
11885
11886
11887
11888
11889
11890
11891
11892
11893
11894
11895
11896
11897
11898
11899
11900</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11884</span>

static VALUE
sf_s_expint_Ei_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_Ei_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_En-class_method">
  
    .<strong>expint_En</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_n(x) of order n,</p>

<p>E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11727
11728
11729
11730
11731
11732
11733
11734
11735
11736
11737
11738</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11727</span>

static VALUE
sf_s_expint_En(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expint_En, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expint_En_e-class_method">
  
    .<strong>expint_En_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the exponential integral E_n(x) of order n,</p>

<p>E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n.</p>

<p>Domain: x != 0.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11781
11782
11783
11784
11785
11786
11787
11788
11789
11790
11791
11792
11793
11794
11795
11796
11797
11798
11799
11800</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11781</span>

static VALUE
sf_s_expint_En_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expint_En_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expm1-class_method">
  
    .<strong>expm1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10907
10908
10909
10910
10911
10912
10913
10914
10915</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10907</span>

static VALUE
sf_s_expm1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_expm1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="expm1_e-class_method">
  
    .<strong>expm1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity \exp(x)-1 using an algorithm
that is accurate for small x.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10950
10951
10952
10953
10954
10955
10956
10957
10958
10959
10960
10961
10962
10963
10964
10965
10966</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10950</span>

static VALUE
sf_s_expm1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_expm1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel-class_method">
  
    .<strong>exprel</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2<em>3) + x^3/(2</em>3*4) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10999
11000
11001
11002
11003
11004
11005
11006
11007</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10999</span>

static VALUE
sf_s_exprel(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_2-class_method">
  
    .<strong>exprel_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 =
1 + x/3 + x^2/(3<em>4) + x^3/(3</em>4*5) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11093
11094
11095
11096
11097
11098
11099
11100
11101</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11093</span>

static VALUE
sf_s_exprel_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_2_e-class_method">
  
    .<strong>exprel_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion 2(\exp(x)-1-x)/x^2 =
1 + x/3 + x^2/(3<em>4) + x^3/(3</em>4*5) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11138
11139
11140
11141
11142
11143
11144
11145
11146
11147
11148
11149
11150
11151
11152
11153
11154</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11138</span>

static VALUE
sf_s_exprel_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_e-class_method">
  
    .<strong>exprel_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the quantity (\exp(x)-1)/x using an
algorithm that is accurate for small x.  For small x the
algorithm is based on the expansion (\exp(x)-1)/x = 1 + x/2 +
x^2/(2<em>3) + x^3/(2</em>3*4) + \dots.
Exceptional Return Values:  GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11044
11045
11046
11047
11048
11049
11050
11051
11052
11053
11054
11055
11056
11057
11058
11059
11060</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11044</span>

static VALUE
sf_s_exprel_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_n-class_method">
  
    .<strong>exprel_n</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the N-relative exponential, which is the
n-th generalization of the functions gsl_sf_exprel and
gsl_sf_exprel_2.  The N-relative exponential is given by,</p>

<p>exprel_N(x) = N!/x^N (\exp(x) - \sum_@k=0@^@N-1@ x^k/k!)
          = 1 + x/(N+1) + x^2/((N+1)(N+2)) + …
          = 1F1 (1,1+N,x)
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11193
11194
11195
11196
11197
11198
11199
11200
11201
11202
11203
11204</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11193</span>

static VALUE
sf_s_exprel_n(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_n, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="exprel_n_e-class_method">
  
    .<strong>exprel_n_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the N-relative exponential, which is the
n-th generalization of the functions gsl_sf_exprel and
gsl_sf_exprel_2.  The N-relative exponential is given by,</p>

<p>exprel_N(x) = N!/x^N (\exp(x) - \sum_@k=0@^@N-1@ x^k/k!)
          = 1 + x/(N+1) + x^2/((N+1)(N+2)) + …
          = 1F1 (1,1+N,x)
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11249
11250
11251
11252
11253
11254
11255
11256
11257
11258
11259
11260
11261
11262
11263
11264
11265
11266
11267
11268</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11249</span>

static VALUE
sf_s_exprel_n_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_exprel_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fact-class_method">
  
    .<strong>fact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
The maximum value of n such that n! is not
considered an overflow is given by the macro GSL_SF_FACT_NMAX
and is 170.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13836
13837
13838
13839
13840
13841
13842
13843
13844</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13836</span>

static VALUE
sf_s_fact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fact_e-class_method">
  
    .<strong>fact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the factorial n!.  The factorial is
related to the Gamma function by n! = \Gamma(n+1).
The maximum value of n such that n! is not
considered an overflow is given by the macro GSL_SF_FACT_NMAX
and is 170.
exceptions: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13882
13883
13884
13885
13886
13887
13888
13889
13890
13891
13892
13893
13894
13895
13896
13897
13898</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13882</span>

static VALUE
sf_s_fact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_0-class_method">
  
    .<strong>fermi_dirac_0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 0.
This integral is given by F_0(x) = \ln(1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12575
12576
12577
12578
12579
12580
12581
12582
12583</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12575</span>

static VALUE
sf_s_fermi_dirac_0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_0_e-class_method">
  
    .<strong>fermi_dirac_0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 0.
This integral is given by F_0(x) = \ln(1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12618
12619
12620
12621
12622
12623
12624
12625
12626
12627
12628
12629
12630
12631
12632
12633
12634</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12618</span>

static VALUE
sf_s_fermi_dirac_0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_1-class_method">
  
    .<strong>fermi_dirac_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12665
12666
12667
12668
12669
12670
12671
12672
12673</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12665</span>

static VALUE
sf_s_fermi_dirac_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_1_e-class_method">
  
    .<strong>fermi_dirac_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of 1,
F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12708
12709
12710
12711
12712
12713
12714
12715
12716
12717
12718
12719
12720
12721
12722
12723
12724</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12708</span>

static VALUE
sf_s_fermi_dirac_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_2-class_method">
  
    .<strong>fermi_dirac_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12756
12757
12758
12759
12760
12761
12762
12763
12764</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12756</span>

static VALUE
sf_s_fermi_dirac_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_2_e-class_method">
  
    .<strong>fermi_dirac_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index
of 2,
F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1)).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12800
12801
12802
12803
12804
12805
12806
12807
12808
12809
12810
12811
12812
12813
12814
12815
12816</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12800</span>

static VALUE
sf_s_fermi_dirac_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_3half-class_method">
  
    .<strong>fermi_dirac_3half</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_3/2(x)$
F_@3/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13140
13141
13142
13143
13144
13145
13146
13147
13148</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13140</span>

static VALUE
sf_s_fermi_dirac_3half(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_3half, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_3half_e-class_method">
  
    .<strong>fermi_dirac_3half_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_3/2(x)$
F_@3/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13184
13185
13186
13187
13188
13189
13190
13191
13192
13193
13194
13195
13196
13197
13198
13199
13200</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13184</span>

static VALUE
sf_s_fermi_dirac_3half_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_3half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_half-class_method">
  
    .<strong>fermi_dirac_half</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_1/2(x)$
F_@1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13048
13049
13050
13051
13052
13053
13054
13055
13056</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13048</span>

static VALUE
sf_s_fermi_dirac_half(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_half, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_half_e-class_method">
  
    .<strong>fermi_dirac_half_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_1/2(x)$
F_@1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13092
13093
13094
13095
13096
13097
13098
13099
13100
13101
13102
13103
13104
13105
13106
13107
13108</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13092</span>

static VALUE
sf_s_fermi_dirac_half_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_half_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_inc_0-class_method">
  
    .<strong>fermi_dirac_inc_0</strong>(x, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
$F_0(x,b) = \ln(1 + e^b-x) - (b-x)$
F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13236
13237
13238
13239
13240
13241
13242
13243
13244</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13236</span>

static VALUE
sf_s_fermi_dirac_inc_0(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_inc_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_inc_0_e-class_method">
  
    .<strong>fermi_dirac_inc_0_e</strong>(x, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
$F_0(x,b) = \ln(1 + e^b-x) - (b-x)$
F_0(x,b) = \ln(1 + e^@b-x@) - (b-x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13284
13285
13286
13287
13288
13289
13290
13291
13292
13293
13294
13295
13296
13297
13298
13299
13300</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13284</span>

static VALUE
sf_s_fermi_dirac_inc_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_inc_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_int-class_method">
  
    .<strong>fermi_dirac_int</strong>(j, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
Complete integral F_j(x) for integer j
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12852
12853
12854
12855
12856
12857
12858
12859
12860
12861
12862
12863</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12852</span>

static VALUE
sf_s_fermi_dirac_int(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_int_e-class_method">
  
    .<strong>fermi_dirac_int_e</strong>(j, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an integer
index of j,
F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1)).
Complete integral F_j(x) for integer j
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12905
12906
12907
12908
12909
12910
12911
12912
12913
12914
12915
12916
12917
12918
12919
12920
12921
12922
12923
12924</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12905</span>

static VALUE
sf_s_fermi_dirac_int_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //j
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_m1-class_method">
  
    .<strong>fermi_dirac_m1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of -1.
This integral is given by
$F_-1(x) = e^x / (1 + e^x)$
F_@-1@(x) = e^x / (1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12483
12484
12485
12486
12487
12488
12489
12490
12491</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12483</span>

static VALUE
sf_s_fermi_dirac_m1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_m1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_m1_e-class_method">
  
    .<strong>fermi_dirac_m1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral with an index of -1.
This integral is given by
$F_-1(x) = e^x / (1 + e^x)$
F_@-1@(x) = e^x / (1 + e^x).
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12528
12529
12530
12531
12532
12533
12534
12535
12536
12537
12538
12539
12540
12541
12542
12543
12544</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12528</span>

static VALUE
sf_s_fermi_dirac_m1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_m1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_mhalf-class_method">
  
    .<strong>fermi_dirac_mhalf</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_-1/2(x)$
F_@-1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12956
12957
12958
12959
12960
12961
12962
12963
12964</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12956</span>

static VALUE
sf_s_fermi_dirac_mhalf(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_mhalf, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fermi_dirac_mhalf_e-class_method">
  
    .<strong>fermi_dirac_mhalf_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complete Fermi-Dirac integral
$F_-1/2(x)$
F_@-1/2@(x).
Exceptional Return Values: GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13000
13001
13002
13003
13004
13005
13006
13007
13008
13009
13010
13011
13012
13013
13014
13015
13016</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13000</span>

static VALUE
sf_s_fermi_dirac_mhalf_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_fermi_dirac_mhalf_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma-class_method">
  
    .<strong>gamma</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro GSL_SF_GAMMA_XMAX
and is 171.0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13334
13335
13336
13337
13338
13339
13340
13341
13342</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13334</span>

static VALUE
sf_s_gamma(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_e-class_method">
  
    .<strong>gamma_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gamma function \Gamma(x), subject to x
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of x such that \Gamma(x) is not
considered an overflow is given by the macro GSL_SF_GAMMA_XMAX
and is 171.0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13380
13381
13382
13383
13384
13385
13386
13387
13388
13389
13390
13391
13392
13393
13394
13395
13396</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13380</span>

static VALUE
sf_s_gamma_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc-class_method">
  
    .<strong>gamma_inc</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the unnormalized incomplete Gamma Function
$\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$
\Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t)
for a real and $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14886
14887
14888
14889
14890
14891
14892
14893
14894</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14886</span>

static VALUE
sf_s_gamma_inc(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_e-class_method">
  
    .<strong>gamma_inc_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute the unnormalized incomplete Gamma Function
$\Gamma(a,x) = \int_x^\infty dt\, t^(a-1) \exp(-t)$
\Gamma(a,x) = \int_x^\infty dt t^@a-1@ \exp(-t)
for a real and $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14935
14936
14937
14938
14939
14940
14941
14942
14943
14944
14945
14946
14947
14948
14949
14950
14951</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14935</span>

static VALUE
sf_s_gamma_inc_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_P-class_method">
  
    .<strong>gamma_inc_P</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary normalized incomplete Gamma Function
$P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$
P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.</p>

<p>Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15093
15094
15095
15096
15097
15098
15099
15100
15101</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15093</span>

static VALUE
sf_s_gamma_inc_P(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_P, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_P_e-class_method">
  
    .<strong>gamma_inc_P_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the complementary normalized incomplete Gamma Function
$P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt\, t^(a-1) \exp(-t)$
P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.</p>

<p>Note that Abramowitz &amp; Stegun call P(a,x) the incomplete gamma
function (section 6.5).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15145
15146
15147
15148
15149
15150
15151
15152
15153
15154
15155
15156
15157
15158
15159
15160
15161</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15145</span>

static VALUE
sf_s_gamma_inc_P_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_P_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_Q-class_method">
  
    .<strong>gamma_inc_Q</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Gamma Function
$Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14988
14989
14990
14991
14992
14993
14994
14995
14996</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14988</span>

static VALUE
sf_s_gamma_inc_Q(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_Q, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gamma_inc_Q_e-class_method">
  
    .<strong>gamma_inc_Q_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized incomplete Gamma Function
$Q(a,x) = 1/\Gamma(a) \int_x^\infty dt\, t^(a-1) \exp(-t)$
Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^@a-1@ \exp(-t)
for a &gt; 0, $x \ge 0$
x &gt;= 0.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15037
15038
15039
15040
15041
15042
15043
15044
15045
15046
15047
15048
15049
15050
15051
15052
15053</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15037</span>

static VALUE
sf_s_gamma_inc_Q_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gamma_inc_Q_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammainv-class_method">
  
    .<strong>gammainv</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
exceptions: GSL_EUNDRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13679
13680
13681
13682
13683
13684
13685
13686
13687</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13679</span>

static VALUE
sf_s_gammainv(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gammainv, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammainv_e-class_method">
  
    .<strong>gammainv_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the reciprocal of the gamma function,
1/\Gamma(x) using the real Lanczos method.
exceptions: GSL_EUNDRFLW, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13722
13723
13724
13725
13726
13727
13728
13729
13730
13731
13732
13733
13734
13735
13736
13737
13738</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13722</span>

static VALUE
sf_s_gammainv_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gammainv_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammastar-class_method">
  
    .<strong>gammastar</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regulated Gamma Function \Gamma^*(x)
for x &gt; 0. The regulated gamma function is given by,</p>

<p>\Gamma^*(x) = \Gamma(x)/(\sqrt@2\pi@ x^@(x-1/2)@ \exp(-x))
          = (1 + (1/12x) + …)  for x \to \infty
and is a useful suggestion of Temme.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13585
13586
13587
13588
13589
13590
13591
13592
13593</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13585</span>

static VALUE
sf_s_gammastar(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gammastar, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gammastar_e-class_method">
  
    .<strong>gammastar_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the regulated Gamma Function \Gamma^*(x)
for x &gt; 0. The regulated gamma function is given by,</p>

<p>\Gamma^*(x) = \Gamma(x)/(\sqrt@2\pi@ x^@(x-1/2)@ \exp(-x))
          = (1 + (1/12x) + …)  for x \to \infty
and is a useful suggestion of Temme.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13632
13633
13634
13635
13636
13637
13638
13639
13640
13641
13642
13643
13644
13645
13646
13647
13648</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13632</span>

static VALUE
sf_s_gammastar_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gammastar_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_1-class_method">
  
    .<strong>gegenpoly_1</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15505
15506
15507
15508
15509
15510
15511
15512
15513</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15505</span>

static VALUE
sf_s_gegenpoly_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_1_e-class_method">
  
    .<strong>gegenpoly_1_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15641
15642
15643
15644
15645
15646
15647
15648
15649
15650
15651
15652
15653
15654
15655
15656
15657</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15641</span>

static VALUE
sf_s_gegenpoly_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_2-class_method">
  
    .<strong>gegenpoly_2</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15549
15550
15551
15552
15553
15554
15555
15556
15557</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15549</span>

static VALUE
sf_s_gegenpoly_2(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_2, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_2_e-class_method">
  
    .<strong>gegenpoly_2_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15697
15698
15699
15700
15701
15702
15703
15704
15705
15706
15707
15708
15709
15710
15711
15712
15713</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15697</span>

static VALUE
sf_s_gegenpoly_2_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_3-class_method">
  
    .<strong>gegenpoly_3</strong>(lambda, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15593
15594
15595
15596
15597
15598
15599
15600
15601</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15593</span>

static VALUE
sf_s_gegenpoly_3(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_3, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_3_e-class_method">
  
    .<strong>gegenpoly_3_e</strong>(lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) using explicit
representations for n =1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15753
15754
15755
15756
15757
15758
15759
15760
15761
15762
15763
15764
15765
15766
15767
15768
15769</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15753</span>

static VALUE
sf_s_gegenpoly_3_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_array-class_method">
  
    .<strong>gegenpoly_array</strong>(nmax, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an array of Gegenbauer polynomials
$C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) for n = 0, 1, 2, \dots, nmax, subject
to \lambda &gt; -1/2, $nmax \ge 0$
nmax &gt;= 0.
Conditions: n = 0, 1, 2, … nmax
Domain: lambda &gt; -1/2, nmax &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15943
15944
15945
15946
15947
15948
15949
15950
15951
15952
15953
15954
15955
15956
15957
15958
15959
15960
15961
15962
15963
15964
15965
15966</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15943</span>

static VALUE
sf_s_gegenpoly_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //nmax
    
    if (c0&lt;0) {
        rb_raise(rb_eArgError,&quot;should be kmax&gt;=0&quot;);
    }
    shape[0] = c0+1;
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_n-class_method">
  
    .<strong>gegenpoly_n</strong>(n, lambda, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) for a specific value of n,
lambda, x subject to \lambda &gt; -1/2, $n \ge 0$
n &gt;= 0.
Domain: lambda &gt; -1/2, n &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15811
15812
15813
15814
15815
15816
15817
15818
15819
15820
15821
15822
15823
15824
15825
15826
15827
15828
15829
15830</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15811</span>

static VALUE
sf_s_gegenpoly_n(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_n,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="gegenpoly_n_e-class_method">
  
    .<strong>gegenpoly_n_e</strong>(n, lambda, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Gegenbauer polynomial $C^(\lambda)_n(x)$
C^@(\lambda)@_n(x) for a specific value of n,
lambda, x subject to \lambda &gt; -1/2, $n \ge 0$
n &gt;= 0.
Domain: lambda &gt; -1/2, n &gt;= 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15876
15877
15878
15879
15880
15881
15882
15883
15884
15885
15886
15887
15888
15889
15890
15891
15892
15893
15894
15895</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15876</span>

static VALUE
sf_s_gegenpoly_n_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_gegenpoly_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hazard-class_method">
  
    .<strong>hazard</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hazard function for the normal distribution.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10524
10525
10526
10527
10528
10529
10530
10531
10532</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10524</span>

static VALUE
sf_s_hazard(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hazard, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hazard_e-class_method">
  
    .<strong>hazard_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hazard function for the normal distribution.
Exceptional Return Values: GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10566
10567
10568
10569
10570
10571
10572
10573
10574
10575
10576
10577
10578
10579
10580
10581
10582</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10566</span>

static VALUE
sf_s_hazard_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hazard_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR-class_method">
  
    .<strong>hydrogenicR</strong>(n, l, Z, r)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the n-th normalized hydrogenic bound state
radial wavefunction,</p>

<p>R_n := 2 (Z^@3/2@/n^2) \sqrt@(n-l-1)!/(n+l)!@ \exp(-Z r/n) (2Zr/n)^l
        L^@2l+1@_@n-l-1@(2Zr/n).</p>

<p>where L^a_b(x) is the generalized Laguerre polynomial (Laguerre Functions).
The normalization is chosen such that the wavefunction \psi is
given by
$\psi(n,l,r) = R_n Y_lm$
\psi(n,l,r) = R_n Y_@lm@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6603
6604
6605
6606
6607
6608
6609
6610
6611
6612
6613
6614
6615</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6603</span>

static VALUE
sf_s_hydrogenicR(VALUE mod, VALUE v0, VALUE v1, VALUE v2, VALUE v3){
#line 37 &quot;../gen/tmpl/m_DFloat_f_int_x2_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[2];

    opts[0] = NUM2INT(v0);
    opts[1] = NUM2INT(v1);

    return na_ndloop3(&amp;ndf, opts, 2, v2, v3);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_1-class_method">
  
    .<strong>hydrogenicR_1</strong>(Z, r)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$
R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6495
6496
6497
6498
6499
6500
6501
6502
6503</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6495</span>

static VALUE
sf_s_hydrogenicR_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_1_e-class_method">
  
    .<strong>hydrogenicR_1_e</strong>(Z, r)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction $R_1 := 2Z \sqrtZ \exp(-Z r)$
R_1 := 2Z \sqrt@Z@ \exp(-Z r).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6541
6542
6543
6544
6545
6546
6547
6548
6549
6550
6551
6552
6553
6554
6555
6556
6557</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6541</span>

static VALUE
sf_s_hydrogenicR_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hydrogenicR_e-class_method">
  
    .<strong>hydrogenicR_e</strong>(n, l, Z, r)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the n-th normalized hydrogenic bound state
radial wavefunction,</p>

<p>R_n := 2 (Z^@3/2@/n^2) \sqrt@(n-l-1)!/(n+l)!@ \exp(-Z r/n) (2Zr/n)^l
        L^@2l+1@_@n-l-1@(2Zr/n).</p>

<p>where L^a_b(x) is the generalized Laguerre polynomial (Laguerre Functions).
The normalization is chosen such that the wavefunction \psi is
given by
$\psi(n,l,r) = R_n Y_lm$
\psi(n,l,r) = R_n Y_@lm@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>Z</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


6671
6672
6673
6674
6675
6676
6677
6678
6679
6680
6681
6682
6683
6684
6685
6686
6687
6688
6689
6690
6691
6692
6693
6694</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 6671</span>

static VALUE
sf_s_hydrogenicR_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hydrogenicR_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //n
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_0F1-class_method">
  
    .<strong>hyperg_0F1</strong>(c, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}<em>0F_1(c,x)$
0F1(c,x).
It is related to Bessel functions
0F1[c,x] =
Gamma[c]    x^(1/2(1-c)) I</em>(c-1)(2 Sqrt[x])
Gamma[c] (-x)^(1/2(1-c)) J_(c-1)(2 Sqrt[-x])
exceptions: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16004
16005
16006
16007
16008
16009
16010
16011
16012</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16004</span>

static VALUE
sf_s_hyperg_0F1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_0F1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_0F1_e-class_method">
  
    .<strong>hyperg_0F1_e</strong>(c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}<em>0F_1(c,x)$
0F1(c,x).
It is related to Bessel functions
0F1[c,x] =
Gamma[c]    x^(1/2(1-c)) I</em>(c-1)(2 Sqrt[x])
Gamma[c] (-x)^(1/2(1-c)) J_(c-1)(2 Sqrt[-x])
exceptions: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16054
16055
16056
16057
16058
16059
16060
16061
16062
16063
16064
16065
16066
16067
16068
16069
16070</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16054</span>

static VALUE
sf_s_hyperg_0F1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_0F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1-class_method">
  
    .<strong>hyperg_1F1</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(a,b,x) = M(a,b,x)$
1F1(a,b,x) = M(a,b,x) for general parameters a, b.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16242
16243
16244
16245
16246
16247
16248
16249
16250</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16242</span>

static VALUE
sf_s_hyperg_1F1(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_e-class_method">
  
    .<strong>hyperg_1F1_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(a,b,x) = M(a,b,x)$
1F1(a,b,x) = M(a,b,x) for general parameters a, b.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16292
16293
16294
16295
16296
16297
16298
16299
16300
16301
16302
16303
16304
16305
16306
16307
16308</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16292</span>

static VALUE
sf_s_hyperg_1F1_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_int-class_method">
  
    .<strong>hyperg_1F1_int</strong>(m, n, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(m,n,x) = M(m,n,x)$
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16112
16113
16114
16115
16116
16117
16118
16119
16120
16121
16122
16123
16124
16125
16126
16127
16128
16129
16130
16131
16132
16133
16134
16135</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16112</span>

static VALUE
sf_s_hyperg_1F1_int(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_int,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_1F1_int_e-class_method">
  
    .<strong>hyperg_1F1_int_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
${}_1F_1(m,n,x) = M(m,n,x)$
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16181
16182
16183
16184
16185
16186
16187
16188
16189
16190
16191
16192
16193
16194
16195
16196
16197
16198
16199
16200
16201
16202
16203
16204</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16181</span>

static VALUE
sf_s_hyperg_1F1_int_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_1F1_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F0-class_method">
  
    .<strong>hyperg_2F0</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &lt; 0 we
have
${}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)$
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17189
17190
17191
17192
17193
17194
17195
17196
17197</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17189</span>

static VALUE
sf_s_hyperg_2F0(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F0, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F0_e-class_method">
  
    .<strong>hyperg_2F0_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypergeometric function ${}_2F_0(a,b,x)$
2F0(a,b,x).  The series representation
is a divergent hypergeometric series.  However, for x &lt; 0 we
have
${}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)$
2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17242
17243
17244
17245
17246
17247
17248
17249
17250
17251
17252
17253
17254
17255
17256
17257
17258</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17242</span>

static VALUE
sf_s_hyperg_2F0_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1-class_method">
  
    .<strong>hyperg_2F1</strong>(a, b, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a,b,c,x) = F(a,b,c,x)$
2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.</p>

<p>If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code GSL_EMAXITER when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16712
16713
16714
16715
16716
16717
16718
16719
16720
16721
16722
16723
16724
16725
16726
16727
16728</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16712</span>

static VALUE
sf_s_hyperg_2F1(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj-class_method">
  
    .<strong>hyperg_2F1_conj</strong>(aR, aI, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a_R + i a_I, aR - i aI, c, x)$
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters
for |x| &lt; 1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16835
16836
16837
16838
16839
16840
16841
16842
16843
16844
16845
16846
16847
16848
16849
16850
16851</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16835</span>

static VALUE
sf_s_hyperg_2F1_conj(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_e-class_method">
  
    .<strong>hyperg_2F1_conj_e</strong>(aR, aI, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a_R + i a_I, aR - i aI, c, x)$
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters
for |x| &lt; 1.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16896
16897
16898
16899
16900
16901
16902
16903
16904
16905
16906
16907
16908
16909
16910
16911
16912</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16896</span>

static VALUE
sf_s_hyperg_2F1_conj_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_renorm-class_method">
  
    .<strong>hyperg_2F1_conj_renorm</strong>(aR, aI, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17071
17072
17073
17074
17075
17076
17077
17078
17079
17080
17081
17082
17083
17084
17085
17086
17087</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17071</span>

static VALUE
sf_s_hyperg_2F1_conj_renorm(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_renorm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_conj_renorm_e-class_method">
  
    .<strong>hyperg_2F1_conj_renorm_e</strong>(aR, aI, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)$
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>aR</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>aI</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17132
17133
17134
17135
17136
17137
17138
17139
17140
17141
17142
17143
17144
17145
17146
17147
17148</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17132</span>

static VALUE
sf_s_hyperg_2F1_conj_renorm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_conj_renorm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_e-class_method">
  
    .<strong>hyperg_2F1_e</strong>(a, b, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Gauss hypergeometric function
${}_2F_1(a,b,c,x) = F(a,b,c,x)$
2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.</p>

<p>If the arguments (a,b,c,x) are too close to a singularity then
the function can return the error code GSL_EMAXITER when the
series approximation converges too slowly.  This occurs in the region of
x=1, c - a - b = m for integer m.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16778
16779
16780
16781
16782
16783
16784
16785
16786
16787
16788
16789
16790
16791
16792
16793
16794</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16778</span>

static VALUE
sf_s_hyperg_2F1_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_renorm-class_method">
  
    .<strong>hyperg_2F1_renorm</strong>(a, b, c, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a,b,c,x) / \Gamma(c)$
2F1(a,b,c,x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16953
16954
16955
16956
16957
16958
16959
16960
16961
16962
16963
16964
16965
16966
16967
16968
16969</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16953</span>

static VALUE
sf_s_hyperg_2F1_renorm(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_renorm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_2F1_renorm_e-class_method">
  
    .<strong>hyperg_2F1_renorm_e</strong>(a, b, c, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the renormalized Gauss hypergeometric function
${}_2F_1(a,b,c,x) / \Gamma(c)$
2F1(a,b,c,x) / \Gamma(c) for |x| &lt; 1.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>c</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17014
17015
17016
17017
17018
17019
17020
17021
17022
17023
17024
17025
17026
17027
17028
17029
17030</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17014</span>

static VALUE
sf_s_hyperg_2F1_renorm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_2F1_renorm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U-class_method">
  
    .<strong>hyperg_U</strong>(a, b, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function U(a,b,x).
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16544
16545
16546
16547
16548
16549
16550
16551
16552</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16544</span>

static VALUE
sf_s_hyperg_U(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 36 &quot;../gen/tmpl/m_DFloat_f_DFloat_x3.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U, STRIDE_LOOP|NDF_EXTRACT, 3,1, ain,aout};

    return na_ndloop(&amp;ndf, 3, v0, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_e-class_method">
  
    .<strong>hyperg_U_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function U(a,b,x).
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16592
16593
16594
16595
16596
16597
16598
16599
16600
16601
16602
16603
16604
16605
16606
16607
16608</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16592</span>

static VALUE
sf_s_hyperg_U_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_e10_e-class_method">
  
    .<strong>hyperg_U_e10_e</strong>(a, b, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the confluent hypergeometric function
U(a,b,x) using the gsl_sf_result_e10 type to return a
result with extended range.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16650
16651
16652
16653
16654
16655
16656
16657
16658
16659
16660
16661
16662
16663
16664
16665
16666</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16650</span>

static VALUE
sf_s_hyperg_U_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    3,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,3,v0,v1,v2); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int-class_method">
  
    .<strong>hyperg_U_int</strong>(m, n, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16349
16350
16351
16352
16353
16354
16355
16356
16357
16358
16359
16360
16361
16362
16363
16364
16365
16366
16367
16368
16369
16370
16371
16372</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16349</span>

static VALUE
sf_s_hyperg_U_int(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int_e-class_method">
  
    .<strong>hyperg_U_int_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the confluent hypergeometric function
U(m,n,x) for integer parameters m, n.
exceptions:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16417
16418
16419
16420
16421
16422
16423
16424
16425
16426
16427
16428
16429
16430
16431
16432
16433
16434
16435
16436
16437
16438
16439
16440</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16417</span>

static VALUE
sf_s_hyperg_U_int_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hyperg_U_int_e10_e-class_method">
  
    .<strong>hyperg_U_int_e10_e</strong>(m, n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the confluent hypergeometric function
U(m,n,x) for integer parameters m, n using the
gsl_sf_result_e10 type to return a result with extended range.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, result.e10, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


16485
16486
16487
16488
16489
16490
16491
16492
16493
16494
16495
16496
16497
16498
16499
16500
16501
16502
16503
16504
16505
16506
16507
16508</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 16485</span>

static VALUE
sf_s_hyperg_U_int_e10_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cI,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hyperg_U_int_e10_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //m
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hypot-class_method">
  
    .<strong>hypot</strong>(x, y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypotenuse function $\sqrt+ y^2$
\sqrt@+ y^2@ avoiding overflow and underflow.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23506
23507
23508
23509
23510
23511
23512
23513
23514</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23506</span>

static VALUE
sf_s_hypot(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hypot, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hypot_e-class_method">
  
    .<strong>hypot_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the hypotenuse function $\sqrt+ y^2$
\sqrt@+ y^2@ avoiding overflow and underflow.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23552
23553
23554
23555
23556
23557
23558
23559
23560
23561
23562
23563
23564
23565
23566
23567
23568</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23552</span>

static VALUE
sf_s_hypot_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hypot_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hzeta-class_method">
  
    .<strong>hzeta</strong>(s, q)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Hurwitz zeta function \zeta(s,q) for
s &gt; 1, q &gt; 0.
Domain: s &gt; 1.0, q &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24703
24704
24705
24706
24707
24708
24709
24710
24711</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24703</span>

static VALUE
sf_s_hzeta(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_hzeta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hzeta_e-class_method">
  
    .<strong>hzeta_e</strong>(s, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Hurwitz zeta function \zeta(s,q) for
s &gt; 1, q &gt; 0.
Domain: s &gt; 1.0, q &gt; 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24750
24751
24752
24753
24754
24755
24756
24757
24758
24759
24760
24761
24762
24763
24764
24765
24766</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24750</span>

static VALUE
sf_s_hzeta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_hzeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_1-class_method">
  
    .<strong>laguerre_1</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17473
17474
17475
17476
17477
17478
17479
17480
17481</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17473</span>

static VALUE
sf_s_laguerre_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_1_e-class_method">
  
    .<strong>laguerre_1_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17606
17607
17608
17609
17610
17611
17612
17613
17614
17615
17616
17617
17618
17619
17620
17621
17622</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17606</span>

static VALUE
sf_s_laguerre_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_2-class_method">
  
    .<strong>laguerre_2</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17516
17517
17518
17519
17520
17521
17522
17523
17524</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17516</span>

static VALUE
sf_s_laguerre_2(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_2, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_2_e-class_method">
  
    .<strong>laguerre_2_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17661
17662
17663
17664
17665
17666
17667
17668
17669
17670
17671
17672
17673
17674
17675
17676
17677</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17661</span>

static VALUE
sf_s_laguerre_2_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_3-class_method">
  
    .<strong>laguerre_3</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17559
17560
17561
17562
17563
17564
17565
17566
17567</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17559</span>

static VALUE
sf_s_laguerre_3(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_3, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_3_e-class_method">
  
    .<strong>laguerre_3_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_1(x), L^a_2(x), L^a_3(x) using explicit
representations.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17716
17717
17718
17719
17720
17721
17722
17723
17724
17725
17726
17727
17728
17729
17730
17731
17732</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17716</span>

static VALUE
sf_s_laguerre_3_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_n-class_method">
  
    .<strong>laguerre_n</strong>(n, a, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &gt; -1,
$n \ge 0$
n &gt;= 0.</p>

<p>Domain: a &gt; -1.0, n &gt;= 0
Evaluate generalized Laguerre polynomials.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17776
17777
17778
17779
17780
17781
17782
17783
17784
17785
17786
17787
17788
17789
17790
17791
17792
17793
17794
17795</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17776</span>

static VALUE
sf_s_laguerre_n(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_n,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="laguerre_n_e-class_method">
  
    .<strong>laguerre_n_e</strong>(n, a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines evaluate the generalized Laguerre polynomials
L^a_n(x) for a &gt; -1,
$n \ge 0$
n &gt;= 0.</p>

<p>Domain: a &gt; -1.0, n &gt;= 0
Evaluate generalized Laguerre polynomials.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17843
17844
17845
17846
17847
17848
17849
17850
17851
17852
17853
17854
17855
17856
17857
17858
17859
17860
17861
17862</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17843</span>

static VALUE
sf_s_laguerre_n_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_laguerre_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_W0-class_method">
  
    .<strong>lambert_W0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the principal branch of the Lambert W function, W_0(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17288
17289
17290
17291
17292
17293
17294
17295
17296</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17288</span>

static VALUE
sf_s_lambert_W0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_W0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_W0_e-class_method">
  
    .<strong>lambert_W0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the principal branch of the Lambert W function, W_0(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17330
17331
17332
17333
17334
17335
17336
17337
17338
17339
17340
17341
17342
17343
17344
17345
17346</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17330</span>

static VALUE
sf_s_lambert_W0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_W0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_Wm1-class_method">
  
    .<strong>lambert_Wm1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the secondary real-valued branch of the Lambert W function,
$W_-1(x)$
W_@-1@(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17378
17379
17380
17381
17382
17383
17384
17385
17386</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17378</span>

static VALUE
sf_s_lambert_Wm1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_Wm1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lambert_Wm1_e-class_method">
  
    .<strong>lambert_Wm1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These compute the secondary real-valued branch of the Lambert W function,
$W_-1(x)$
W_@-1@(x).
exceptions: GSL_EDOM, GSL_EMAXITER</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17422
17423
17424
17425
17426
17427
17428
17429
17430
17431
17432
17433
17434
17435
17436
17437
17438</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17422</span>

static VALUE
sf_s_lambert_Wm1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lambert_Wm1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array-class_method">
  
    .<strong>legendre_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
polynomials for 0 \le l \le lmax and
0 \le m \le l for
$|x| \le 1$
|x| &lt;= 1.
The norm parameter specifies which normalization is used.
The normalized P_l^m(x) values are stored in result_array, whose
minimum size can be obtained from calling gsl_sf_legendre_array_n.
The array index of P_l^m(x) is obtained from calling
gsl_sf_legendre_array_index(l, m). To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18732
18733
18734
18735
18736
18737
18738
18739
18740
18741
18742
18743
18744
18745
18746
18747
18748
18749
18750
18751
18752
18753
18754
18755
18756</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18732</span>

static VALUE
sf_s_legendre_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_e-class_method">
  
    .<strong>legendre_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
polynomials for 0 \le l \le lmax and
0 \le m \le l for
$|x| \le 1$
|x| &lt;= 1.
The norm parameter specifies which normalization is used.
The normalized P_l^m(x) values are stored in result_array, whose
minimum size can be obtained from calling gsl_sf_legendre_array_n.
The array index of P_l^m(x) is obtained from calling
gsl_sf_legendre_array_index(l, m). To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18814
18815
18816
18817
18818
18819
18820
18821
18822
18823
18824
18825
18826
18827
18828
18829
18830
18831
18832
18833
18834
18835
18836
18837
18838
18839
18840</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18814</span>

static VALUE
sf_s_legendre_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_index-class_method">
  
    .<strong>legendre_array_index</strong>(l, m)  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index into result_array,
result_deriv_array, or result_deriv2_array corresponding
to P_l^m(x), P_l^‘m(x), or P_l^‘‘m(x). The
index is given by l(l+1)/2 + m.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19568
19569
19570
19571
19572
19573
19574
19575
19576
19577
19578
19579
19580
19581
19582
19583
19584</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19568</span>

static VALUE
sf_s_legendre_array_index(VALUE mod,VALUE v0,VALUE v1)
{
    
    size_t c0;
    size_t c1;
    size_t c2;
    
    c0 = NUM2SIZET(v0);
    c1 = NUM2SIZET(v1);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_legendre_array_index(c0,c1);
    
    return SIZET2NUM(c2);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_array_n-class_method">
  
    .<strong>legendre_array_n</strong>(lmax)  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the minimum array size for maximum degree lmax
needed for the array versions of the associated Legendre functions.
Size is calculated as the total number of P_l^m(x) functions,
plus extra space for precomputing multiplicative factors used in the
recurrence relations.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19539
19540
19541
19542
19543
19544
19545
19546
19547
19548
19549
19550
19551
19552
19553</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19539</span>

static VALUE
sf_s_legendre_array_n(VALUE mod,VALUE v0)
{
    
    size_t c0;
    size_t c1;
    
    c0 = NUM2SIZET(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c1 = gsl_sf_legendre_array_n(c0);
    
    return SIZET2NUM(c1);
    
#line 27 &quot;../gen/tmpl/mod_func_scalar.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_alt_array-class_method">
  
    .<strong>legendre_deriv2_alt_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(\cos\theta)/d\theta, and their second derivatives
d^2 P_l^m(\cos\theta)/d\theta^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19409
19410
19411
19412
19413
19414
19415
19416
19417
19418
19419
19420
19421
19422
19423
19424
19425
19426
19427
19428
19429
19430
19431
19432
19433</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19409</span>

static VALUE
sf_s_legendre_deriv2_alt_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_alt_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_alt_array_e-class_method">
  
    .<strong>legendre_deriv2_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(\cos\theta)/d\theta, and their second derivatives
d^2 P_l^m(\cos\theta)/d\theta^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19498
19499
19500
19501
19502
19503
19504
19505
19506
19507
19508
19509
19510
19511
19512
19513
19514
19515
19516
19517
19518
19519
19520
19521
19522
19523
19524</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19498</span>

static VALUE
sf_s_legendre_deriv2_alt_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_alt_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_array-class_method">
  
    .<strong>legendre_deriv2_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(x)/dx, and their second derivatives
d^2 P_l^m(x)/dx^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19233
19234
19235
19236
19237
19238
19239
19240
19241
19242
19243
19244
19245
19246
19247
19248
19249
19250
19251
19252
19253
19254
19255
19256
19257</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19233</span>

static VALUE
sf_s_legendre_deriv2_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv2_array_e-class_method">
  
    .<strong>legendre_deriv2_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x), their first derivatives
dP_l^m(x)/dx, and their second derivatives
d^2 P_l^m(x)/dx^2 are stored in result_array,
result_deriv_array, and result_deriv2_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], result_deriv2_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19321
19322
19323
19324
19325
19326
19327
19328
19329
19330
19331
19332
19333
19334
19335
19336
19337
19338
19339
19340
19341
19342
19343
19344
19345
19346
19347</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19321</span>

static VALUE
sf_s_legendre_deriv2_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,1,shape},{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv2_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_alt_array-class_method">
  
    .<strong>legendre_deriv_alt_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The normalized P_l^m(x) values and their derivatives
dP_l^m(\cos\theta)/d\theta are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19063
19064
19065
19066
19067
19068
19069
19070
19071
19072
19073
19074
19075
19076
19077
19078
19079
19080
19081
19082
19083
19084
19085
19086
19087</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19063</span>

static VALUE
sf_s_legendre_deriv_alt_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_alt_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_alt_array_e-class_method">
  
    .<strong>legendre_deriv_alt_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The normalized P_l^m(x) values and their derivatives
dP_l^m(\cos\theta)/d\theta are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19146
19147
19148
19149
19150
19151
19152
19153
19154
19155
19156
19157
19158
19159
19160
19161
19162
19163
19164
19165
19166
19167
19168
19169
19170
19171
19172</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19146</span>

static VALUE
sf_s_legendre_deriv_alt_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_alt_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_array-class_method">
  
    .<strong>legendre_deriv_array</strong>(norm, lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x) values and their derivatives
dP_l^m(x)/dx are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18897
18898
18899
18900
18901
18902
18903
18904
18905
18906
18907
18908
18909
18910
18911
18912
18913
18914
18915
18916
18917
18918
18919
18920
18921</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18897</span>

static VALUE
sf_s_legendre_deriv_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_deriv_array_e-class_method">
  
    .<strong>legendre_deriv_array_e</strong>(norm, lmax, x, csphase)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree lmax for
$|x| &lt; 1$
|x| &lt; 1.
The parameter norm specifies the normalization used. The
normalized P_l^m(x) values and their derivatives
dP_l^m(x)/dx are stored in result_array and
result_deriv_array respectively.
To include or exclude
the Condon-Shortley phase factor of (-1)^m, set the parameter
csphase to either -1 or 1 respectively in the
_e function. This factor is included by default.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>norm</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Type of normalization to use. The possible values are: Numo::GSL::Sf::Legendre::NONE, Numo::GSL::Sf::Legendre::SCHMIDT, Numo::GSL::Sf::Legendre::SPHARM, Numo::GSL::Sf::Legendre::FULL</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>csphase</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>To include or exclude the Condon-Shortley phase factor of (-1)^m, set the parameter csphase to either -1 or 1 respectively.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18981
18982
18983
18984
18985
18986
18987
18988
18989
18990
18991
18992
18993
18994
18995
18996
18997
18998
18999
19000
19001
19002
19003
19004
19005
19006
19007</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18981</span>

static VALUE
sf_s_legendre_deriv_array_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    gsl_sf_legendre_t c0;
    size_t c1;
    double c3;
    
#line 36 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_deriv_array_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[3];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //norm
    c1 = NUM2SIZET(v1); opt[1] = &amp;c1; //lmax
    c3 = NUM2DBL(v3); opt[2] = &amp;c3; //csphase
    
    shape[0] = gsl_sf_legendre_array_n(c1);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d-class_method">
  
    .<strong>legendre_H3d</strong>(l, lambda, eta)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the l-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$
\eta &gt;= 0, $l \ge 0$
l &gt;= 0. In the flat limit this takes the form
$L^H3d_l(\lambda,\eta) = j_l(\lambda\eta)$
L^@H3d@_l(\lambda,\eta) = j_l(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20771
20772
20773
20774
20775
20776
20777
20778
20779
20780
20781
20782
20783
20784
20785
20786
20787
20788
20789
20790</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20771</span>

static VALUE
sf_s_legendre_H3d(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_0-class_method">
  
    .<strong>legendre_H3d_0</strong>(lambda, eta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script>
L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_0(\lambda,\eta) = j_0(\lambda\eta)$
L^@H3d@_0(\lambda,\eta) = j_0(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20549
20550
20551
20552
20553
20554
20555
20556
20557</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20549</span>

static VALUE
sf_s_legendre_H3d_0(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_0, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_0_e-class_method">
  
    .<strong>legendre_H3d_0_e</strong>(lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_0(\lambda,\eta) := \over \lambda\sinh(\eta)</script>
L^@H3d@_0(\lambda,\eta) := \sin(\lambda\eta)/(\lambda\sinh(\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_0(\lambda,\eta) = j_0(\lambda\eta)$
L^@H3d@_0(\lambda,\eta) = j_0(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20602
20603
20604
20605
20606
20607
20608
20609
20610
20611
20612
20613
20614
20615
20616
20617
20618</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20602</span>

static VALUE
sf_s_legendre_H3d_0_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_1-class_method">
  
    .<strong>legendre_H3d_1</strong>(lambda, eta)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script>
L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_1(\lambda,\eta) = j_1(\lambda\eta)$
L^@H3d@_1(\lambda,\eta) = j_1(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20659
20660
20661
20662
20663
20664
20665
20666
20667</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20659</span>

static VALUE
sf_s_legendre_H3d_1(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_1, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_1_e-class_method">
  
    .<strong>legendre_H3d_1_e</strong>(lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,
<script type="math/tex">L^H3d_1(\lambda,\eta) := + 1} \eta)\over \lambda \sinh(\eta)\right) \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)</script>
L^@H3d@_1(\lambda,\eta) := 1/\sqrt@+ 1@ \sin(\lambda \eta)/(\lambda \sinh(\eta)) (\coth(\eta) - \lambda \cot(\lambda\eta))
for $\eta \ge 0$
\eta &gt;= 0.
In the flat limit this takes the form
$L^H3d_1(\lambda,\eta) = j_1(\lambda\eta)$
L^@H3d@_1(\lambda,\eta) = j_1(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20712
20713
20714
20715
20716
20717
20718
20719
20720
20721
20722
20723
20724
20725
20726
20727
20728</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20712</span>

static VALUE
sf_s_legendre_H3d_1_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_array-class_method">
  
    .<strong>legendre_H3d_array</strong>(lmax, lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an array of radial eigenfunctions
$L^H3d_l( \lambda, \eta)$
L^@H3d@_l(\lambda, \eta)
for $0 \le l \le lmax$
0 &lt;= l &lt;= lmax.
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20902
20903
20904
20905
20906
20907
20908
20909
20910
20911
20912
20913
20914
20915
20916
20917
20918
20919
20920
20921</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20902</span>

static VALUE
sf_s_legendre_H3d_array(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_H3d_e-class_method">
  
    .<strong>legendre_H3d_e</strong>(l, lambda, eta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the l-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space $\eta \ge 0$
\eta &gt;= 0, $l \ge 0$
l &gt;= 0. In the flat limit this takes the form
$L^H3d_l(\lambda,\eta) = j_l(\lambda\eta)$
L^@H3d@_l(\lambda,\eta) = j_l(\lambda\eta).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>lambda</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>eta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20837
20838
20839
20840
20841
20842
20843
20844
20845
20846
20847
20848
20849
20850
20851
20852
20853
20854
20855
20856</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20837</span>

static VALUE
sf_s_legendre_H3d_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_H3d_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P1-class_method">
  
    .<strong>legendre_P1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17895
17896
17897
17898
17899
17900
17901
17902
17903</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17895</span>

static VALUE
sf_s_legendre_P1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P1_e-class_method">
  
    .<strong>legendre_P1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18022
18023
18024
18025
18026
18027
18028
18029
18030
18031
18032
18033
18034
18035
18036
18037
18038</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18022</span>

static VALUE
sf_s_legendre_P1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P2-class_method">
  
    .<strong>legendre_P2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17936
17937
17938
17939
17940
17941
17942
17943
17944</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17936</span>

static VALUE
sf_s_legendre_P2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P2_e-class_method">
  
    .<strong>legendre_P2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18075
18076
18077
18078
18079
18080
18081
18082
18083
18084
18085
18086
18087
18088
18089
18090
18091</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18075</span>

static VALUE
sf_s_legendre_P2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P3-class_method">
  
    .<strong>legendre_P3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


17977
17978
17979
17980
17981
17982
17983
17984
17985</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 17977</span>

static VALUE
sf_s_legendre_P3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_P3_e-class_method">
  
    .<strong>legendre_P3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomials
$P_l(x)$
P_l(x) using explicit
representations for l=1, 2, 3.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18128
18129
18130
18131
18132
18133
18134
18135
18136
18137
18138
18139
18140
18141
18142
18143
18144</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18128</span>

static VALUE
sf_s_legendre_P3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_P3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl-class_method">
  
    .<strong>legendre_Pl</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomial $P_l(x)$
P_l(x) for a specific value of l,
x subject to $l \ge 0$
l &gt;= 0,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18182
18183
18184
18185
18186
18187
18188
18189
18190
18191
18192
18193</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18182</span>

static VALUE
sf_s_legendre_Pl(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_array-class_method">
  
    .<strong>legendre_Pl_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute arrays of Legendre polynomials
P_l(x) and derivatives dP_l(x)/dx,
for l = 0, \dots, lmax,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18300
18301
18302
18303
18304
18305
18306
18307
18308
18309
18310
18311
18312
18313
18314
18315
18316
18317
18318
18319</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18300</span>

static VALUE
sf_s_legendre_Pl_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,2,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_deriv_array-class_method">
  
    .<strong>legendre_Pl_deriv_array</strong>(lmax, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions compute arrays of Legendre polynomials
P_l(x) and derivatives dP_l(x)/dx,
for l = 0, \dots, lmax,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>lmax</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_array[], result_deriv_array[], return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18366
18367
18368
18369
18370
18371
18372
18373
18374
18375
18376
18377
18378
18379
18380
18381
18382
18383
18384
18385</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18366</span>

static VALUE
sf_s_legendre_Pl_deriv_array(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    
    size_t shape[1]; 

    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,1,shape},{cDF,1,shape},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_deriv_array,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //lmax
    
    shape[0] = gsl_sf_legendre_array_n(c0);    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Pl_e-class_method">
  
    .<strong>legendre_Pl_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions evaluate the Legendre polynomial $P_l(x)$
P_l(x) for a specific value of l,
x subject to $l \ge 0$
l &gt;= 0,
$|x| \le 1$
|x| &lt;= 1
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18237
18238
18239
18240
18241
18242
18243
18244
18245
18246
18247
18248
18249
18250
18251
18252
18253
18254
18255
18256</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18237</span>

static VALUE
sf_s_legendre_Pl_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Pl_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Plm-class_method">
  
    .<strong>legendre_Plm</strong>(l, m, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the associated Legendre polynomial
P_l^m(x) for $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19628
19629
19630
19631
19632
19633
19634
19635
19636
19637
19638
19639
19640
19641
19642
19643
19644
19645
19646
19647
19648
19649
19650
19651</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19628</span>

static VALUE
sf_s_legendre_Plm(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Plm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Plm_e-class_method">
  
    .<strong>legendre_Plm_e</strong>(l, m, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the associated Legendre polynomial
P_l^m(x) for $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1.
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19699
19700
19701
19702
19703
19704
19705
19706
19707
19708
19709
19710
19711
19712
19713
19714
19715
19716
19717
19718
19719
19720
19721
19722</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19699</span>

static VALUE
sf_s_legendre_Plm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Plm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q0-class_method">
  
    .<strong>legendre_Q0</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_0(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18417
18418
18419
18420
18421
18422
18423
18424
18425</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18417</span>

static VALUE
sf_s_legendre_Q0(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q0, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q0_e-class_method">
  
    .<strong>legendre_Q0_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_0(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18461
18462
18463
18464
18465
18466
18467
18468
18469
18470
18471
18472
18473
18474
18475
18476
18477</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18461</span>

static VALUE
sf_s_legendre_Q0_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q0_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q1-class_method">
  
    .<strong>legendre_Q1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_1(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18509
18510
18511
18512
18513
18514
18515
18516
18517</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18509</span>

static VALUE
sf_s_legendre_Q1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Q1_e-class_method">
  
    .<strong>legendre_Q1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_1(x) for x &gt;
-1, $x \ne 1$
x != 1.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18553
18554
18555
18556
18557
18558
18559
18560
18561
18562
18563
18564
18565
18566
18567
18568
18569</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18553</span>

static VALUE
sf_s_legendre_Q1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Q1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Ql-class_method">
  
    .<strong>legendre_Ql</strong>(l, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_l(x) for x &gt;
-1, $x \ne 1$
x != 1 and $l \ge 0$
l &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18605
18606
18607
18608
18609
18610
18611
18612
18613
18614
18615
18616</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18605</span>

static VALUE
sf_s_legendre_Ql(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Ql, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_Ql_e-class_method">
  
    .<strong>legendre_Ql_e</strong>(l, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Legendre function Q_l(x) for x &gt;
-1, $x \ne 1$
x != 1 and $l \ge 0$
l &gt;= 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


18658
18659
18660
18661
18662
18663
18664
18665
18666
18667
18668
18669
18670
18671
18672
18673
18674
18675
18676
18677</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 18658</span>

static VALUE
sf_s_legendre_Ql_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_Ql_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //l
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_sphPlm-class_method">
  
    .<strong>legendre_sphPlm</strong>(l, m, x)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized associated Legendre polynomial
$\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$
\sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable
for use in spherical harmonics.  The parameters must satisfy $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19769
19770
19771
19772
19773
19774
19775
19776
19777
19778
19779
19780
19781
19782
19783
19784
19785
19786
19787
19788
19789
19790
19791
19792</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19769</span>

static VALUE
sf_s_legendre_sphPlm(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_sphPlm,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="legendre_sphPlm_e-class_method">
  
    .<strong>legendre_sphPlm_e</strong>(l, m, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the normalized associated Legendre polynomial
$\sqrt(2l+1)/(4\pi) \sqrt(l-m)!/(l+m)! P_l^m(x)$
\sqrt@(2l+1)/(4\pi)@ \sqrt@(l-m)!/(l+m)!@ P_l^m(x) suitable
for use in spherical harmonics.  The parameters must satisfy $m \ge 0$
m &gt;= 0, $l \ge m$
l &gt;= m, $|x| \le 1$
|x| &lt;= 1. Theses routines avoid the overflows
that occur for the standard normalization of P_l^m(x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>l</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


19843
19844
19845
19846
19847
19848
19849
19850
19851
19852
19853
19854
19855
19856
19857
19858
19859
19860
19861
19862
19863
19864
19865
19866</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 19843</span>

static VALUE
sf_s_legendre_sphPlm_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_legendre_sphPlm_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //l
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //m
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnbeta-class_method">
  
    .<strong>lnbeta</strong>(a, b)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Beta Function, \log(B(a,b))
subject to a and b not
being negative integers.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15294
15295
15296
15297
15298
15299
15300
15301
15302</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15294</span>

static VALUE
sf_s_lnbeta(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnbeta, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnbeta_e-class_method">
  
    .<strong>lnbeta_e</strong>(a, b)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Beta Function, \log(B(a,b))
subject to a and b not
being negative integers.
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>b</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


15341
15342
15343
15344
15345
15346
15347
15348
15349
15350
15351
15352
15353
15354
15355
15356
15357</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 15341</span>

static VALUE
sf_s_lnbeta_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnbeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnchoose-class_method">
  
    .<strong>lnchoose</strong>(n, m)  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of n choose m.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14317
14318
14319
14320
14321
14322
14323
14324
14325
14326
14327
14328
14329
14330
14331
14332
14333</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14317</span>

static VALUE
sf_s_lnchoose(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnchoose,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnchoose_e-class_method">
  
    .<strong>lnchoose_e</strong>(n, m)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of n choose m.  This is
equivalent to the sum \log(n!) - \log(m!) - \log((n-m)!).
exceptions: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>m</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14371
14372
14373
14374
14375
14376
14377
14378
14379
14380
14381
14382
14383
14384
14385
14386
14387</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14371</span>

static VALUE
sf_s_lnchoose_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cUI,0},{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnchoose_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lncosh-class_method">
  
    .<strong>lncosh</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\cosh(x)) for any x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23950
23951
23952
23953
23954
23955
23956
23957
23958</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23950</span>

static VALUE
sf_s_lncosh(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lncosh, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lncosh_e-class_method">
  
    .<strong>lncosh_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\cosh(x)) for any x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23992
23993
23994
23995
23996
23997
23998
23999
24000
24001
24002
24003
24004
24005
24006
24007
24008</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23992</span>

static VALUE
sf_s_lncosh_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lncosh_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lndoublefact-class_method">
  
    .<strong>lndoublefact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the double factorial of n,
\log(n!!).
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14120
14121
14122
14123
14124
14125
14126
14127
14128</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14120</span>

static VALUE
sf_s_lndoublefact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lndoublefact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lndoublefact_e-class_method">
  
    .<strong>lndoublefact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the double factorial of n,
\log(n!!).
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14163
14164
14165
14166
14167
14168
14169
14170
14171
14172
14173
14174
14175
14176
14177
14178
14179</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14163</span>

static VALUE
sf_s_lndoublefact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lndoublefact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnfact-class_method">
  
    .<strong>lnfact</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the factorial of n,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170,
but defers for larger n.
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14027
14028
14029
14030
14031
14032
14033
14034
14035</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14027</span>

static VALUE
sf_s_lnfact(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_UInt.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnfact, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnfact_e-class_method">
  
    .<strong>lnfact_e</strong>(n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the factorial of n,
\log(n!).  The algorithm is faster than computing
\ln(\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170,
but defers for larger n.
exceptions: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Numo::UInt</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14072
14073
14074
14075
14076
14077
14078
14079
14080
14081
14082
14083
14084
14085
14086
14087
14088</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14072</span>

static VALUE
sf_s_lnfact_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cUI,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnfact_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma-class_method">
  
    .<strong>lngamma</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not being a negative
integer or zero.  For x&lt;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13430
13431
13432
13433
13434
13435
13436
13437
13438</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13430</span>

static VALUE
sf_s_lngamma(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_complex_e-class_method">
  
    .<strong>lngamma_complex_e</strong>(zr, zi)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes \log(\Gamma(z)) for complex z=z_r+i
z_i and z not a negative integer or zero, using the complex Lanczos
method.  The returned parameters are lnr = \log|\Gamma(z)| and
arg = \arg(\Gamma(z)) in (-\pi,\pi].  Note that the phase
part (arg) is not well-determined when |z| is very large,
due to inevitable roundoff in restricting to (-\pi,\pi].  This
will result in a GSL_ELOSS error when it occurs.  The absolute
value part (lnr), however, never suffers from loss of precision.
exceptions: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>zr</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>zi</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [lnr.val, lnr.err, arg.val, arg.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13785
13786
13787
13788
13789
13790
13791
13792
13793
13794
13795
13796
13797
13798
13799
13800
13801</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13785</span>

static VALUE
sf_s_lngamma_complex_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_complex_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_e-class_method">
  
    .<strong>lngamma_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Gamma function,
\log(\Gamma(x)), subject to x not being a negative
integer or zero.  For x&lt;0 the real part of \log(\Gamma(x)) is
returned, which is equivalent to \log(|\Gamma(x)|).  The function
is computed using the real Lanczos method.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13476
13477
13478
13479
13480
13481
13482
13483
13484
13485
13486
13487
13488
13489
13490
13491
13492</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13476</span>

static VALUE
sf_s_lngamma_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lngamma_sgn_e-class_method">
  
    .<strong>lngamma_sgn_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the sign of the gamma function and the logarithm of
its magnitude, subject to x not being a negative integer or zero.  The
function is computed using the real Lanczos method.  The value of the
gamma function and its error can be reconstructed using the relation
\Gamma(x) = sgn * \exp(result_lg), taking into account the two
components of result_lg.
exceptions: GSL_EDOM, GSL_EROUND</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result_lg.val, result_lg.err, sgn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


13534
13535
13536
13537
13538
13539
13540
13541
13542
13543
13544
13545
13546
13547
13548
13549
13550</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 13534</span>

static VALUE
sf_s_lngamma_sgn_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lngamma_sgn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch-class_method">
  
    .<strong>lnpoch</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14631
14632
14633
14634
14635
14636
14637
14638
14639</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14631</span>

static VALUE
sf_s_lnpoch(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch_e-class_method">
  
    .<strong>lnpoch_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the Pochhammer symbol,
\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a)).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14677
14678
14679
14680
14681
14682
14683
14684
14685
14686
14687
14688
14689
14690
14691
14692
14693</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14677</span>

static VALUE
sf_s_lnpoch_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnpoch_sgn_e-class_method">
  
    .<strong>lnpoch_sgn_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sign of the Pochhammer symbol and the
logarithm of its magnitude.  The computed parameters are result =
\log(|(a)_x|) with a corresponding error term,
and sgn = \sgn((a)_x) where (a)_x =
\Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, sgn, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14737
14738
14739
14740
14741
14742
14743
14744
14745
14746
14747
14748
14749
14750
14751
14752
14753</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14737</span>

static VALUE
sf_s_lnpoch_sgn_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[4] = {{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnpoch_sgn_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,4,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnsinh-class_method">
  
    .<strong>lnsinh</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\sinh(x)) for x &gt; 0.
Domain: x &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23861
23862
23863
23864
23865
23866
23867
23868
23869</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23861</span>

static VALUE
sf_s_lnsinh(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_lnsinh, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lnsinh_e-class_method">
  
    .<strong>lnsinh_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(\sinh(x)) for x &gt; 0.
Domain: x &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23904
23905
23906
23907
23908
23909
23910
23911
23912
23913
23914
23915
23916
23917
23918
23919
23920</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23904</span>

static VALUE
sf_s_lnsinh_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_lnsinh_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log-class_method">
  
    .<strong>log</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of x, \log(x), for
x &gt; 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20952
20953
20954
20955
20956
20957
20958
20959
20960</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20952</span>

static VALUE
sf_s_log(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx-class_method">
  
    .<strong>log_1plusx</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21192
21193
21194
21195
21196
21197
21198
21199
21200</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21192</span>

static VALUE
sf_s_log_1plusx(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_e-class_method">
  
    .<strong>log_1plusx_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21236
21237
21238
21239
21240
21241
21242
21243
21244
21245
21246
21247
21248
21249
21250
21251
21252</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21236</span>

static VALUE
sf_s_log_1plusx_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_mx-class_method">
  
    .<strong>log_1plusx_mx</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) - x for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21284
21285
21286
21287
21288
21289
21290
21291
21292</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21284</span>

static VALUE
sf_s_log_1plusx_mx(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_mx, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_1plusx_mx_e-class_method">
  
    .<strong>log_1plusx_mx_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \log(1 + x) - x for x &gt; -1 using an
algorithm that is accurate for small x.
Domain: x &gt; -1.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21328
21329
21330
21331
21332
21333
21334
21335
21336
21337
21338
21339
21340
21341
21342
21343
21344</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21328</span>

static VALUE
sf_s_log_1plusx_mx_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_1plusx_mx_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_abs-class_method">
  
    .<strong>log_abs</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the magnitude of x,
\log(|x|), for x \ne 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21042
21043
21044
21045
21046
21047
21048
21049
21050</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21042</span>

static VALUE
sf_s_log_abs(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_abs, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_abs_e-class_method">
  
    .<strong>log_abs_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the magnitude of x,
\log(|x|), for x \ne 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21085
21086
21087
21088
21089
21090
21091
21092
21093
21094
21095
21096
21097
21098
21099
21100
21101</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21085</span>

static VALUE
sf_s_log_abs_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_abs_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_e-class_method">
  
    .<strong>log_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of x, \log(x), for
x &gt; 0.
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


20995
20996
20997
20998
20999
21000
21001
21002
21003
21004
21005
21006
21007
21008
21009
21010
21011</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 20995</span>

static VALUE
sf_s_log_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_erfc-class_method">
  
    .<strong>log_erfc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10251
10252
10253
10254
10255
10256
10257
10258
10259</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10251</span>

static VALUE
sf_s_log_erfc(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_log_erfc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="log_erfc_e-class_method">
  
    .<strong>log_erfc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the logarithm of the complementary error function
\log(\erfc(x)).
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


10294
10295
10296
10297
10298
10299
10300
10301
10302
10303
10304
10305
10306
10307
10308
10309
10310</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 10294</span>

static VALUE
sf_s_log_erfc_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_log_erfc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_a-class_method">
  
    .<strong>mathieu_a</strong>(n, q)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21379
21380
21381
21382
21383
21384
21385
21386
21387
21388
21389
21390</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21379</span>

static VALUE
sf_s_mathieu_a(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_Int_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_a, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_a_e-class_method">
  
    .<strong>mathieu_a_e</strong>(n, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21430
21431
21432
21433
21434
21435
21436
21437
21438
21439
21440
21441
21442
21443
21444
21445
21446
21447
21448
21449</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21430</span>

static VALUE
sf_s_mathieu_a_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_a_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_b-class_method">
  
    .<strong>mathieu_b</strong>(n, q)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21484
21485
21486
21487
21488
21489
21490
21491
21492
21493
21494
21495</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21484</span>

static VALUE
sf_s_mathieu_b(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_Int_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_b, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_b_e-class_method">
  
    .<strong>mathieu_b_e</strong>(n, q)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the characteristic values a_n(q),
b_n(q) of the Mathieu functions ce_n(q,x) and
se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21535
21536
21537
21538
21539
21540
21541
21542
21543
21544
21545
21546
21547
21548
21549
21550
21551
21552
21553
21554</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21535</span>

static VALUE
sf_s_mathieu_b_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_b_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_ce-class_method">
  
    .<strong>mathieu_ce</strong>(n, q, x)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21591
21592
21593
21594
21595
21596
21597
21598
21599
21600
21601
21602</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21591</span>

static VALUE
sf_s_mathieu_ce(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 37 &quot;../gen/tmpl/m_Int_f_int_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_ce, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[1];

    opts[0] = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, opts, 2, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_ce_e-class_method">
  
    .<strong>mathieu_ce_e</strong>(n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21644
21645
21646
21647
21648
21649
21650
21651
21652
21653
21654
21655
21656
21657
21658
21659
21660
21661
21662
21663</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21644</span>

static VALUE
sf_s_mathieu_ce_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_ce_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Mc-class_method">
  
    .<strong>mathieu_Mc</strong>(j, n, q, x)  &#x21d2; <tt>Numo::Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21830
21831
21832
21833
21834
21835
21836
21837
21838
21839
21840
21841
21842
21843
21844
21845
21846
21847
21848
21849
21850
21851
21852
21853</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21830</span>

static VALUE
sf_s_mathieu_Mc(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Mc,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Mc_e-class_method">
  
    .<strong>mathieu_Mc_e</strong>(j, n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21915
21916
21917
21918
21919
21920
21921
21922
21923
21924
21925
21926
21927
21928
21929
21930
21931
21932
21933
21934
21935
21936
21937
21938</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21915</span>

static VALUE
sf_s_mathieu_Mc_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Mc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Ms-class_method">
  
    .<strong>mathieu_Ms</strong>(j, n, q, x)  &#x21d2; <tt>Numo::Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21996
21997
21998
21999
22000
22001
22002
22003
22004
22005
22006
22007
22008
22009
22010
22011
22012
22013
22014
22015
22016
22017
22018
22019</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21996</span>

static VALUE
sf_s_mathieu_Ms(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Ms,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,1,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_Ms_e-class_method">
  
    .<strong>mathieu_Ms_e</strong>(j, n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the radial j-th kind Mathieu functions
$Mc_n^(j)(q,x)$
Mc_n^@(j)@(q,x) and
$Ms_n^(j)(q,x)$
Ms_n^@(j)@(q,x) of order n.</p>

<p>The allowed values of j are 1 and 2.
The functions for j = 3,4 can be computed as
$M_n^(3) = M_n^(1) + iM_n^(2)$
M_n^@(3)@ = M_n^@(1)@ + iM_n^@(2)@ and
$M_n^(4) = M_n^(1) - iM_n^(2)$
M_n^@(4)@ = M_n^@(1)@ - iM_n^@(2)@,
where
$M_n^(j) = Mc_n^(j)$
M_n^@(j)@ = Mc_n^@(j)@ or
$Ms_n^(j)$
Ms_n^@(j)@.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>j</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22081
22082
22083
22084
22085
22086
22087
22088
22089
22090
22091
22092
22093
22094
22095
22096
22097
22098
22099
22100
22101
22102
22103
22104</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22081</span>

static VALUE
sf_s_mathieu_Ms_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    int c0;
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_Ms_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
#line 46 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    void *opt[2];
    
    c0 = NUM2INT(v0); opt[0] = &amp;c0; //j
    c1 = NUM2INT(v1); opt[1] = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v2,v3); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_se-class_method">
  
    .<strong>mathieu_se</strong>(n, q, x)  &#x21d2; <tt>Int</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>parameter</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21700
21701
21702
21703
21704
21705
21706
21707
21708
21709
21710
21711</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21700</span>

static VALUE
sf_s_mathieu_se(VALUE mod, VALUE v0, VALUE v1, VALUE v2){
#line 37 &quot;../gen/tmpl/m_Int_f_int_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_se, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};
    int opts[1];

    opts[0] = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, opts, 2, v1, v2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mathieu_se_e-class_method">
  
    .<strong>mathieu_se_e</strong>(n, q, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the angular Mathieu functions ce_n(q,x)
and se_n(q,x), respectively.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>q</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


21753
21754
21755
21756
21757
21758
21759
21760
21761
21762
21763
21764
21765
21766
21767
21768
21769
21770
21771
21772</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 21753</span>

static VALUE
sf_s_mathieu_se_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_mathieu_se_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,2,v1,v2); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="multiply_e-class_method">
  
    .<strong>multiply_e</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function multiplies x and y storing the product and its
associated error in result.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8368
8369
8370
8371
8372
8373
8374
8375
8376
8377
8378
8379
8380
8381
8382
8383
8384</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8368</span>

static VALUE
sf_s_multiply_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_multiply_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="multiply_err_e-class_method">
  
    .<strong>multiply_err_e</strong>(x, dx, y, dy)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function multiplies x and y with associated absolute
errors dx and dy.  The product
$xy \pm xy \sqrt+(dy/y)^2$
xy +/- xy \sqrt((dx/x)^2 +(dy/y)^2)
is stored in result.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dy</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


8431
8432
8433
8434
8435
8436
8437
8438
8439
8440
8441
8442
8443
8444
8445
8446
8447</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 8431</span>

static VALUE
sf_s_multiply_err_e(VALUE mod,VALUE v0,VALUE v1,VALUE v2,VALUE v3)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[4] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_multiply_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    4,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,4,v0,v1,v2,v3); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="poch-class_method">
  
    .<strong>poch</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a +
x)/\Gamma(a).  The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).  When a and a+x
are negative integers or zero, the limiting value of the ratio is returned.
exceptions:  GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14533
14534
14535
14536
14537
14538
14539
14540
14541</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14533</span>

static VALUE
sf_s_poch(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_poch, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="poch_e-class_method">
  
    .<strong>poch_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Pochhammer symbol (a)_x = \Gamma(a +
x)/\Gamma(a).  The Pochhammer symbol is also known as the Apell symbol and
sometimes written as (a,x).  When a and a+x
are negative integers or zero, the limiting value of the ratio is returned.
exceptions:  GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14581
14582
14583
14584
14585
14586
14587
14588
14589
14590
14591
14592
14593
14594
14595
14596
14597</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14581</span>

static VALUE
sf_s_poch_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_poch_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pochrel-class_method">
  
    .<strong>pochrel</strong>(a, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14787
14788
14789
14790
14791
14792
14793
14794
14795</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14787</span>

static VALUE
sf_s_pochrel(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_DFloat_x2.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_pochrel, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pochrel_e-class_method">
  
    .<strong>pochrel_e</strong>(a, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the relative Pochhammer symbol ((a)_x -
1)/x where (a)_x = \Gamma(a + x)/\Gamma(a).
exceptions:  GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>a</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14833
14834
14835
14836
14837
14838
14839
14840
14841
14842
14843
14844
14845
14846
14847
14848
14849</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14833</span>

static VALUE
sf_s_pochrel_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_pochrel_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="polar_to_rect-class_method">
  
    .<strong>polar_to_rect</strong>(r, theta)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function converts the polar coordinates (r,theta) to
rectilinear coordinates (x,y), x = r\cos(\theta),
y = r\sin(\theta).
Exceptional Return Values: GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>r</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>theta</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [x.val, x.err, y.val, y.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24050
24051
24052
24053
24054
24055
24056
24057
24058
24059
24060
24061
24062
24063
24064
24065
24066</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24050</span>

static VALUE
sf_s_polar_to_rect(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_polar_to_rect,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pow_int-class_method">
  
    .<strong>pow_int</strong>(x, n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the power x^n for integer n.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22141
22142
22143
22144
22145
22146
22147
22148
22149</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22141</span>

static VALUE
sf_s_pow_int(VALUE mod, VALUE v0, VALUE v1){
#line 34 &quot;../gen/tmpl/m_DFloat_f_DFloat_Int.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_pow_int, STRIDE_LOOP|NDF_EXTRACT, 2,1, ain,aout};

    return na_ndloop(&amp;ndf, 2, v0, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pow_int_e-class_method">
  
    .<strong>pow_int_e</strong>(x, n)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the power x^n for integer n.  The
power is computed using the minimum number of multiplications. For
example, x^8 is computed as ((x^2)^2)^2, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22191
22192
22193
22194
22195
22196
22197
22198
22199
22200
22201
22202
22203
22204
22205
22206
22207
22208
22209
22210</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22191</span>

static VALUE
sf_s_pow_int_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c1;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_pow_int_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c1 = NUM2INT(v1); opt = &amp;c1; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v0); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi-class_method">
  
    .<strong>psi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(x) for general
x, x \ne 0.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22320
22321
22322
22323
22324
22325
22326
22327
22328</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22320</span>

static VALUE
sf_s_psi(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1-class_method">
  
    .<strong>psi_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(x) for
general x.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22582
22583
22584
22585
22586
22587
22588
22589
22590</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22582</span>

static VALUE
sf_s_psi_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_e-class_method">
  
    .<strong>psi_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(x) for
general x.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22626
22627
22628
22629
22630
22631
22632
22633
22634
22635
22636
22637
22638
22639
22640
22641
22642</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22626</span>

static VALUE
sf_s_psi_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_int-class_method">
  
    .<strong>psi_1_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(n) for
positive integer n.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22505
22506
22507
22508
22509
22510
22511
22512
22513</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22505</span>

static VALUE
sf_s_psi_1_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1_int_e-class_method">
  
    .<strong>psi_1_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Trigamma function \psi’(n) for
positive integer n.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22527
22528
22529
22530
22531
22532
22533
22534
22535
22536
22537
22538
22539
22540
22541
22542
22543
22544
22545
22546
22547
22548
22549
22550</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22527</span>

static VALUE
sf_s_psi_1_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_psi_1_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1piy-class_method">
  
    .<strong>psi_1piy</strong>(y)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
exceptions: none
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22412
22413
22414
22415
22416
22417
22418
22419
22420</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22412</span>

static VALUE
sf_s_psi_1piy(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1piy, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_1piy_e-class_method">
  
    .<strong>psi_1piy_e</strong>(y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the real part of the digamma function on the line
1+i y, \Re[\psi(1 + i y)].
exceptions: none
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22456
22457
22458
22459
22460
22461
22462
22463
22464
22465
22466
22467
22468
22469
22470
22471
22472</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22456</span>

static VALUE
sf_s_psi_1piy_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_1piy_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_e-class_method">
  
    .<strong>psi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(x) for general
x, x \ne 0.
Domain: x != 0.0, -1.0, -2.0, …
Exceptional Return Values: GSL_EDOM, GSL_ELOSS</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22364
22365
22366
22367
22368
22369
22370
22371
22372
22373
22374
22375
22376
22377
22378
22379
22380</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22364</span>

static VALUE
sf_s_psi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_int-class_method">
  
    .<strong>psi_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(n) for positive
integer n.  The digamma function is also called the Psi function.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22243
22244
22245
22246
22247
22248
22249
22250
22251</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22243</span>

static VALUE
sf_s_psi_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_int_e-class_method">
  
    .<strong>psi_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the digamma function \psi(n) for positive
integer n.  The digamma function is also called the Psi function.
Domain: n integer, n &gt; 0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22265
22266
22267
22268
22269
22270
22271
22272
22273
22274
22275
22276
22277
22278
22279
22280
22281
22282
22283
22284
22285
22286
22287
22288</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22265</span>

static VALUE
sf_s_psi_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_psi_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_n-class_method">
  
    .<strong>psi_n</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the polygamma function $\psi^(n)(x)$
\psi^@(n)@(x) for
$n \ge 0$
n &gt;= 0, x &gt; 0.
Domain: n &gt;= 0, x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22679
22680
22681
22682
22683
22684
22685
22686
22687
22688
22689
22690</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22679</span>

static VALUE
sf_s_psi_n(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_psi_n, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="psi_n_e-class_method">
  
    .<strong>psi_n_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the polygamma function $\psi^(n)(x)$
\psi^@(n)@(x) for
$n \ge 0$
n &gt;= 0, x &gt; 0.
Domain: n &gt;= 0, x &gt; 0.0
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22733
22734
22735
22736
22737
22738
22739
22740
22741
22742
22743
22744
22745
22746
22747
22748
22749
22750
22751
22752</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22733</span>

static VALUE
sf_s_psi_n_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_psi_n_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="rect_to_polar-class_method">
  
    .<strong>rect_to_polar</strong>(x, y)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function converts the rectilinear coordinates (x,y) to
polar coordinates (r,theta), such that x =
r\cos(\theta), y = r\sin(\theta).  The argument theta
lies in the range [-\pi, \pi].
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>y</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [r.val, r.err, theta.val, theta.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24109
24110
24111
24112
24113
24114
24115
24116
24117
24118
24119
24120
24121
24122
24123
24124
24125</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24109</span>

static VALUE
sf_s_rect_to_polar(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[5] = {{cDF,0},{cDF,0},{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_rect_to_polar,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,5,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Shi-class_method">
  
    .<strong>Shi</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$
Shi(x) = \int_0^x dt \sinh(t)/t.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11931
11932
11933
11934
11935
11936
11937
11938
11939</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11931</span>

static VALUE
sf_s_Shi(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Shi, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Shi_e-class_method">
  
    .<strong>Shi_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the integral $\hbox<span class='object_link'><a href="#Shi-class_method" title="Numo::GSL::Sf.Shi (method)">Shi</a></span>(x) = \int_0^x dt \sinh(t)/t$
Shi(x) = \int_0^x dt \sinh(t)/t.
Exceptional Return Values: GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


11974
11975
11976
11977
11978
11979
11980
11981
11982
11983
11984
11985
11986
11987
11988
11989
11990</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 11974</span>

static VALUE
sf_s_Shi_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Shi_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Si-class_method">
  
    .<strong>Si</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Si</a></span>(x) = \int_0^x dt \sin(t)/t$
Si(x) = \int_0^x dt \sin(t)/t.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12207
12208
12209
12210
12211
12212
12213
12214
12215</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12207</span>

static VALUE
sf_s_Si(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_Si, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="Si_e-class_method">
  
    .<strong>Si_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Sine integral $\hbox<span class='object_link'><a href="#Si-class_method" title="Numo::GSL::Sf.Si (method)">Si</a></span>(x) = \int_0^x dt \sin(t)/t$
Si(x) = \int_0^x dt \sin(t)/t.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


12250
12251
12252
12253
12254
12255
12256
12257
12258
12259
12260
12261
12262
12263
12264
12265
12266</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 12250</span>

static VALUE
sf_s_Si_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_Si_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin-class_method">
  
    .<strong>sin</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sine function \sin(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23326
23327
23328
23329
23330
23331
23332
23333
23334</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23326</span>

static VALUE
sf_s_sin(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_sin, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin_e-class_method">
  
    .<strong>sin_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the sine function \sin(x).
Exceptional Return Values:</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23368
23369
23370
23371
23372
23373
23374
23375
23376
23377
23378
23379
23380
23381
23382
23383
23384</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23368</span>

static VALUE
sf_s_sin_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sin_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sin_err_e-class_method">
  
    .<strong>sin_err_e</strong>(x, dx)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This routine computes the sine of an angle x with an associated
absolute error dx,
$\sin(x \pm dx)$
\sin(x \pm dx).  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>dx</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24252
24253
24254
24255
24256
24257
24258
24259
24260
24261
24262
24263
24264
24265
24266
24267
24268</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24252</span>

static VALUE
sf_s_sin_err_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sin_err_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    2,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,2,v0,v1); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sinc-class_method">
  
    .<strong>sinc</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23599
23600
23601
23602
23603
23604
23605
23606
23607</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23599</span>

static VALUE
sf_s_sinc(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_sinc, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sinc_e-class_method">
  
    .<strong>sinc_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \sinc(x) = \sin(\pi x) / (\pi x) for any
value of x.
Exceptional Return Values: none</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23642
23643
23644
23645
23646
23647
23648
23649
23650
23651
23652
23653
23654
23655
23656
23657
23658</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23642</span>

static VALUE
sf_s_sinc_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_sinc_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_1-class_method">
  
    .<strong>synchrotron_1</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first synchrotron function
$x \int_x^\infty dt K_5/3(t)$
x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22786
22787
22788
22789
22790
22791
22792
22793
22794</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22786</span>

static VALUE
sf_s_synchrotron_1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_1_e-class_method">
  
    .<strong>synchrotron_1_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the first synchrotron function
$x \int_x^\infty dt K_5/3(t)$
x \int_x^\infty dt K_@5/3@(t) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22832
22833
22834
22835
22836
22837
22838
22839
22840
22841
22842
22843
22844
22845
22846
22847
22848</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22832</span>

static VALUE
sf_s_synchrotron_1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_2-class_method">
  
    .<strong>synchrotron_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second synchrotron function
$x K_2/3(x)$
x K_@2/3@(x) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22882
22883
22884
22885
22886
22887
22888
22889
22890</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22882</span>

static VALUE
sf_s_synchrotron_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchrotron_2_e-class_method">
  
    .<strong>synchrotron_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the second synchrotron function
$x K_2/3(x)$
x K_@2/3@(x) for $x \ge 0$
x &gt;= 0.
Domain: x &gt;= 0.0
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22928
22929
22930
22931
22932
22933
22934
22935
22936
22937
22938
22939
22940
22941
22942
22943
22944</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22928</span>

static VALUE
sf_s_synchrotron_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_synchrotron_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="taylorcoeff-class_method">
  
    .<strong>taylorcoeff</strong>(n, x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Taylor coefficient x^n / n! for
$x \ge 0$
x &gt;= 0,
$n \ge 0$
n &gt;= 0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14424
14425
14426
14427
14428
14429
14430
14431
14432
14433
14434
14435</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14424</span>

static VALUE
sf_s_taylorcoeff(VALUE mod, VALUE v0, VALUE v1){
#line 33 &quot;../gen/tmpl/m_DFloat_f_int_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_taylorcoeff, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};
    int c0;

    c0 = NUM2INT(v0);

    return na_ndloop3(&amp;ndf, &amp;c0, 1, v1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="taylorcoeff_e-class_method">
  
    .<strong>taylorcoeff_e</strong>(n, x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Taylor coefficient x^n / n! for
$x \ge 0$
x &gt;= 0,
$n \ge 0$
n &gt;= 0.
exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14478
14479
14480
14481
14482
14483
14484
14485
14486
14487
14488
14489
14490
14491
14492
14493
14494
14495
14496
14497</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 14478</span>

static VALUE
sf_s_taylorcoeff_e(VALUE mod,VALUE v0,VALUE v1)
{
    
    int c0;
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_taylorcoeff_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    void *opt;
    c0 = NUM2INT(v0); opt = &amp;c0; //n
    
    
#line 53 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop3(&amp;ndf,opt,1,v1); 
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_2-class_method">
  
    .<strong>transport_2</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(2,x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22974
22975
22976
22977
22978
22979
22980
22981
22982</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 22974</span>

static VALUE
sf_s_transport_2(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_2, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_2_e-class_method">
  
    .<strong>transport_2_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(2,x).
Exceptional Return Values: GSL_EDOM</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23016
23017
23018
23019
23020
23021
23022
23023
23024
23025
23026
23027
23028
23029
23030
23031
23032</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23016</span>

static VALUE
sf_s_transport_2_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_2_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_3-class_method">
  
    .<strong>transport_3</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(3,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23062
23063
23064
23065
23066
23067
23068
23069
23070</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23062</span>

static VALUE
sf_s_transport_3(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_3, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_3_e-class_method">
  
    .<strong>transport_3_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(3,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23104
23105
23106
23107
23108
23109
23110
23111
23112
23113
23114
23115
23116
23117
23118
23119
23120</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23104</span>

static VALUE
sf_s_transport_3_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_3_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_4-class_method">
  
    .<strong>transport_4</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(4,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23150
23151
23152
23153
23154
23155
23156
23157
23158</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23150</span>

static VALUE
sf_s_transport_4(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_4, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_4_e-class_method">
  
    .<strong>transport_4_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(4,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23192
23193
23194
23195
23196
23197
23198
23199
23200
23201
23202
23203
23204
23205
23206
23207
23208</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23192</span>

static VALUE
sf_s_transport_4_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_4_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_5-class_method">
  
    .<strong>transport_5</strong>(x)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(5,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23238
23239
23240
23241
23242
23243
23244
23245
23246</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23238</span>

static VALUE
sf_s_transport_5(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_transport_5, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="transport_5_e-class_method">
  
    .<strong>transport_5_e</strong>(x)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the transport function J(5,x).
Exceptional Return Values: GSL_EDOM, GSL_EUNDRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>x</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


23280
23281
23282
23283
23284
23285
23286
23287
23288
23289
23290
23291
23292
23293
23294
23295
23296</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 23280</span>

static VALUE
sf_s_transport_5_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_transport_5_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta-class_method">
  
    .<strong>zeta</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(s)
for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24437
24438
24439
24440
24441
24442
24443
24444
24445</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24437</span>

static VALUE
sf_s_zeta(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zeta, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_e-class_method">
  
    .<strong>zeta_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(s)
for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24482
24483
24484
24485
24486
24487
24488
24489
24490
24491
24492
24493
24494
24495
24496
24497
24498</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24482</span>

static VALUE
sf_s_zeta_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_zeta_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_int-class_method">
  
    .<strong>zeta_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(n)
for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24358
24359
24360
24361
24362
24363
24364
24365
24366</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24358</span>

static VALUE
sf_s_zeta_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zeta_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zeta_int_e-class_method">
  
    .<strong>zeta_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute the Riemann zeta function \zeta(n)
for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24381
24382
24383
24384
24385
24386
24387
24388
24389
24390
24391
24392
24393
24394
24395
24396
24397
24398
24399
24400
24401
24402
24403
24404</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24381</span>

static VALUE
sf_s_zeta_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_zeta_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1-class_method">
  
    .<strong>zetam1</strong>(s)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(s) - 1 for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24608
24609
24610
24611
24612
24613
24614
24615
24616</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24608</span>

static VALUE
sf_s_zetam1(VALUE mod, VALUE v0){
#line 30 &quot;../gen/tmpl/m_DFloat_f_DFloat.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_e-class_method">
  
    .<strong>zetam1_e</strong>(s)  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(s) - 1 for arbitrary s,
s \ne 1.
Domain: s != 1.0
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>s</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat, Numo::Int]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24652
24653
24654
24655
24656
24657
24658
24659
24660
24661
24662
24663
24664
24665
24666
24667
24668</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24652</span>

static VALUE
sf_s_zetam1_e(VALUE mod,VALUE v0)
{
    
    

#line 38 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    ndfunc_arg_in_t ain[1] = {{cDF,0}};
    ndfunc_arg_out_t aout[3] = {{cDF,0},{cDF,0},{cI,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1_e,NO_LOOP|NDF_INPLACE|NDF_EXTRACT,
                    1,3,ain,aout};
    
    
#line 52 &quot;../gen/tmpl/mod_func_noloop.c&quot;
    return na_ndloop(&amp;ndf,1,v0); 
#line 54 &quot;../gen/tmpl/mod_func_noloop.c&quot;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_int-class_method">
  
    .<strong>zetam1_int</strong>(n)  &#x21d2; <tt>DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(n) - 1 for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Int</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>result</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24531
24532
24533
24534
24535
24536
24537
24538
24539</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24531</span>

static VALUE
sf_s_zetam1_int(VALUE mod, VALUE v0){
#line 31 &quot;../gen/tmpl/m_DFloat_f_Int.c&quot;
    ndfunc_arg_in_t ain[1] = {{cInt,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = {iter_sf_s_zetam1_int, STRIDE_LOOP|NDF_EXTRACT, 1,1, ain,aout};

    return na_ndloop(&amp;ndf, 1, v0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="zetam1_int_e-class_method">
  
    .<strong>zetam1_int_e</strong>(n)  &#x21d2; <tt>[Float, Float, Integer]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These routines compute \zeta(n) - 1 for integer n,
n \ne 1.
Domain: n integer, n != 1
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Float, Float, Integer]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [result.val, result.err, return]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


24553
24554
24555
24556
24557
24558
24559
24560
24561
24562
24563
24564
24565
24566
24567
24568
24569
24570
24571
24572
24573
24574
24575
24576</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/sf/gsl_sf.c', line 24553</span>

static VALUE
sf_s_zetam1_int_e(VALUE mod,VALUE v0)
{
    
    int c0;
    gsl_sf_result c1;
    int c2;
    
    c0 = NUM2INT(v0);
#line 16 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    c2 = gsl_sf_zetam1_int_e(c0,&amp;c1);
    
#line 20 &quot;../gen/tmpl/mod_func_scalar.c&quot;
    {
        VALUE va = rb_ary_new();
        
        rb_ary_push(va,DBL2NUM(c1.val));
        rb_ary_push(va,DBL2NUM(c1.err));
        rb_ary_push(va,INT2NUM(c2));
#line 24 &quot;../gen/tmpl/mod_func_scalar.c&quot;
        return va;
    }
    
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Mon Mar 20 06:57:01 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.8 (ruby-2.4.0).
</div>

    </div>
  </body>
</html>