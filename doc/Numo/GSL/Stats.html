<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Numo::GSL::Stats
  
    &mdash; Documentation by YARD 0.9.8
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Numo::GSL::Stats";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../_index.html">Index (S)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Numo.html" title="Numo (module)">Numo</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../GSL.html" title="Numo::GSL (module)">GSL</a></span></span>
     &raquo; 
    <span class="title">Stats</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Numo::GSL::Stats
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>ext/numo/gsl/stats/gsl_stats.c</dd>
  </dl>
  
</div>








  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#absdev-class_method" title="absdev (class method)">.<strong>absdev</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the absolute deviation from the mean of data, a
dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#absdev_m-class_method" title="absdev_m (class method)">.<strong>absdev_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the absolute deviation of the dataset data relative
to the given value of mean,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#correlation-class_method" title="correlation (class method)">.<strong>correlation</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function efficiently computes the Pearson correlation coefficient
between the datasets data1 and data2 which must both be of the same length
n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#covariance-class_method" title="covariance (class method)">.<strong>covariance</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the covariance of the datasets data1 and data2 which
must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#covariance_m-class_method" title="covariance_m (class method)">.<strong>covariance_m</strong>(data1[], data2[], mean1, mean2, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the covariance of the datasets data1 and data2 using
the given values of the means, mean1 and mean2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#kurtosis-class_method" title="kurtosis (class method)">.<strong>kurtosis</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the kurtosis of data, a dataset of length n with
stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#kurtosis_m_sd-class_method" title="kurtosis_m_sd (class method)">.<strong>kurtosis_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the kurtosis of the dataset data using the given
values of the mean mean and standard deviation sd,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lag1_autocorrelation-class_method" title="lag1_autocorrelation (class method)">.<strong>lag1_autocorrelation</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the lag-1 autocorrelation of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lag1_autocorrelation_m-class_method" title="lag1_autocorrelation_m (class method)">.<strong>lag1_autocorrelation_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the lag-1 autocorrelation of the dataset data using
the given value of the mean mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max-class_method" title="max (class method)">.<strong>max</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the maximum value in data, a dataset of length n with
stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max_index-class_method" title="max_index (class method)">.<strong>max_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the index of the maximum value in data, a dataset of
length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mean-class_method" title="mean (class method)">.<strong>mean</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the arithmetic mean of data, a dataset of length n
with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#median_from_sorted_data-class_method" title="median_from_sorted_data (class method)">.<strong>median_from_sorted_data</strong>(sorted_data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the median value of sorted_data, a dataset of length
n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min-class_method" title="min (class method)">.<strong>min</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the minimum value in data, a dataset of length n with
stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min_index-class_method" title="min_index (class method)">.<strong>min_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the index of the minimum value in data, a dataset of
length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax-class_method" title="minmax (class method)">.<strong>minmax</strong>(data[], [axis0,axis1,..])  &#x21d2; [Numo::DFloat, Numo::DFloat] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function finds both the minimum and maximum values min, max in data in
a single pass.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax_index-class_method" title="minmax_index (class method)">.<strong>minmax_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the indexes min_index, max_index of the minimum and
maximum values in data in a single pass.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#quantile_from_sorted_data-class_method" title="quantile_from_sorted_data (class method)">.<strong>quantile_from_sorted_data</strong>(sorted_data[], f, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns a quantile value of sorted_data, a double-precision
array of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd-class_method" title="sd (class method)">.<strong>sd</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd_m-class_method" title="sd_m (class method)">.<strong>sd_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd_with_fixed_mean-class_method" title="sd_with_fixed_mean (class method)">.<strong>sd_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function calculates the standard deviation of data for a fixed
population mean mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#skew-class_method" title="skew (class method)">.<strong>skew</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the skewness of data, a dataset of length n with
stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#skew_m_sd-class_method" title="skew_m_sd (class method)">.<strong>skew_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the skewness of the dataset data using the given
values of the mean mean and standard deviation sd,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#spearman-class_method" title="spearman (class method)">.<strong>spearman</strong>(data1[], data2[], work[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the Spearman rank correlation coefficient between
the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tss-class_method" title="tss (class method)">.<strong>tss</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>These functions return the total sum of squares (TSS) of data about the
mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tss_m-class_method" title="tss_m (class method)">.<strong>tss_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>These functions return the total sum of squares (TSS) of data about the
mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance-class_method" title="variance (class method)">.<strong>variance</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the estimated, or sample, variance of data, a dataset
of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance_m-class_method" title="variance_m (class method)">.<strong>variance_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the sample variance of data relative to the given
value of mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance_with_fixed_mean-class_method" title="variance_with_fixed_mean (class method)">.<strong>variance_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes an unbiased estimate of the variance of data when
the population mean mean of the underlying distribution is known a priori.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wabsdev-class_method" title="wabsdev (class method)">.<strong>wabsdev</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the weighted absolute deviation from the weighted
mean of data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wabsdev_m-class_method" title="wabsdev_m (class method)">.<strong>wabsdev_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the absolute deviation of the weighted dataset data
about the given weighted mean wmean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wkurtosis-class_method" title="wkurtosis (class method)">.<strong>wkurtosis</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the weighted kurtosis of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wkurtosis_m_sd-class_method" title="wkurtosis_m_sd (class method)">.<strong>wkurtosis_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the weighted kurtosis of the dataset data using the
given values of the weighted mean and weighted standard deviation, wmean
and wsd.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wmean-class_method" title="wmean (class method)">.<strong>wmean</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the weighted mean of the dataset data with stride
stride and length n, using the set of weights w with stride wstride and
length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd-class_method" title="wsd (class method)">.<strong>wsd</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd_m-class_method" title="wsd_m (class method)">.<strong>wsd_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the square root of the corresponding variance
function gsl_stats_wvariance_m above.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd_with_fixed_mean-class_method" title="wsd_with_fixed_mean (class method)">.<strong>wsd_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wskew-class_method" title="wskew (class method)">.<strong>wskew</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the weighted skewness of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wskew_m_sd-class_method" title="wskew_m_sd (class method)">.<strong>wskew_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes the weighted skewness of the dataset data using the
given values of the weighted mean and weighted standard deviation, wmean
and wsd.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wtss-class_method" title="wtss (class method)">.<strong>wtss</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>These functions return the weighted total sum of squares (TSS) of data
about the weighted mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wtss_m-class_method" title="wtss_m (class method)">.<strong>wtss_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>These functions return the weighted total sum of squares (TSS) of data
about the weighted mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance-class_method" title="wvariance (class method)">.<strong>wvariance</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the estimated variance of the dataset data with
stride stride and length n, using the set of weights w with stride wstride
and length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance_m-class_method" title="wvariance_m (class method)">.<strong>wvariance_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function returns the estimated variance of the weighted dataset data
using the given weighted mean wmean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance_with_fixed_mean-class_method" title="wvariance_with_fixed_mean (class method)">.<strong>wvariance_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function computes an unbiased estimate of the variance of the weighted
dataset data when the population mean mean of the underlying distribution
is known a priori.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="absdev-class_method">
  
    .<strong>absdev</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the absolute deviation from the mean of data, a
dataset of length n with stride stride.  The absolute deviation from the
mean is defined as,</p>

<p>absdev  = (1/N) sum |x_i - Hatmu|</p>

<p>where x_i are the elements of the dataset data.  The absolute deviation
from the mean provides a more robust measure of the width of a distribution
than the variance.  This function computes the mean of data via a call to
gsl_stats_mean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


494
495
496
497
498
499
500
501
502
503
504
505
506
507
508</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 494</span>

static VALUE
numo_s_absdev(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_absdev, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="absdev_m-class_method">
  
    .<strong>absdev_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the absolute deviation of the dataset data relative
to the given value of mean,</p>

<p>absdev  = (1/N) sum |x_i - mean|</p>

<p>This function is useful if you have already computed the mean of data (and
want to avoid recomputing it), or wish to calculate the absolute deviation
relative to another value (such as zero, or the median).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 543</span>

static VALUE
numo_s_absdev_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_absdev_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="correlation-class_method">
  
    .<strong>correlation</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function efficiently computes the Pearson correlation coefficient
between the datasets data1 and data2 which must both be of the same length
n. r = cov(x, y) / (Hatsigma_x Hatsigma_y)</p>

<h1 id="label-40-7B1-2F-28n-1-29+sum+-28x_i+-+Hat+x-29+-28y_i+-+Hat+y-29">@sum (x_i - Hat x) (y_i - Hat y)</h1>

<pre class="code"><code class=""> \over
 \sqrt@{1/(n-1) \sum (x_i - \Hat x)^2@ \sqrt@\sum (y_i - \Hat y)^2@
@}</code></pre>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


985
986
987
988
989
990
991
992
993
994
995
996
997
998
999
1000</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 985</span>

static VALUE
numo_s_correlation(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_correlation, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="covariance-class_method">
  
    .<strong>covariance</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the covariance of the datasets data1 and data2 which
must both be of the same length n.</p>

<p>covar = (1/(n - 1)) sum_@= 1@^@n@ (x_i - Hat x) (y_i - Hat y)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 882</span>

static VALUE
numo_s_covariance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_covariance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="covariance_m-class_method">
  
    .<strong>covariance_m</strong>(data1[], data2[], mean1, mean2, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the covariance of the datasets data1 and data2 using
the given values of the means, mean1 and mean2.  This is useful if you have
already computed the means of data1 and data2 and want to avoid recomputing
them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean1</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean2</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 931</span>

static VALUE
numo_s_covariance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_covariance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="kurtosis-class_method">
  
    .<strong>kurtosis</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the kurtosis of data, a dataset of length n with
stride stride.  The kurtosis is defined as,</p>

<p>kurtosis = ((1/N) sum ((x_i - Hatmu)/Hatsigma)^4)  - 3</p>

<p>The kurtosis measures how sharply peaked a distribution is, relative to its
width.  The kurtosis is normalized to zero for a Gaussian distribution.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


694
695
696
697
698
699
700
701
702
703
704
705
706
707
708</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 694</span>

static VALUE
numo_s_kurtosis(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_kurtosis, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="kurtosis_m_sd-class_method">
  
    .<strong>kurtosis_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the kurtosis of the dataset data using the given
values of the mean mean and standard deviation sd,</p>

<p>kurtosis = ((1/N) sum ((x_i - mean)/sd)^4) - 3</p>

<p>This function is useful if you have already computed the mean and standard
deviation of data and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>sd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 742</span>

static VALUE
numo_s_kurtosis_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_kurtosis_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);
    opt[1] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lag1_autocorrelation-class_method">
  
    .<strong>lag1_autocorrelation</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the lag-1 autocorrelation of the dataset data.</p>

<p>a_1 = @= 1@^@n@ (x_@i@ - Hatmu) (x_@i-1@ - Hatmu)</p>

<pre class="code"><code class="">\over
\sum_@{i = 1@}^@{n@} (x_@{i@} - \Hat\mu) (x_@{i@} - \Hat\mu)@}</code></pre>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


790
791
792
793
794
795
796
797
798
799
800
801
802
803
804</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 790</span>

static VALUE
numo_s_lag1_autocorrelation(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_lag1_autocorrelation, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lag1_autocorrelation_m-class_method">
  
    .<strong>lag1_autocorrelation_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the lag-1 autocorrelation of the dataset data using
the given value of the mean mean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 833</span>

static VALUE
numo_s_lag1_autocorrelation_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_lag1_autocorrelation_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="max-class_method">
  
    .<strong>max</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the maximum value in data, a dataset of length n with
stride stride.  The maximum value is defined as the value of the element
x_i which satisfies $x_i ge x_j$ x_i &gt;= x_j for all j.</p>

<p>If you want instead to find the element with the largest absolute magnitude
you will need to apply fabs or abs to your data before calling this
function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1826
1827
1828
1829
1830
1831
1832
1833
1834
1835
1836
1837
1838
1839
1840</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1826</span>

static VALUE
numo_s_max(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_max, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="max_index-class_method">
  
    .<strong>max_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the index of the maximum value in data, a dataset of
length n with stride stride.  The maximum value is defined as the value of
the element x_i which satisfies $x_i ge x_j$ x_i &gt;= x_j for all j.  When
there are several equal maximum elements then the first one is chosen.</p>

<pre class="code"><code class="">@overload max_index() =&gt; Integer
@overload max_index(axis0,axis1,..) =&gt; Integer or Numo::Int32/64

@param [Numo::DFloat] data[]
@return [Numo::UInt64]  return</code></pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1984</span>

static VALUE
numo_s_max_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{Qnil,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{0,0,0}};
    ndfunc_t ndf = {0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT, 3,1, ain,aout};

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_max_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_max_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mean-class_method">
  
    .<strong>mean</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the arithmetic mean of data, a dataset of length n
with stride stride.  The arithmetic mean, or sample mean, is denoted by
Hatmu and defined as,</p>

<p>Hatmu = (1/N) sum x_i</p>

<p>where x_i are the elements of the dataset data.  For samples drawn from a
gaussian distribution the variance of Hatmu is sigma^2 / N.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


64
65
66
67
68
69
70
71
72
73
74
75
76
77
78</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 64</span>

static VALUE
numo_s_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="median_from_sorted_data-class_method">
  
    .<strong>median_from_sorted_data</strong>(sorted_data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the median value of sorted_data, a dataset of length
n with stride stride.  The elements of the array must be in ascending
numerical order.  There are no checks to see whether the data are sorted,
so the function gsl_sort should always be used first.</p>

<p>When the dataset has an odd number of elements the median is the value of
element (n-1)/2.  When the dataset has an even number of elements the
median is the mean of the two nearest middle values, elements (n-1)/2 and
n/2.  Since the algorithm for computing the median involves interpolation
this function always returns a floating-point number, even for integer data
types.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>sorted_data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2231</span>

static VALUE
numo_s_median_from_sorted_data(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_median_from_sorted_data, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="min-class_method">
  
    .<strong>min</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the minimum value in data, a dataset of length n with
stride stride.  The minimum value is defined as the value of the element
x_i which satisfies $x_i le x_j$ x_i &lt;= x_j for all j.</p>

<p>If you want instead to find the element with the smallest absolute
magnitude you will need to apply fabs or abs to your data before calling
this function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1872</span>

static VALUE
numo_s_min(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_min, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="min_index-class_method">
  
    .<strong>min_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the index of the minimum value in data, a dataset of
length n with stride stride.  The minimum value is defined as the value of
the element x_i which satisfies $x_i ge x_j$ x_i &gt;= x_j for all j.  When
there are several equal minimum elements then the first one is chosen.</p>

<pre class="code"><code class="">@overload min_index() =&gt; Integer
@overload min_index(axis0,axis1,..) =&gt; Integer or Numo::Int32/64

@param [Numo::DFloat] data[]
@return [Numo::UInt64]  return</code></pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2071</span>

static VALUE
numo_s_min_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{Qnil,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{0,0,0}};
    ndfunc_t ndf = {0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT, 3,1, ain,aout};

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_min_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_min_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="minmax-class_method">
  
    .<strong>minmax</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function finds both the minimum and maximum values min, max in data in
a single pass.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>array of [min, max]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1913</span>

static VALUE
numo_s_minmax(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,0},{cDF,0}};
    ndfunc_t ndf = { iter_minmax, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 2, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="minmax_index-class_method">
  
    .<strong>minmax_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the indexes min_index, max_index of the minimum and
maximum values in data in a single pass.</p>

<pre class="code"><code class="">@overload minmax_index() =&gt; [Integer, Integer]
@overload minmax_index(axis0,axis1,..) =&gt; 2-element array of Integer or Numo::Int32/64

@param [Numo::DFloat] data[]
@return [[Numo::UInt64, Numo::UInt64]]  array of [min_index, max_index]</code></pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2162</span>

static VALUE
numo_s_minmax_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[2] = {{0,0,0},{0,0,0}};
    ndfunc_t ndf = { 0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3,2, ain,aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        aout[1].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_minmax_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        aout[1].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_minmax_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="quantile_from_sorted_data-class_method">
  
    .<strong>quantile_from_sorted_data</strong>(sorted_data[], f, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns a quantile value of sorted_data, a double-precision
array of length n with stride stride.  The elements of the array must be in
ascending numerical order.  The quantile is determined by the f, a fraction
between 0 and 1.  For example, to compute the value of the 75th percentile
f should have the value 0.75.</p>

<p>There are no checks to see whether the data are sorted, so the function
gsl_sort should always be used first.</p>

<p>The quantile is found by interpolation, using the formula</p>

<p>quantile = (1 - delta) x_i + delta x_@i+1@</p>

<p>where i is floor((n - 1)f) and delta is (n-1)f - i.</p>

<p>Thus the minimum value of the array (<a href="0*stride">data</a>) is given
by f equal to zero, the maximum value (<a href="(n-1)*stride">data</a>) is
given by f equal to one and the median value is given by f equal to 0.5. 
Since the algorithm for computing quantiles involves interpolation this
function always returns a floating-point number, even for integer data
types.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>sorted_data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>f</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2294</span>

static VALUE
numo_s_quantile_from_sorted_data(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_quantile_from_sorted_data, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd-class_method">
  
    .<strong>sd</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>The standard deviation is defined as the square root of the variance. These
functions return the square root of the corresponding variance functions
above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


207
208
209
210
211
212
213
214
215
216
217
218
219
220
221</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 207</span>

static VALUE
numo_s_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd_m-class_method">
  
    .<strong>sd_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>The standard deviation is defined as the square root of the variance. These
functions return the square root of the corresponding variance functions
above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 250</span>

static VALUE
numo_s_sd_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_sd_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd_with_fixed_mean-class_method">
  
    .<strong>sd_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function calculates the standard deviation of data for a fixed
population mean mean.  The result is the square root of the corresponding
variance function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 442</span>

static VALUE
numo_s_sd_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_sd_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="skew-class_method">
  
    .<strong>skew</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the skewness of data, a dataset of length n with
stride stride.  The skewness is defined as,</p>

<p>skew = (1/N) sum ((x_i - Hatmu)/Hatsigma)^3</p>

<p>where x_i are the elements of the dataset data.  The skewness measures the
asymmetry of the tails of a distribution.</p>

<p>The function computes the mean and estimated standard deviation of data via
calls to gsl_stats_mean and gsl_stats_sd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


595
596
597
598
599
600
601
602
603
604
605
606
607
608
609</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 595</span>

static VALUE
numo_s_skew(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_skew, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="skew_m_sd-class_method">
  
    .<strong>skew_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the skewness of the dataset data using the given
values of the mean mean and standard deviation sd,</p>

<p>skew = (1/N) sum ((x_i - mean)/sd)^3</p>

<p>These functions are useful if you have already computed the mean and
standard deviation of data and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>sd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 643</span>

static VALUE
numo_s_skew_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_skew_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);
    opt[1] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="spearman-class_method">
  
    .<strong>spearman</strong>(data1[], data2[], work[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the Spearman rank correlation coefficient between
the datasets data1 and data2 which must both be of the same length n.
Additional workspace of size 2*n is required in work. The Spearman rank
correlation between vectors x and y is equivalent to the Pearson
correlation between the ranked vectors x_R and y_R, where ranks are defined
to be the average of the positions of an element in the ascending order of
the values.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>work[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1036
1037
1038
1039
1040
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1036</span>

static VALUE
numo_s_spearman(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce, v, buf = 0;
    narray_t *na;
    double *opt;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_spearman, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    GetNArray(argv[0],na);
    opt = ALLOCV_N(double,buf,na-&gt;size*2); // todo: get loop size
    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    v = na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
    ALLOCV_END(buf);
    return v;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="tss-class_method">
  
    .<strong>tss</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>These functions return the total sum of squares (TSS) of data about the
mean.  For gsl_stats_tss_m the user-supplied value of mean is used, and for
gsl_stats_tss it is computed using gsl_stats_mean.</p>

<p>TSS =  sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


298
299
300
301
302
303
304
305
306
307
308
309
310
311
312</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 298</span>

static VALUE
numo_s_tss(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_tss, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="tss_m-class_method">
  
    .<strong>tss_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>These functions return the total sum of squares (TSS) of data about the
mean.  For gsl_stats_tss_m the user-supplied value of mean is used, and for
gsl_stats_tss it is computed using gsl_stats_mean.</p>

<p>TSS =  sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 344</span>

static VALUE
numo_s_tss_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_tss_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance-class_method">
  
    .<strong>variance</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the estimated, or sample, variance of data, a dataset
of length n with stride stride.  The estimated variance is denoted by
Hatsigma^2 and is defined by,</p>

<p>Hatsigma^2 = (1/(N-1)) sum (x_i - Hatmu)^2</p>

<p>where x_i are the elements of the dataset data.  Note that the
normalization factor of 1/(N-1) results from the derivation of Hatsigma^2
as an unbiased estimator of the population variance sigma^2.  For samples
drawn from a Gaussian distribution the variance of Hatsigma^2 itself is 2
sigma^4 / N.</p>

<p>This function computes the mean via a call to gsl_stats_mean.  If you have
already computed the mean then you can pass it directly to
gsl_stats_variance_m.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


117
118
119
120
121
122
123
124
125
126
127
128
129
130
131</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 117</span>

static VALUE
numo_s_variance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_variance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance_m-class_method">
  
    .<strong>variance_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the sample variance of data relative to the given
value of mean.  The function is computed with Hatmu replaced by the value
of mean that you supply,</p>

<p>Hatsigma^2 = (1/(N-1)) sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 162</span>

static VALUE
numo_s_variance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_variance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance_with_fixed_mean-class_method">
  
    .<strong>variance_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes an unbiased estimate of the variance of data when
the population mean mean of the underlying distribution is known a priori. 
In this case the estimator for the variance uses the factor 1/N and the
sample mean Hatmu is replaced by the known population mean mu,</p>

<p>Hatsigma^2 = (1/N) sum (x_i - mu)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 395</span>

static VALUE
numo_s_variance_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_variance_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wabsdev-class_method">
  
    .<strong>wabsdev</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the weighted absolute deviation from the weighted
mean of data.  The absolute deviation from the mean is defined as,</p>

<p>absdev = (sum w_i |x_i - Hatmu|) / (sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1536</span>

static VALUE
numo_s_wabsdev(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wabsdev, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wabsdev_m-class_method">
  
    .<strong>wabsdev_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the absolute deviation of the weighted dataset data
about the given weighted mean wmean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1582</span>

static VALUE
numo_s_wabsdev_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wabsdev_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wkurtosis-class_method">
  
    .<strong>wkurtosis</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the weighted kurtosis of the dataset data.</p>

<p>kurtosis = ((sum w_i ((x_i - Hat x)/Hat sigma)^4) / (sum w_i)) - 3</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
1742</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1727</span>

static VALUE
numo_s_wkurtosis(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wkurtosis, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wkurtosis_m_sd-class_method">
  
    .<strong>wkurtosis_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the weighted kurtosis of the dataset data using the
given values of the weighted mean and weighted standard deviation, wmean
and wsd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wsd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1775</span>

static VALUE
numo_s_wkurtosis_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wkurtosis_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wmean-class_method">
  
    .<strong>wmean</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the weighted mean of the dataset data with stride
stride and length n, using the set of weights w with stride wstride and
length n.  The weighted mean is defined as,</p>

<p>Hatmu = (sum w_i x_i) / (sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1089</span>

static VALUE
numo_s_wmean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wmean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd-class_method">
  
    .<strong>wsd</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>The standard deviation is defined as the square root of the variance. This
function returns the square root of the corresponding variance function
gsl_stats_wvariance above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1236</span>

static VALUE
numo_s_wsd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wsd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd_m-class_method">
  
    .<strong>wsd_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the square root of the corresponding variance
function gsl_stats_wvariance_m above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1282</span>

static VALUE
numo_s_wsd_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wsd_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd_with_fixed_mean-class_method">
  
    .<strong>wsd_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>The standard deviation is defined as the square root of the variance. This
function returns the square root of the corresponding variance function
above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1386</span>

static VALUE
numo_s_wsd_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wsd_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wskew-class_method">
  
    .<strong>wskew</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the weighted skewness of the dataset data.</p>

<p>skew = (sum w_i ((x_i - Hat x)/Hat sigma)^3) / (sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1630</span>

static VALUE
numo_s_wskew(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wskew, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wskew_m_sd-class_method">
  
    .<strong>wskew_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes the weighted skewness of the dataset data using the
given values of the weighted mean and weighted standard deviation, wmean
and wsd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wsd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1678</span>

static VALUE
numo_s_wskew_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wskew_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wtss-class_method">
  
    .<strong>wtss</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>These functions return the weighted total sum of squares (TSS) of data
about the weighted mean.  For gsl_stats_wtss_m the user-supplied value of
wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.</p>

<p>TSS =  sum w_i (x_i - wmean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1437</span>

static VALUE
numo_s_wtss(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wtss, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wtss_m-class_method">
  
    .<strong>wtss_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>These functions return the weighted total sum of squares (TSS) of data
about the weighted mean.  For gsl_stats_wtss_m the user-supplied value of
wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.</p>

<p>TSS =  sum w_i (x_i - wmean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1487</span>

static VALUE
numo_s_wtss_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wtss_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance-class_method">
  
    .<strong>wvariance</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the estimated variance of the dataset data with
stride stride and length n, using the set of weights w with stride wstride
and length n.  The estimated variance of a weighted dataset is calculated
as,</p>

<p>Hatsigma^2 = ((sum w_i)/((sum w_i)^2 - sum (w_i^2)))</p>

<pre class="code"><code class="">\sum w_i (x_i - \Hat\mu)^2</code></pre>

<p>Note that this expression reduces to an unweighted variance with the
familiar 1/(N-1) factor when there are N equal non-zero weights.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1142</span>

static VALUE
numo_s_wvariance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wvariance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance_m-class_method">
  
    .<strong>wvariance_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function returns the estimated variance of the weighted dataset data
using the given weighted mean wmean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1188</span>

static VALUE
numo_s_wvariance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wvariance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance_with_fixed_mean-class_method">
  
    .<strong>wvariance_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function computes an unbiased estimate of the variance of the weighted
dataset data when the population mean mean of the underlying distribution
is known a priori.  In this case the estimator for the variance replaces
the sample mean Hatmu by the known population mean mu,</p>

<p>Hatsigma^2 = (sum w_i (x_i - mu)^2) / (sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1336</span>

static VALUE
numo_s_wvariance_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_wvariance_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Fri Jan 27 21:54:04 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.8 (ruby-2.4.0).
</div>

    </div>
  </body>
</html>