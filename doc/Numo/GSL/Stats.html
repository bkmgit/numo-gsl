<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Numo::GSL::Stats
  
    &mdash; Documentation by YARD 0.9.8
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Numo::GSL::Stats";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../x_index.html">Index (S)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Numo.html" title="Numo (module)">Numo</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../GSL.html" title="Numo::GSL (module)">GSL</a></span></span>
     &raquo; 
    <span class="title">Stats</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Numo::GSL::Stats
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>ext/numo/gsl/stats/gsl_stats.c</dd>
  </dl>
  
</div>








  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#absdev-class_method" title="absdev (class method)">.<strong>absdev</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the absolute deviation from the mean of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#absdev_m-class_method" title="absdev_m (class method)">.<strong>absdev_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the absolute deviation of the dataset data relative to the given value of mean,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#correlation-class_method" title="correlation (class method)">.<strong>correlation</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function efficiently computes the Pearson correlation coefficient between the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#covariance-class_method" title="covariance (class method)">.<strong>covariance</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the covariance of the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#covariance_m-class_method" title="covariance_m (class method)">.<strong>covariance_m</strong>(data1[], data2[], mean1, mean2, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the covariance of the datasets data1 and data2 using the given values of the means, mean1 and mean2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#kurtosis-class_method" title="kurtosis (class method)">.<strong>kurtosis</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the kurtosis of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#kurtosis_m_sd-class_method" title="kurtosis_m_sd (class method)">.<strong>kurtosis_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the kurtosis of the dataset data using the given values of the mean mean and standard deviation sd,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lag1_autocorrelation-class_method" title="lag1_autocorrelation (class method)">.<strong>lag1_autocorrelation</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the lag-1 autocorrelation of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lag1_autocorrelation_m-class_method" title="lag1_autocorrelation_m (class method)">.<strong>lag1_autocorrelation_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the lag-1 autocorrelation of the dataset data using the given value of the mean mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max-class_method" title="max (class method)">.<strong>max</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the maximum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max_index-class_method" title="max_index (class method)">.<strong>max_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index of the maximum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mean-class_method" title="mean (class method)">.<strong>mean</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the arithmetic mean of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#median_from_sorted_data-class_method" title="median_from_sorted_data (class method)">.<strong>median_from_sorted_data</strong>(sorted_data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the median value of sorted_data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min-class_method" title="min (class method)">.<strong>min</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the minimum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min_index-class_method" title="min_index (class method)">.<strong>min_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index of the minimum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax-class_method" title="minmax (class method)">.<strong>minmax</strong>(data[], [axis0,axis1,..])  &#x21d2; [Numo::DFloat, Numo::DFloat] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function finds both the minimum and maximum values min, max in data in a single pass.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax_index-class_method" title="minmax_index (class method)">.<strong>minmax_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the indexes min_index, max_index of the minimum and maximum values in data in a single pass.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#quantile_from_sorted_data-class_method" title="quantile_from_sorted_data (class method)">.<strong>quantile_from_sorted_data</strong>(sorted_data[], f, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns a quantile value of sorted_data, a double-precision array of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd-class_method" title="sd (class method)">.<strong>sd</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd_m-class_method" title="sd_m (class method)">.<strong>sd_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd_with_fixed_mean-class_method" title="sd_with_fixed_mean (class method)">.<strong>sd_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function calculates the standard deviation of data for a fixed population mean mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#skew-class_method" title="skew (class method)">.<strong>skew</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the skewness of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#skew_m_sd-class_method" title="skew_m_sd (class method)">.<strong>skew_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the skewness of the dataset data using the given values of the mean mean and standard deviation sd,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#spearman-class_method" title="spearman (class method)">.<strong>spearman</strong>(data1[], data2[], work[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Spearman rank correlation coefficient between the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tss-class_method" title="tss (class method)">.<strong>tss</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the total sum of squares (TSS) of data about the mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tss_m-class_method" title="tss_m (class method)">.<strong>tss_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the total sum of squares (TSS) of data about the mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance-class_method" title="variance (class method)">.<strong>variance</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the estimated, or sample, variance of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance_m-class_method" title="variance_m (class method)">.<strong>variance_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the sample variance of data relative to the given value of mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance_with_fixed_mean-class_method" title="variance_with_fixed_mean (class method)">.<strong>variance_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an unbiased estimate of the variance of data when the population mean mean of the underlying distribution is known a priori.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wabsdev-class_method" title="wabsdev (class method)">.<strong>wabsdev</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted absolute deviation from the weighted mean of data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wabsdev_m-class_method" title="wabsdev_m (class method)">.<strong>wabsdev_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wkurtosis-class_method" title="wkurtosis (class method)">.<strong>wkurtosis</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted kurtosis of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wkurtosis_m_sd-class_method" title="wkurtosis_m_sd (class method)">.<strong>wkurtosis_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted kurtosis of the dataset data using the given values of the weighted mean and weighted standard deviation, wmean and wsd.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wmean-class_method" title="wmean (class method)">.<strong>wmean</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the weighted mean of the dataset data with stride stride and length n, using the set of weights w with stride wstride and length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd-class_method" title="wsd (class method)">.<strong>wsd</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd_m-class_method" title="wsd_m (class method)">.<strong>wsd_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd_with_fixed_mean-class_method" title="wsd_with_fixed_mean (class method)">.<strong>wsd_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wskew-class_method" title="wskew (class method)">.<strong>wskew</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted skewness of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wskew_m_sd-class_method" title="wskew_m_sd (class method)">.<strong>wskew_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted skewness of the dataset data using the given values of the weighted mean and weighted standard deviation, wmean and wsd.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wtss-class_method" title="wtss (class method)">.<strong>wtss</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the weighted total sum of squares (TSS) of data about the weighted mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wtss_m-class_method" title="wtss_m (class method)">.<strong>wtss_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the weighted total sum of squares (TSS) of data about the weighted mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance-class_method" title="wvariance (class method)">.<strong>wvariance</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the estimated variance of the dataset data with stride stride and length n, using the set of weights w with stride wstride and length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance_m-class_method" title="wvariance_m (class method)">.<strong>wvariance_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the estimated variance of the weighted dataset data using the given weighted mean wmean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance_with_fixed_mean-class_method" title="wvariance_with_fixed_mean (class method)">.<strong>wvariance_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an unbiased estimate of the variance of the weighted dataset data when the population mean mean of the underlying distribution is known a priori.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="absdev-class_method">
  
    .<strong>absdev</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the absolute deviation from the mean of
data, a dataset of length n with stride stride.  The
absolute deviation from the mean is defined as,</p>

<table>
  <tbody>
    <tr>
      <td>absdev  = (1/N) \sum</td>
      <td>x_i - \Hat\mu</td>
    </tr>
  </tbody>
</table>

<p>where x_i are the elements of the dataset data.  The
absolute deviation from the mean provides a more robust measure of the
width of a distribution than the variance.  This function computes the
mean of data via a call to gsl_stats_mean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


513
514
515
516
517
518
519
520
521
522
523
524
525
526
527</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 513</span>

static VALUE
stats_s_absdev(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_absdev, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="absdev_m-class_method">
  
    .<strong>absdev_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the absolute deviation of the dataset data
relative to the given value of mean,</p>

<table>
  <tbody>
    <tr>
      <td>absdev  = (1/N) \sum</td>
      <td>x_i - mean</td>
    </tr>
  </tbody>
</table>

<p>This function is useful if you have already computed the mean of
data (and want to avoid recomputing it), or wish to calculate the
absolute deviation relative to another value (such as zero, or the
median).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 562</span>

static VALUE
stats_s_absdev_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_absdev_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="correlation-class_method">
  
    .<strong>correlation</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function efficiently computes the Pearson correlation coefficient
between the datasets data1 and data2 which must both be of
the same length n.
r = cov(x, y) / (\Hat\sigma_x \Hat\sigma_y)
= [1/(n-1) \sum (x_i - \Hat x) (y_i - \Hat y)
   \over
   \sqrt[1/(n-1) \sum (x_i - \Hat x)^2] \sqrt[1/(n-1) \sum (y_i - \Hat y)^2]
  ]</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1004</span>

static VALUE
stats_s_correlation(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_correlation, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="covariance-class_method">
  
    .<strong>covariance</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the covariance of the datasets data1 and
data2 which must both be of the same length n.</p>

<p>covar = (1/(n - 1)) \sum_[i = 1]^[n] (x_i - \Hat x) (y_i - \Hat y)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 901</span>

static VALUE
stats_s_covariance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_covariance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="covariance_m-class_method">
  
    .<strong>covariance_m</strong>(data1[], data2[], mean1, mean2, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the covariance of the datasets data1 and
data2 using the given values of the means, mean1 and
mean2.  This is useful if you have already computed the means of
data1 and data2 and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean1</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean2</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
965
966
967
968
969</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 950</span>

static VALUE
stats_s_covariance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_covariance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="kurtosis-class_method">
  
    .<strong>kurtosis</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the kurtosis of data, a dataset of length
n with stride stride.  The kurtosis is defined as,</p>

<p>kurtosis = ((1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^4)  - 3</p>

<p>The kurtosis measures how sharply peaked a distribution is, relative to
its width.  The kurtosis is normalized to zero for a Gaussian
distribution.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


713
714
715
716
717
718
719
720
721
722
723
724
725
726
727</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 713</span>

static VALUE
stats_s_kurtosis(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_kurtosis, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="kurtosis_m_sd-class_method">
  
    .<strong>kurtosis_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the kurtosis of the dataset data using the
given values of the mean mean and standard deviation sd,</p>

<p>kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3</p>

<p>This function is useful if you have already computed the mean and
standard deviation of data and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>sd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 761</span>

static VALUE
stats_s_kurtosis_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_kurtosis_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);
    opt[1] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lag1_autocorrelation-class_method">
  
    .<strong>lag1_autocorrelation</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the lag-1 autocorrelation of the dataset data.</p>

<p>a_1 = [\sum_[i = 1]^[n] (x_[i] - \Hat\mu) (x_[i-1] - \Hat\mu)
     \over
     \sum_[i = 1]^[n] (x_[i] - \Hat\mu) (x_[i] - \Hat\mu)]</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


809
810
811
812
813
814
815
816
817
818
819
820
821
822
823</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 809</span>

static VALUE
stats_s_lag1_autocorrelation(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_lag1_autocorrelation, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lag1_autocorrelation_m-class_method">
  
    .<strong>lag1_autocorrelation_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the lag-1 autocorrelation of the dataset
data using the given value of the mean mean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 852</span>

static VALUE
stats_s_lag1_autocorrelation_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_lag1_autocorrelation_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="max-class_method">
  
    .<strong>max</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the maximum value in data, a dataset of
length n with stride stride.  The maximum value is defined
as the value of the element x_i which satisfies $x_i \ge x_j$
x_i &gt;= x_j for all j.</p>

<p>If you want instead to find the element with the largest absolute
magnitude you will need to apply fabs or abs to your data
before calling this function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1845</span>

static VALUE
stats_s_max(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_max, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="max_index-class_method">
  
    .<strong>max_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index of the maximum value in data, a
dataset of length n with stride stride.  The maximum value is
defined as the value of the element x_i which satisfies
$x_i \ge x_j$
x_i &gt;= x_j for all j.  When there are several equal maximum
elements then the first one is chosen.
 @overload max_index() =&gt; Integer
 @overload max_index(axis0,axis1,..) =&gt; Integer or Numo::Int32/64</p>

<p>@param [Numo::DFloat] data[]
 @return [Numo::UInt64]  return</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2003</span>

static VALUE
stats_s_max_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{0,0,0}};
    ndfunc_t ndf = {0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT, 3,1, ain,aout};

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_max_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_max_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mean-class_method">
  
    .<strong>mean</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the arithmetic mean of data, a dataset of
length n with stride stride.  The arithmetic mean, or
sample mean, is denoted by \Hat\mu and defined as,</p>

<p>\Hat\mu = (1/N) \sum x_i</p>

<p>where x_i are the elements of the dataset data.  For
samples drawn from a gaussian distribution the variance of
\Hat\mu is \sigma^2 / N.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


83
84
85
86
87
88
89
90
91
92
93
94
95
96
97</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 83</span>

static VALUE
stats_s_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="median_from_sorted_data-class_method">
  
    .<strong>median_from_sorted_data</strong>(sorted_data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the median value of sorted_data, a dataset
of length n with stride stride.  The elements of the array
must be in ascending numerical order.  There are no checks to see
whether the data are sorted, so the function gsl_sort should
always be used first.</p>

<p>When the dataset has an odd number of elements the median is the value
of element (n-1)/2.  When the dataset has an even number of
elements the median is the mean of the two nearest middle values,
elements (n-1)/2 and n/2.  Since the algorithm for
computing the median involves interpolation this function always returns
a floating-point number, even for integer data types.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>sorted_data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2250</span>

static VALUE
stats_s_median_from_sorted_data(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_median_from_sorted_data, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="min-class_method">
  
    .<strong>min</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the minimum value in data, a dataset of
length n with stride stride.  The minimum value is defined
as the value of the element x_i which satisfies $x_i \le x_j$
x_i &lt;= x_j for all j.</p>

<p>If you want instead to find the element with the smallest absolute
magnitude you will need to apply fabs or abs to your data
before calling this function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
1904
1905</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1891</span>

static VALUE
stats_s_min(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_min, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="min_index-class_method">
  
    .<strong>min_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index of the minimum value in data, a
dataset of length n with stride stride.  The minimum value
is defined as the value of the element x_i which satisfies
$x_i \ge x_j$
x_i &gt;= x_j for all j.  When there are several equal
minimum elements then the first one is chosen.
 @overload min_index() =&gt; Integer
 @overload min_index(axis0,axis1,..) =&gt; Integer or Numo::Int32/64</p>

<p>@param [Numo::DFloat] data[]
 @return [Numo::UInt64]  return</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2090</span>

static VALUE
stats_s_min_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{0,0,0}};
    ndfunc_t ndf = {0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT, 3,1, ain,aout};

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_min_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_min_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="minmax-class_method">
  
    .<strong>minmax</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function finds both the minimum and maximum values min,
max in data in a single pass.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [min, max]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1932</span>

static VALUE
stats_s_minmax(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,0},{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_minmax, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 2, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="minmax_index-class_method">
  
    .<strong>minmax_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the indexes min_index, max_index of
the minimum and maximum values in data in a single pass.
 @overload minmax_index() =&gt; [Integer, Integer]
 @overload minmax_index(axis0,axis1,..) =&gt; 2-element array of Integer or Numo::Int32/64</p>

<p>@param [Numo::DFloat] data[]
 @return [[Numo::UInt64, Numo::UInt64]]  array of [min_index, max_index]</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
2210
2211
2212
2213
2214</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2181</span>

static VALUE
stats_s_minmax_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[2] = {{0,0,0},{0,0,0}};
    ndfunc_t ndf = { 0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3,2, ain,aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        aout[1].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_minmax_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        aout[1].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_minmax_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="quantile_from_sorted_data-class_method">
  
    .<strong>quantile_from_sorted_data</strong>(sorted_data[], f, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns a quantile value of sorted_data, a
double-precision array of length n with stride stride.  The
elements of the array must be in ascending numerical order.  The
quantile is determined by the f, a fraction between 0 and 1.  For
example, to compute the value of the 75th percentile f should have
the value 0.75.</p>

<p>There are no checks to see whether the data are sorted, so the function
gsl_sort should always be used first.</p>

<p>The quantile is found by interpolation, using the formula</p>

<p>quantile = (1 - \delta) x_i + \delta x_[i+1]</p>

<p>where i is floor((n - 1)f) and \delta is
(n-1)f - i.</p>

<p>Thus the minimum value of the array (data[0<em>stride]) is given by
f equal to zero, the maximum value (data[(n-1)</em>stride]) is
given by f equal to one and the median value is given by f
equal to 0.5.  Since the algorithm for computing quantiles involves
interpolation this function always returns a floating-point number, even
for integer data types.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>sorted_data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>f</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2313</span>

static VALUE
stats_s_quantile_from_sorted_data(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_quantile_from_sorted_data, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd-class_method">
  
    .<strong>sd</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
These functions return the square root of the corresponding variance
functions above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


226
227
228
229
230
231
232
233
234
235
236
237
238
239
240</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 226</span>

static VALUE
stats_s_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd_m-class_method">
  
    .<strong>sd_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
These functions return the square root of the corresponding variance
functions above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 269</span>

static VALUE
stats_s_sd_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_sd_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd_with_fixed_mean-class_method">
  
    .<strong>sd_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function calculates the standard deviation of data for a
fixed population mean mean.  The result is the square root of the
corresponding variance function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 461</span>

static VALUE
stats_s_sd_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_sd_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="skew-class_method">
  
    .<strong>skew</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the skewness of data, a dataset of length
n with stride stride.  The skewness is defined as,</p>

<p>skew = (1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^3</p>

<p>where x_i are the elements of the dataset data.  The skewness
measures the asymmetry of the tails of a distribution.</p>

<p>The function computes the mean and estimated standard deviation of
data via calls to gsl_stats_mean and gsl_stats_sd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


614
615
616
617
618
619
620
621
622
623
624
625
626
627
628</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 614</span>

static VALUE
stats_s_skew(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_skew, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="skew_m_sd-class_method">
  
    .<strong>skew_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the skewness of the dataset data using the
given values of the mean mean and standard deviation sd,</p>

<p>skew = (1/N) \sum ((x_i - mean)/sd)^3</p>

<p>These functions are useful if you have already computed the mean and
standard deviation of data and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>sd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 662</span>

static VALUE
stats_s_skew_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_skew_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);
    opt[1] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="spearman-class_method">
  
    .<strong>spearman</strong>(data1[], data2[], work[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Spearman rank correlation coefficient between
the datasets data1 and data2 which must both be of the same
length n. Additional workspace of size 2*n is required in
work. The Spearman rank correlation between vectors x and
y is equivalent to the Pearson correlation between the ranked
vectors x_R and y_R, where ranks are defined to be the
average of the positions of an element in the ascending order of the values.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>work[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1055</span>

static VALUE
stats_s_spearman(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce, v, buf = 0;
    narray_t *na;
    double *opt;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_spearman, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    GetNArray(argv[0],na);
    opt = ALLOCV_N(double,buf,na-&gt;size*2); // todo: get loop size
    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    v = na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
    ALLOCV_END(buf);
    return v;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="tss-class_method">
  
    .<strong>tss</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the total sum of squares (TSS) of data about
the mean.  For gsl_stats_tss_m the user-supplied value of
mean is used, and for gsl_stats_tss it is computed using
gsl_stats_mean.</p>

<p>TSS =  \sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


317
318
319
320
321
322
323
324
325
326
327
328
329
330
331</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 317</span>

static VALUE
stats_s_tss(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_tss, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="tss_m-class_method">
  
    .<strong>tss_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the total sum of squares (TSS) of data about
the mean.  For gsl_stats_tss_m the user-supplied value of
mean is used, and for gsl_stats_tss it is computed using
gsl_stats_mean.</p>

<p>TSS =  \sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 363</span>

static VALUE
stats_s_tss_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_tss_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance-class_method">
  
    .<strong>variance</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the estimated, or sample, variance of
data, a dataset of length n with stride stride.  The
estimated variance is denoted by \Hat\sigma^2 and is defined by,</p>

<p>\Hat\sigma^2 = (1/(N-1)) \sum (x_i - \Hat\mu)^2</p>

<p>where x_i are the elements of the dataset data.  Note that
the normalization factor of 1/(N-1) results from the derivation
of \Hat\sigma^2 as an unbiased estimator of the population
variance \sigma^2.  For samples drawn from a Gaussian distribution
the variance of \Hat\sigma^2 itself is 2 \sigma^4 / N.</p>

<p>This function computes the mean via a call to gsl_stats_mean.  If
you have already computed the mean then you can pass it directly to
gsl_stats_variance_m.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


136
137
138
139
140
141
142
143
144
145
146
147
148
149
150</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 136</span>

static VALUE
stats_s_variance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_variance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance_m-class_method">
  
    .<strong>variance_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the sample variance of data relative to the
given value of mean.  The function is computed with \Hat\mu
replaced by the value of mean that you supply,</p>

<p>\Hat\sigma^2 = (1/(N-1)) \sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 181</span>

static VALUE
stats_s_variance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_variance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance_with_fixed_mean-class_method">
  
    .<strong>variance_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an unbiased estimate of the variance of
data when the population mean mean of the underlying
distribution is known a priori.  In this case the estimator for
the variance uses the factor 1/N and the sample mean
\Hat\mu is replaced by the known population mean \mu,</p>

<p>\Hat\sigma^2 = (1/N) \sum (x_i - \mu)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 414</span>

static VALUE
stats_s_variance_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_variance_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wabsdev-class_method">
  
    .<strong>wabsdev</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted absolute deviation from the weighted
mean of data.  The absolute deviation from the mean is defined as,</p>

<table>
  <tbody>
    <tr>
      <td>absdev = (\sum w_i</td>
      <td>x_i - \Hat\mu</td>
      <td>) / (\sum w_i)</td>
    </tr>
  </tbody>
</table>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1555</span>

static VALUE
stats_s_wabsdev(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wabsdev, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wabsdev_m-class_method">
  
    .<strong>wabsdev_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the absolute deviation of the weighted dataset
data about the given weighted mean wmean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1601</span>

static VALUE
stats_s_wabsdev_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wabsdev_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wkurtosis-class_method">
  
    .<strong>wkurtosis</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted kurtosis of the dataset data.</p>

<p>kurtosis = ((\sum w_i ((x_i - \Hat x)/\Hat \sigma)^4) / (\sum w_i)) - 3</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1746</span>

static VALUE
stats_s_wkurtosis(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wkurtosis, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wkurtosis_m_sd-class_method">
  
    .<strong>wkurtosis_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted kurtosis of the dataset data
using the given values of the weighted mean and weighted standard
deviation, wmean and wsd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wsd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1794</span>

static VALUE
stats_s_wkurtosis_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wkurtosis_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wmean-class_method">
  
    .<strong>wmean</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the weighted mean of the dataset data with
stride stride and length n, using the set of weights w
with stride wstride and length n.  The weighted mean is defined as,</p>

<p>\Hat\mu = (\sum w_i x_i) / (\sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1108
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120
1121
1122
1123</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1108</span>

static VALUE
stats_s_wmean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wmean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd-class_method">
  
    .<strong>wsd</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
This function returns the square root of the corresponding variance
function gsl_stats_wvariance above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1255</span>

static VALUE
stats_s_wsd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wsd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd_m-class_method">
  
    .<strong>wsd_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the square root of the corresponding variance
function gsl_stats_wvariance_m above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1301</span>

static VALUE
stats_s_wsd_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wsd_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd_with_fixed_mean-class_method">
  
    .<strong>wsd_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
This function returns the square root of the corresponding variance
function above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1405</span>

static VALUE
stats_s_wsd_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wsd_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wskew-class_method">
  
    .<strong>wskew</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted skewness of the dataset data.</p>

<p>skew = (\sum w_i ((x_i - \Hat x)/\Hat \sigma)^3) / (\sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1649</span>

static VALUE
stats_s_wskew(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wskew, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wskew_m_sd-class_method">
  
    .<strong>wskew_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted skewness of the dataset data
using the given values of the weighted mean and weighted standard
deviation, wmean and wsd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wsd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1697</span>

static VALUE
stats_s_wskew_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wskew_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wtss-class_method">
  
    .<strong>wtss</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the weighted total sum of squares (TSS) of
data about the weighted mean.  For gsl_stats_wtss_m the
user-supplied value of wmean is used, and for gsl_stats_wtss
it is computed using gsl_stats_wmean.</p>

<p>TSS =  \sum w_i (x_i - wmean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1456</span>

static VALUE
stats_s_wtss(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wtss, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wtss_m-class_method">
  
    .<strong>wtss_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the weighted total sum of squares (TSS) of
data about the weighted mean.  For gsl_stats_wtss_m the
user-supplied value of wmean is used, and for gsl_stats_wtss
it is computed using gsl_stats_wmean.</p>

<p>TSS =  \sum w_i (x_i - wmean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1506</span>

static VALUE
stats_s_wtss_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wtss_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance-class_method">
  
    .<strong>wvariance</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the estimated variance of the dataset data
with stride stride and length n, using the set of weights
w with stride wstride and length n.  The estimated
variance of a weighted dataset is calculated as,</p>

<p>\Hat\sigma^2 = ((\sum w_i)/((\sum w_i)^2 - \sum (w_i^2)))
              \sum w_i (x_i - \Hat\mu)^2</p>

<p>Note that this expression reduces to an unweighted variance with the
familiar 1/(N-1) factor when there are N equal non-zero
weights.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1161</span>

static VALUE
stats_s_wvariance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wvariance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance_m-class_method">
  
    .<strong>wvariance_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the estimated variance of the weighted dataset
data using the given weighted mean wmean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1207</span>

static VALUE
stats_s_wvariance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wvariance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance_with_fixed_mean-class_method">
  
    .<strong>wvariance_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an unbiased estimate of the variance of the weighted
dataset data when the population mean mean of the underlying
distribution is known a priori.  In this case the estimator for
the variance replaces the sample mean \Hat\mu by the known
population mean \mu,</p>

<p>\Hat\sigma^2 = (\sum w_i (x_i - \mu)^2) / (\sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1355</span>

static VALUE
stats_s_wvariance_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wvariance_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Sat Mar 25 10:15:28 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.8 (ruby-2.4.0).
</div>

    </div>
  </body>
</html>