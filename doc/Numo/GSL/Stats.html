<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Numo::GSL::Stats
  
    &mdash; Documentation by YARD 0.9.8
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Numo::GSL::Stats";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../x_index.html">Index (S)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Numo.html" title="Numo (module)">Numo</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../GSL.html" title="Numo::GSL (module)">GSL</a></span></span>
     &raquo; 
    <span class="title">Stats</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Numo::GSL::Stats
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>ext/numo/gsl/stats/gsl_stats.c</dd>
  </dl>
  
</div>








  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#absdev-class_method" title="absdev (class method)">.<strong>absdev</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the absolute deviation from the mean of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#absdev_m-class_method" title="absdev_m (class method)">.<strong>absdev_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the absolute deviation of the dataset data relative to the given value of mean,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#correlation-class_method" title="correlation (class method)">.<strong>correlation</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function efficiently computes the Pearson correlation coefficient between the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#covariance-class_method" title="covariance (class method)">.<strong>covariance</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the covariance of the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#covariance_m-class_method" title="covariance_m (class method)">.<strong>covariance_m</strong>(data1[], data2[], mean1, mean2, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the covariance of the datasets data1 and data2 using the given values of the means, mean1 and mean2.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#kurtosis-class_method" title="kurtosis (class method)">.<strong>kurtosis</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the kurtosis of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#kurtosis_m_sd-class_method" title="kurtosis_m_sd (class method)">.<strong>kurtosis_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the kurtosis of the dataset data using the given values of the mean mean and standard deviation sd,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lag1_autocorrelation-class_method" title="lag1_autocorrelation (class method)">.<strong>lag1_autocorrelation</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the lag-1 autocorrelation of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lag1_autocorrelation_m-class_method" title="lag1_autocorrelation_m (class method)">.<strong>lag1_autocorrelation_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the lag-1 autocorrelation of the dataset data using the given value of the mean mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max-class_method" title="max (class method)">.<strong>max</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the maximum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max_index-class_method" title="max_index (class method)">.<strong>max_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index of the maximum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#mean-class_method" title="mean (class method)">.<strong>mean</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the arithmetic mean of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#median_from_sorted_data-class_method" title="median_from_sorted_data (class method)">.<strong>median_from_sorted_data</strong>(sorted_data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the median value of sorted_data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min-class_method" title="min (class method)">.<strong>min</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the minimum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min_index-class_method" title="min_index (class method)">.<strong>min_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the index of the minimum value in data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax-class_method" title="minmax (class method)">.<strong>minmax</strong>(data[], [axis0,axis1,..])  &#x21d2; [Numo::DFloat, Numo::DFloat] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function finds both the minimum and maximum values min, max in data in a single pass.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax_index-class_method" title="minmax_index (class method)">.<strong>minmax_index</strong>(*args)  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the indexes min_index, max_index of the minimum and maximum values in data in a single pass.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#quantile_from_sorted_data-class_method" title="quantile_from_sorted_data (class method)">.<strong>quantile_from_sorted_data</strong>(sorted_data[], f, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns a quantile value of sorted_data, a double-precision array of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd-class_method" title="sd (class method)">.<strong>sd</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd_m-class_method" title="sd_m (class method)">.<strong>sd_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sd_with_fixed_mean-class_method" title="sd_with_fixed_mean (class method)">.<strong>sd_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function calculates the standard deviation of data for a fixed population mean mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#skew-class_method" title="skew (class method)">.<strong>skew</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the skewness of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#skew_m_sd-class_method" title="skew_m_sd (class method)">.<strong>skew_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the skewness of the dataset data using the given values of the mean mean and standard deviation sd,.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#spearman-class_method" title="spearman (class method)">.<strong>spearman</strong>(data1[], data2[], work[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the Spearman rank correlation coefficient between the datasets data1 and data2 which must both be of the same length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tss-class_method" title="tss (class method)">.<strong>tss</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the total sum of squares (TSS) of data about the mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tss_m-class_method" title="tss_m (class method)">.<strong>tss_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the total sum of squares (TSS) of data about the mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance-class_method" title="variance (class method)">.<strong>variance</strong>(data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the estimated, or sample, variance of data, a dataset of length n with stride stride.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance_m-class_method" title="variance_m (class method)">.<strong>variance_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the sample variance of data relative to the given value of mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variance_with_fixed_mean-class_method" title="variance_with_fixed_mean (class method)">.<strong>variance_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an unbiased estimate of the variance of data when the population mean mean of the underlying distribution is known a priori.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wabsdev-class_method" title="wabsdev (class method)">.<strong>wabsdev</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted absolute deviation from the weighted mean of data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wabsdev_m-class_method" title="wabsdev_m (class method)">.<strong>wabsdev_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wkurtosis-class_method" title="wkurtosis (class method)">.<strong>wkurtosis</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted kurtosis of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wkurtosis_m_sd-class_method" title="wkurtosis_m_sd (class method)">.<strong>wkurtosis_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted kurtosis of the dataset data using the given values of the weighted mean and weighted standard deviation, wmean and wsd.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wmean-class_method" title="wmean (class method)">.<strong>wmean</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the weighted mean of the dataset data with stride stride and length n, using the set of weights w with stride wstride and length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd-class_method" title="wsd (class method)">.<strong>wsd</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd_m-class_method" title="wsd_m (class method)">.<strong>wsd_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wsd_with_fixed_mean-class_method" title="wsd_with_fixed_mean (class method)">.<strong>wsd_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The standard deviation is defined as the square root of the variance.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wskew-class_method" title="wskew (class method)">.<strong>wskew</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted skewness of the dataset data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wskew_m_sd-class_method" title="wskew_m_sd (class method)">.<strong>wskew_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes the weighted skewness of the dataset data using the given values of the weighted mean and weighted standard deviation, wmean and wsd.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wtss-class_method" title="wtss (class method)">.<strong>wtss</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the weighted total sum of squares (TSS) of data about the weighted mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wtss_m-class_method" title="wtss_m (class method)">.<strong>wtss_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>These functions return the weighted total sum of squares (TSS) of data about the weighted mean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance-class_method" title="wvariance (class method)">.<strong>wvariance</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the estimated variance of the dataset data with stride stride and length n, using the set of weights w with stride wstride and length n.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance_m-class_method" title="wvariance_m (class method)">.<strong>wvariance_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function returns the estimated variance of the weighted dataset data using the given weighted mean wmean.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#wvariance_with_fixed_mean-class_method" title="wvariance_with_fixed_mean (class method)">.<strong>wvariance_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; Numo::DFloat </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>This function computes an unbiased estimate of the variance of the weighted dataset data when the population mean mean of the underlying distribution is known a priori.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="absdev-class_method">
  
    .<strong>absdev</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the absolute deviation from the mean of
data, a dataset of length n with stride stride.  The
absolute deviation from the mean is defined as,</p>

<table>
  <tbody>
    <tr>
      <td>absdev  = (1/N) \sum</td>
      <td>x_i - \Hat\mu</td>
    </tr>
  </tbody>
</table>

<p>where x_i are the elements of the dataset data.  The
absolute deviation from the mean provides a more robust measure of the
width of a distribution than the variance.  This function computes the
mean of data via a call to gsl_stats_mean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


509
510
511
512
513
514
515
516
517
518
519
520
521
522
523</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 509</span>

static VALUE
stats_s_absdev(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_absdev, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="absdev_m-class_method">
  
    .<strong>absdev_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the absolute deviation of the dataset data
relative to the given value of mean,</p>

<table>
  <tbody>
    <tr>
      <td>absdev  = (1/N) \sum</td>
      <td>x_i - mean</td>
    </tr>
  </tbody>
</table>

<p>This function is useful if you have already computed the mean of
data (and want to avoid recomputing it), or wish to calculate the
absolute deviation relative to another value (such as zero, or the
median).</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 557</span>

static VALUE
stats_s_absdev_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_absdev_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="correlation-class_method">
  
    .<strong>correlation</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function efficiently computes the Pearson correlation coefficient
between the datasets data1 and data2 which must both be of
the same length n.
r = cov(x, y) / (\Hat\sigma_x \Hat\sigma_y)
= @\sum (x_i - \Hat x) (y_i - \Hat y)
   \over
   \sqrt@{1/(n-1) \sum (x_i - \Hat x)^2@ \sqrt@\sum (y_i - \Hat y)^2@
  @}</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


990
991
992
993
994
995
996
997
998
999
1000
1001
1002
1003
1004
1005</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 990</span>

static VALUE
stats_s_correlation(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_correlation, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="covariance-class_method">
  
    .<strong>covariance</strong>(data1[], data2[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the covariance of the datasets data1 and
data2 which must both be of the same length n.</p>

<p>covar = (1/(n - 1)) \sum_@= 1@^@n@ (x_i - \Hat x) (y_i - \Hat y)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 889</span>

static VALUE
stats_s_covariance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_covariance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="covariance_m-class_method">
  
    .<strong>covariance_m</strong>(data1[], data2[], mean1, mean2, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the covariance of the datasets data1 and
data2 using the given values of the means, mean1 and
mean2.  This is useful if you have already computed the means of
data1 and data2 and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean1</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean2</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 937</span>

static VALUE
stats_s_covariance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_covariance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="kurtosis-class_method">
  
    .<strong>kurtosis</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the kurtosis of data, a dataset of length
n with stride stride.  The kurtosis is defined as,</p>

<p>kurtosis = ((1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^4)  - 3</p>

<p>The kurtosis measures how sharply peaked a distribution is, relative to
its width.  The kurtosis is normalized to zero for a Gaussian
distribution.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


705
706
707
708
709
710
711
712
713
714
715
716
717
718
719</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 705</span>

static VALUE
stats_s_kurtosis(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_kurtosis, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="kurtosis_m_sd-class_method">
  
    .<strong>kurtosis_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the kurtosis of the dataset data using the
given values of the mean mean and standard deviation sd,</p>

<p>kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3</p>

<p>This function is useful if you have already computed the mean and
standard deviation of data and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>sd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 752</span>

static VALUE
stats_s_kurtosis_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_kurtosis_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);
    opt[1] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lag1_autocorrelation-class_method">
  
    .<strong>lag1_autocorrelation</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the lag-1 autocorrelation of the dataset data.</p>

<p>a_1 = @= 1@^@n@ (x_@i@ - \Hat\mu) (x_@i-1@ - \Hat\mu)
     \over
     \sum_@= 1@^@n@ (x_@i@ - \Hat\mu) (x_@i@ - \Hat\mu)@}</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


799
800
801
802
803
804
805
806
807
808
809
810
811
812
813</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 799</span>

static VALUE
stats_s_lag1_autocorrelation(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_lag1_autocorrelation, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lag1_autocorrelation_m-class_method">
  
    .<strong>lag1_autocorrelation_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the lag-1 autocorrelation of the dataset
data using the given value of the mean mean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 841</span>

static VALUE
stats_s_lag1_autocorrelation_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_lag1_autocorrelation_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="max-class_method">
  
    .<strong>max</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the maximum value in data, a dataset of
length n with stride stride.  The maximum value is defined
as the value of the element x_i which satisfies $x_i \ge x_j$
x_i &gt;= x_j for all j.</p>

<p>If you want instead to find the element with the largest absolute
magnitude you will need to apply fabs or abs to your data
before calling this function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1814</span>

static VALUE
stats_s_max(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_max, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="max_index-class_method">
  
    .<strong>max_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index of the maximum value in data, a
dataset of length n with stride stride.  The maximum value is
defined as the value of the element x_i which satisfies
$x_i \ge x_j$
x_i &gt;= x_j for all j.  When there are several equal maximum
elements then the first one is chosen.
 @overload max_index() =&gt; Integer
 @overload max_index(axis0,axis1,..) =&gt; Integer or Numo::Int32/64</p>

<p>@param [Numo::DFloat] data[]
 @return [Numo::UInt64]  return</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1969</span>

static VALUE
stats_s_max_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{0,0,0}};
    ndfunc_t ndf = {0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT, 3,1, ain,aout};

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_max_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_max_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="mean-class_method">
  
    .<strong>mean</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the arithmetic mean of data, a dataset of
length n with stride stride.  The arithmetic mean, or
sample mean, is denoted by \Hat\mu and defined as,</p>

<p>\Hat\mu = (1/N) \sum x_i</p>

<p>where x_i are the elements of the dataset data.  For
samples drawn from a gaussian distribution the variance of
\Hat\mu is \sigma^2 / N.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


88
89
90
91
92
93
94
95
96
97
98
99
100
101
102</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 88</span>

static VALUE
stats_s_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="median_from_sorted_data-class_method">
  
    .<strong>median_from_sorted_data</strong>(sorted_data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the median value of sorted_data, a dataset
of length n with stride stride.  The elements of the array
must be in ascending numerical order.  There are no checks to see
whether the data are sorted, so the function gsl_sort should
always be used first.</p>

<p>When the dataset has an odd number of elements the median is the value
of element (n-1)/2.  When the dataset has an even number of
elements the median is the mean of the two nearest middle values,
elements (n-1)/2 and n/2.  Since the algorithm for
computing the median involves interpolation this function always returns
a floating-point number, even for integer data types.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>sorted_data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2213
2214
2215
2216
2217
2218
2219
2220
2221
2222
2223
2224
2225
2226
2227</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2213</span>

static VALUE
stats_s_median_from_sorted_data(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_median_from_sorted_data, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="min-class_method">
  
    .<strong>min</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the minimum value in data, a dataset of
length n with stride stride.  The minimum value is defined
as the value of the element x_i which satisfies $x_i \le x_j$
x_i &lt;= x_j for all j.</p>

<p>If you want instead to find the element with the smallest absolute
magnitude you will need to apply fabs or abs to your data
before calling this function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1859</span>

static VALUE
stats_s_min(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_min, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="min_index-class_method">
  
    .<strong>min_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the index of the minimum value in data, a
dataset of length n with stride stride.  The minimum value
is defined as the value of the element x_i which satisfies
$x_i \ge x_j$
x_i &gt;= x_j for all j.  When there are several equal
minimum elements then the first one is chosen.
 @overload min_index() =&gt; Integer
 @overload min_index(axis0,axis1,..) =&gt; Integer or Numo::Int32/64</p>

<p>@param [Numo::DFloat] data[]
 @return [Numo::UInt64]  return</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2055</span>

static VALUE
stats_s_min_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{0,0,0}};
    ndfunc_t ndf = {0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT, 3,1, ain,aout};

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_min_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_min_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="minmax-class_method">
  
    .<strong>minmax</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>[Numo::DFloat, Numo::DFloat]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function finds both the minimum and maximum values min,
max in data in a single pass.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>[Numo::DFloat, Numo::DFloat]</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>array of [min, max]</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1899
1900
1901
1902
1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1899</span>

static VALUE
stats_s_minmax(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[2] = {{cDF,0},{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_minmax, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 2, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="minmax_index-class_method">
  
    .<strong>minmax_index</strong>(*args)  &#x21d2; <tt>Object</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the indexes min_index, max_index of
the minimum and maximum values in data in a single pass.
 @overload minmax_index() =&gt; [Integer, Integer]
 @overload minmax_index(axis0,axis1,..) =&gt; 2-element array of Integer or Numo::Int32/64</p>

<p>@param [Numo::DFloat] data[]
 @return [[Numo::UInt64, Numo::UInt64]]  array of [min_index, max_index]</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2145</span>

static VALUE
stats_s_minmax_index(int argc, VALUE *argv, VALUE mod)
{
    narray_t *na;
    VALUE idx, reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{Qnil,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[2] = {{0,0,0},{0,0,0}};
    ndfunc_t ndf = { 0, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3,2, ain,aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    GetNArray(argv[0],na);
    if (na-&gt;ndim==0) {
        return INT2FIX(0);
    }
    if (na-&gt;size &gt; (~(u_int32_t)0)) {
        aout[0].type = numo_cInt64;
        aout[1].type = numo_cInt64;
        idx = rb_narray_new(numo_cInt64, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_minmax_index_index64;
    } else {
        aout[0].type = numo_cInt32;
        aout[1].type = numo_cInt32;
        idx = rb_narray_new(numo_cInt32, na-&gt;ndim, na-&gt;shape);
        ndf.func = iter_stats_s_minmax_index_index32;
    }
    rb_funcall(idx, rb_intern(&quot;seq&quot;), 0);

    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);

    return na_ndloop(&amp;ndf, 3, argv[0], idx, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="quantile_from_sorted_data-class_method">
  
    .<strong>quantile_from_sorted_data</strong>(sorted_data[], f, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns a quantile value of sorted_data, a
double-precision array of length n with stride stride.  The
elements of the array must be in ascending numerical order.  The
quantile is determined by the f, a fraction between 0 and 1.  For
example, to compute the value of the 75th percentile f should have
the value 0.75.</p>

<p>There are no checks to see whether the data are sorted, so the function
gsl_sort should always be used first.</p>

<p>The quantile is found by interpolation, using the formula</p>

<p>quantile = (1 - \delta) x_i + \delta x_@i+1@</p>

<p>where i is floor((n - 1)f) and \delta is
(n-1)f - i.</p>

<p>Thus the minimum value of the array (data[0<em>stride]) is given by
f equal to zero, the maximum value (data[(n-1)</em>stride]) is
given by f equal to one and the median value is given by f
equal to 0.5.  Since the algorithm for computing quantiles involves
interpolation this function always returns a floating-point number, even
for integer data types.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>sorted_data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>f</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2275
2276
2277
2278
2279
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 2275</span>

static VALUE
stats_s_quantile_from_sorted_data(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_quantile_from_sorted_data, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd-class_method">
  
    .<strong>sd</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
These functions return the square root of the corresponding variance
functions above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


228
229
230
231
232
233
234
235
236
237
238
239
240
241
242</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 228</span>

static VALUE
stats_s_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd_m-class_method">
  
    .<strong>sd_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
These functions return the square root of the corresponding variance
functions above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 270</span>

static VALUE
stats_s_sd_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_sd_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sd_with_fixed_mean-class_method">
  
    .<strong>sd_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function calculates the standard deviation of data for a
fixed population mean mean.  The result is the square root of the
corresponding variance function.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 458</span>

static VALUE
stats_s_sd_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_sd_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="skew-class_method">
  
    .<strong>skew</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the skewness of data, a dataset of length
n with stride stride.  The skewness is defined as,</p>

<p>skew = (1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^3</p>

<p>where x_i are the elements of the dataset data.  The skewness
measures the asymmetry of the tails of a distribution.</p>

<p>The function computes the mean and estimated standard deviation of
data via calls to gsl_stats_mean and gsl_stats_sd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


608
609
610
611
612
613
614
615
616
617
618
619
620
621
622</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 608</span>

static VALUE
stats_s_skew(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_skew, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="skew_m_sd-class_method">
  
    .<strong>skew_m_sd</strong>(data[], mean, sd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the skewness of the dataset data using the
given values of the mean mean and standard deviation sd,</p>

<p>skew = (1/N) \sum ((x_i - mean)/sd)^3</p>

<p>These functions are useful if you have already computed the mean and
standard deviation of data and want to avoid recomputing them.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>sd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 655</span>

static VALUE
stats_s_skew_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_skew_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);
    opt[1] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="spearman-class_method">
  
    .<strong>spearman</strong>(data1[], data2[], work[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the Spearman rank correlation coefficient between
the datasets data1 and data2 which must both be of the same
length n. Additional workspace of size 2*n is required in
work. The Spearman rank correlation between vectors x and
y is equivalent to the Pearson correlation between the ranked
vectors x_R and y_R, where ranks are defined to be the
average of the positions of an element in the ascending order of the values.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data1[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data2[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>work[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1040
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1040</span>

static VALUE
stats_s_spearman(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce, v, buf = 0;
    narray_t *na;
    double *opt;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_spearman, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    GetNArray(argv[0],na);
    opt = ALLOCV_N(double,buf,na-&gt;size*2); // todo: get loop size
    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    v = na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
    ALLOCV_END(buf);
    return v;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="tss-class_method">
  
    .<strong>tss</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the total sum of squares (TSS) of data about
the mean.  For gsl_stats_tss_m the user-supplied value of
mean is used, and for gsl_stats_tss it is computed using
gsl_stats_mean.</p>

<p>TSS =  \sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


317
318
319
320
321
322
323
324
325
326
327
328
329
330
331</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 317</span>

static VALUE
stats_s_tss(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_tss, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="tss_m-class_method">
  
    .<strong>tss_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the total sum of squares (TSS) of data about
the mean.  For gsl_stats_tss_m the user-supplied value of
mean is used, and for gsl_stats_tss it is computed using
gsl_stats_mean.</p>

<p>TSS =  \sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 362</span>

static VALUE
stats_s_tss_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_tss_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance-class_method">
  
    .<strong>variance</strong>(data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the estimated, or sample, variance of
data, a dataset of length n with stride stride.  The
estimated variance is denoted by \Hat\sigma^2 and is defined by,</p>

<p>\Hat\sigma^2 = (1/(N-1)) \sum (x_i - \Hat\mu)^2</p>

<p>where x_i are the elements of the dataset data.  Note that
the normalization factor of 1/(N-1) results from the derivation
of \Hat\sigma^2 as an unbiased estimator of the population
variance \sigma^2.  For samples drawn from a Gaussian distribution
the variance of \Hat\sigma^2 itself is 2 \sigma^4 / N.</p>

<p>This function computes the mean via a call to gsl_stats_mean.  If
you have already computed the mean then you can pass it directly to
gsl_stats_variance_m.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


140
141
142
143
144
145
146
147
148
149
150
151
152
153
154</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 140</span>

static VALUE
stats_s_variance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_variance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;1) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=1)&quot;,argc);
    }
    reduce = na_reduce_dimension(argc-1, argv+1, 1, argv);
    return na_ndloop(&amp;ndf, 2, *argv, reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance_m-class_method">
  
    .<strong>variance_m</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the sample variance of data relative to the
given value of mean.  The function is computed with \Hat\mu
replaced by the value of mean that you supply,</p>

<p>\Hat\sigma^2 = (1/(N-1)) \sum (x_i - mean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 184</span>

static VALUE
stats_s_variance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_variance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="variance_with_fixed_mean-class_method">
  
    .<strong>variance_with_fixed_mean</strong>(data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an unbiased estimate of the variance of
data when the population mean mean of the underlying
distribution is known a priori.  In this case the estimator for
the variance uses the factor 1/N and the sample mean
\Hat\mu is replaced by the known population mean \mu,</p>

<p>\Hat\sigma^2 = (1/N) \sum (x_i - \mu)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 412</span>

static VALUE
stats_s_variance_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[2] = {{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_variance_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     2, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[1]);

    reduce = na_reduce_dimension(argc-2, argv+2, 1, argv);
    return na_ndloop3(&amp;ndf, opt, 2, argv[0], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wabsdev-class_method">
  
    .<strong>wabsdev</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted absolute deviation from the weighted
mean of data.  The absolute deviation from the mean is defined as,</p>

<table>
  <tbody>
    <tr>
      <td>absdev = (\sum w_i</td>
      <td>x_i - \Hat\mu</td>
      <td>) / (\sum w_i)</td>
    </tr>
  </tbody>
</table>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1530</span>

static VALUE
stats_s_wabsdev(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wabsdev, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wabsdev_m-class_method">
  
    .<strong>wabsdev_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the absolute deviation of the weighted dataset
data about the given weighted mean wmean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1575</span>

static VALUE
stats_s_wabsdev_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wabsdev_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wkurtosis-class_method">
  
    .<strong>wkurtosis</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted kurtosis of the dataset data.</p>

<p>kurtosis = ((\sum w_i ((x_i - \Hat x)/\Hat \sigma)^4) / (\sum w_i)) - 3</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1717</span>

static VALUE
stats_s_wkurtosis(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wkurtosis, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wkurtosis_m_sd-class_method">
  
    .<strong>wkurtosis_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted kurtosis of the dataset data
using the given values of the weighted mean and weighted standard
deviation, wmean and wsd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wsd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1764</span>

static VALUE
stats_s_wkurtosis_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wkurtosis_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wmean-class_method">
  
    .<strong>wmean</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the weighted mean of the dataset data with
stride stride and length n, using the set of weights w
with stride wstride and length n.  The weighted mean is defined as,</p>

<p>\Hat\mu = (\sum w_i x_i) / (\sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1092</span>

static VALUE
stats_s_wmean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wmean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd-class_method">
  
    .<strong>wsd</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
This function returns the square root of the corresponding variance
function gsl_stats_wvariance above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1236</span>

static VALUE
stats_s_wsd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wsd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd_m-class_method">
  
    .<strong>wsd_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the square root of the corresponding variance
function gsl_stats_wvariance_m above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1281</span>

static VALUE
stats_s_wsd_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wsd_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wsd_with_fixed_mean-class_method">
  
    .<strong>wsd_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The standard deviation is defined as the square root of the variance.
This function returns the square root of the corresponding variance
function above.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1383</span>

static VALUE
stats_s_wsd_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wsd_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wskew-class_method">
  
    .<strong>wskew</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted skewness of the dataset data.</p>

<p>skew = (\sum w_i ((x_i - \Hat x)/\Hat \sigma)^3) / (\sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1622</span>

static VALUE
stats_s_wskew(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wskew, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wskew_m_sd-class_method">
  
    .<strong>wskew_m_sd</strong>(w[], data[], wmean, wsd, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes the weighted skewness of the dataset data
using the given values of the weighted mean and weighted standard
deviation, wmean and wsd.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wsd</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1669</span>

static VALUE
stats_s_wskew_m_sd(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[2];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wskew_m_sd, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;4) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=4)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);
    opt[1] = NUM2DBL(argv[3]);

    reduce = na_reduce_dimension(argc-4, argv+4, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wtss-class_method">
  
    .<strong>wtss</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the weighted total sum of squares (TSS) of
data about the weighted mean.  For gsl_stats_wtss_m the
user-supplied value of wmean is used, and for gsl_stats_wtss
it is computed using gsl_stats_wmean.</p>

<p>TSS =  \sum w_i (x_i - wmean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1433</span>

static VALUE
stats_s_wtss(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wtss, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wtss_m-class_method">
  
    .<strong>wtss_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>These functions return the weighted total sum of squares (TSS) of
data about the weighted mean.  For gsl_stats_wtss_m the
user-supplied value of wmean is used, and for gsl_stats_wtss
it is computed using gsl_stats_wmean.</p>

<p>TSS =  \sum w_i (x_i - wmean)^2</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1482</span>

static VALUE
stats_s_wtss_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wtss_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance-class_method">
  
    .<strong>wvariance</strong>(w[], data[], [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the estimated variance of the dataset data
with stride stride and length n, using the set of weights
w with stride wstride and length n.  The estimated
variance of a weighted dataset is calculated as,</p>

<p>\Hat\sigma^2 = ((\sum w_i)/((\sum w_i)^2 - \sum (w_i^2)))
              \sum w_i (x_i - \Hat\mu)^2</p>

<p>Note that this expression reduces to an unweighted variance with the
familiar 1/(N-1) factor when there are N equal non-zero
weights.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1144</span>

static VALUE
stats_s_wvariance(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wvariance, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;2) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=2)&quot;,argc);
    }

    reduce = na_reduce_dimension(argc-2, argv+2, 2, argv);
    return na_ndloop(&amp;ndf, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance_m-class_method">
  
    .<strong>wvariance_m</strong>(w[], data[], wmean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function returns the estimated variance of the weighted dataset
data using the given weighted mean wmean.</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>wmean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1189</span>

static VALUE
stats_s_wvariance_m(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wvariance_m, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="wvariance_with_fixed_mean-class_method">
  
    .<strong>wvariance_with_fixed_mean</strong>(w[], data[], mean, [axis0,axis1,..])  &#x21d2; <tt>Numo::DFloat</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>This function computes an unbiased estimate of the variance of the weighted
dataset data when the population mean mean of the underlying
distribution is known a priori.  In this case the estimator for
the variance replaces the sample mean \Hat\mu by the known
population mean \mu,</p>

<p>\Hat\sigma^2 = (\sum w_i (x_i - \mu)^2) / (\sum w_i)</p>


  </div>
</div>
<div class="tags">
  
  
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>w[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>data[]</span>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>mean</span>
      
      
        <span class='type'>(<tt>Float</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Numo::DFloat</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>return</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/numo/gsl/stats/gsl_stats.c', line 1334</span>

static VALUE
stats_s_wvariance_with_fixed_mean(int argc, VALUE *argv, VALUE mod)
{
    VALUE reduce;
    double opt[1];
    ndfunc_arg_in_t ain[3] = {{cDF,0},{cDF,0},{sym_reduce,0}};
    ndfunc_arg_out_t aout[1] = {{cDF,0}};
    ndfunc_t ndf = { iter_stats_s_wvariance_with_fixed_mean, STRIDE_LOOP_NIP|NDF_FLAT_REDUCE|NDF_EXTRACT,
                     3, 1, ain, aout };

    if (argc&lt;3) {
        rb_raise(rb_eArgError,&quot;wrong number of argument (%d for &gt;=3)&quot;,argc);
    }

    opt[0] = NUM2DBL(argv[2]);

    reduce = na_reduce_dimension(argc-3, argv+3, 2, argv);
    return na_ndloop3(&amp;ndf, opt, 3, argv[0], argv[1], reduce);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Sun Mar 19 00:56:49 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.8 (ruby-2.4.0).
</div>

    </div>
  </body>
</html>